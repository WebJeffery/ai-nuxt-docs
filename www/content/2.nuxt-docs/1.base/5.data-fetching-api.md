---
title: æ•°æ®è·å–ä¸ API è°ƒç”¨
description: æ·±åº¦è§£æ Nuxt æ¡†æ¶ä¸­çš„æ•°æ®è·å–æœºåˆ¶ï¼ŒåŒ…æ‹¬å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯æ•°æ®è·å–æ–¹å¼ã€API è·¯ç”±å¼€å‘ï¼Œä»¥åŠæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ
icon: 'lucide:database'
---

## æ¦‚è¿°

æ•°æ®è·å–æ˜¯ç°ä»£ Web åº”ç”¨å¼€å‘ä¸­çš„æ ¸å¿ƒç¯èŠ‚ï¼ŒNuxt æä¾›äº†ä¸€å¥—å®Œæ•´è€Œå¼ºå¤§çš„æ•°æ®è·å–è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡å°†æ·±åº¦è§£æ Nuxt æ¡†æ¶ä¸­çš„æ•°æ®è·å–æœºåˆ¶ï¼Œä»åŸºç¡€çš„å®¢æˆ·ç«¯è¯·æ±‚åˆ°å¤æ‚çš„æœåŠ¡ç«¯æ¸²æŸ“æ•°æ®è·å–ï¼Œå¸®åŠ©ä¸­é«˜çº§å‰ç«¯å¼€å‘è€…æŒæ¡é«˜æ•ˆçš„æ•°æ®ç®¡ç†ç­–ç•¥ã€‚

### ğŸ¯ æ ¸å¿ƒç›®æ ‡

- æŒæ¡ Nuxt å¤šç§æ•°æ®è·å–æ–¹å¼çš„ç‰¹ç‚¹å’Œä½¿ç”¨åœºæ™¯
- ç†è§£æœåŠ¡ç«¯æ¸²æŸ“ä¸­çš„æ•°æ®è·å–æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–
- å­¦ä¼šæ„å»ºé«˜æ•ˆçš„ API è·¯ç”±å’Œæ•°æ®ç¼“å­˜ç­–ç•¥
- æŒæ¡é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶çš„æœ€ä½³å®è·µ

### ğŸ’¡ æ ¸å¿ƒç‰¹æ€§

- **å¤šæ ·åŒ–æ•°æ®è·å–**: æ”¯æŒ `$fetch`ã€`useFetch`ã€`useLazyFetch` ç­‰å¤šç§æ•°æ®è·å–æ–¹å¼
- **æœåŠ¡ç«¯ä¼˜åŒ–**: å†…ç½®æ•°æ®é¢„æ¸²æŸ“ã€ç¼“å­˜æœºåˆ¶å’Œé”™è¯¯å¤„ç†
- **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ TypeScript æ”¯æŒï¼Œæä¾›ç±»å‹æ¨æ–­å’ŒéªŒè¯
- **æ€§èƒ½ä¼˜åŒ–**: è‡ªåŠ¨çš„æ•°æ®ç¼“å­˜ã€å»é‡å’Œæ‡’åŠ è½½æœºåˆ¶

::alert{icon="lucide:lightbulb" color="blue"}
**æ¶æ„æ€æƒ³**: Nuxt çš„æ•°æ®è·å–éµå¾ª "åŒæ„æ¸²æŸ“" åŸåˆ™ï¼ŒåŒä¸€å¥—ä»£ç æ—¢èƒ½åœ¨æœåŠ¡ç«¯è¿è¡Œè¿›è¡Œé¢„æ¸²æŸ“ï¼Œä¹Ÿèƒ½åœ¨å®¢æˆ·ç«¯è¿è¡Œæä¾›äº¤äº’ä½“éªŒã€‚
::

## æ•°æ®è·å–æ–¹å¼

### $fetch å…¨å±€æ–¹æ³•

`$fetch` æ˜¯ Nuxt æä¾›çš„å…¨å±€æ•°æ®è·å–æ–¹æ³•ï¼ŒåŸºäº `ofetch` åº“æ„å»ºï¼Œæä¾›äº†ç°ä»£åŒ–çš„ Promise-based APIã€‚

#### åŸºç¡€ç”¨æ³•

```typescript
// ç®€å•çš„ GET è¯·æ±‚
const data = await $fetch('/api/users')

// å¸¦å‚æ•°çš„ POST è¯·æ±‚
const result = await $fetch('/api/users', {
  method: 'POST',
  body: {
    name: 'John Doe',
    email: 'john@example.com'
  }
})

// å¸¦æŸ¥è¯¢å‚æ•°çš„è¯·æ±‚
const users = await $fetch('/api/users', {
  query: {
    page: 1,
    limit: 10,
    status: 'active'
  }
})
```

#### é«˜çº§é…ç½®

```typescript
// å®Œæ•´é…ç½®ç¤ºä¾‹
const response = await $fetch<UserResponse>('/api/users', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(userData),
  query: { include: 'profile' },
  timeout: 5000,
  retry: 3,
  retryDelay: 1000,
  onRequest({ request, options }) {
    // è¯·æ±‚æ‹¦æˆªå™¨
    console.log('å‘é€è¯·æ±‚:', request)
  },
  onResponse({ request, response }) {
    // å“åº”æ‹¦æˆªå™¨
    console.log('æ”¶åˆ°å“åº”:', response.status)
  },
  onRequestError({ request, error }) {
    // è¯·æ±‚é”™è¯¯å¤„ç†
    console.error('è¯·æ±‚å¤±è´¥:', error)
  }
})
```

#### ç±»å‹å®‰å…¨å®è·µ

```typescript
// å®šä¹‰å“åº”ç±»å‹
interface User {
  id: number
  name: string
  email: string
  profile?: {
    avatar: string
    bio: string
  }
}

interface ApiResponse<T> {
  data: T
  message: string
  code: number
}

// ä½¿ç”¨ç±»å‹æ³¨è§£
const users = await $fetch<ApiResponse<User[]>>('/api/users')
const user = await $fetch<ApiResponse<User>>(`/api/users/${userId}`)

// ç±»å‹å®ˆå«å‡½æ•°
function isValidUser(data: any): data is User {
  return data && 
         typeof data.id === 'number' && 
         typeof data.name === 'string' && 
         typeof data.email === 'string'
}

// ä½¿ç”¨ç±»å‹å®ˆå«
const userData = await $fetch('/api/user/123')
if (isValidUser(userData.data)) {
  // TypeScript ç°åœ¨çŸ¥é“ userData.data æ˜¯ User ç±»å‹
  console.log(userData.data.name)
}
```

::alert{icon="lucide:info" color="blue"}
**æœ€ä½³å®è·µ**: `$fetch` é€‚ç”¨äºå®¢æˆ·ç«¯çš„åŠ¨æ€æ•°æ®è·å–ï¼Œç‰¹åˆ«æ˜¯ç”¨æˆ·äº¤äº’è§¦å‘çš„ API è°ƒç”¨ã€‚å¯¹äºé¡µé¢åˆå§‹åŒ–æ•°æ®ï¼Œæ¨èä½¿ç”¨ `useFetch` æˆ– `useAsyncData`ã€‚
::

### useFetch ç»„åˆå¼ API

`useFetch` æ˜¯ Nuxt æä¾›çš„æ ¸å¿ƒæ•°æ®è·å–ç»„åˆå‡½æ•°ï¼Œä¸“ä¸º Vue ç»„ä»¶è®¾è®¡ï¼Œæä¾›å“åº”å¼æ•°æ®ç®¡ç†å’Œè‡ªåŠ¨çš„æœåŠ¡ç«¯æ¸²æŸ“æ”¯æŒã€‚

#### åŸºç¡€ä½¿ç”¨

```vue
<script setup lang="ts">
// åŸºç¡€ç”¨æ³•
const { data: users, pending, error, refresh } = await useFetch('/api/users')

// å¸¦ç±»å‹æ³¨è§£
const { data: user, pending: userLoading } = await useFetch<User>(`/api/users/${userId}`)

// æ¡ä»¶è·å–
const { data: posts } = await useFetch('/api/posts', {
  query: {
    category: route.query.category,
    page: route.query.page || 1
  }
})
</script>

<template>
  <div>
    <div v-if="pending">åŠ è½½ä¸­...</div>
    <div v-else-if="error">{{ error.message }}</div>
    <div v-else>
      <UserCard v-for="user in users" :key="user.id" :user="user" />
      <button @click="refresh()">åˆ·æ–°æ•°æ®</button>
    </div>
  </div>
</template>
```

#### é«˜çº§é…ç½®é€‰é¡¹

```vue
<script setup lang="ts">
const route = useRoute()

const { data, pending, error, refresh } = await useFetch('/api/posts', {
  // æŸ¥è¯¢å‚æ•°
  query: computed(() => ({
    category: route.query.category,
    page: route.query.page || 1,
    search: route.query.search
  })),
  
  // è¯·æ±‚é…ç½®
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${useAuthStore().token}`
  },
  
  // ç¼“å­˜é…ç½®
  key: 'posts-list', // ç¼“å­˜é”®å
  server: true,      // æ˜¯å¦åœ¨æœåŠ¡ç«¯æ‰§è¡Œ
  lazy: false,       // æ˜¯å¦å»¶è¿ŸåŠ è½½
  default: () => [], // é»˜è®¤å€¼
  
  // æ•°æ®è½¬æ¢
  transform: (data: any) => {
    return data.posts.map((post: any) => ({
      id: post.id,
      title: post.title,
      slug: post.slug,
      publishedAt: new Date(post.published_at)
    }))
  },
  
  // å“åº”æ‹¦æˆª
  onResponse({ response }) {
    console.log('å“åº”çŠ¶æ€:', response.status)
  },
  
  // é”™è¯¯å¤„ç†
  onResponseError({ error }) {
    console.error('API é”™è¯¯:', error)
  }
})

// ç›‘å¬è·¯ç”±å˜åŒ–è‡ªåŠ¨é‡æ–°è·å–
watch(() => route.query, () => {
  refresh()
})
</script>
```

#### å“åº”å¼æ•°æ®ç®¡ç†

```vue
<script setup lang="ts">
// å“åº”å¼æŸ¥è¯¢å‚æ•°
const searchParams = reactive({
  keyword: '',
  category: '',
  sortBy: 'created_at',
  order: 'desc'
})

// åŸºäºå“åº”å¼å‚æ•°çš„æ•°æ®è·å–
const { data: searchResults, pending: searching } = await useFetch('/api/search', {
  query: searchParams,
  key: 'search-results',
  watch: false, // ç¦ç”¨è‡ªåŠ¨ç›‘å¬ï¼Œæ‰‹åŠ¨æ§åˆ¶
})

// æ‰‹åŠ¨è§¦å‘æœç´¢
const handleSearch = () => {
  refresh()
}

// ç›‘å¬ç‰¹å®šå­—æ®µå˜åŒ–
watchDebounced(
  () => searchParams.keyword,
  () => {
    if (searchParams.keyword.length >= 2) {
      refresh()
    }
  },
  { debounce: 300 }
)
</script>
```

::alert{icon="lucide:zap" color="green"}
**æ€§èƒ½ä¼˜åŒ–**: `useFetch` ä¼šè‡ªåŠ¨ç¼“å­˜æ•°æ®å¹¶åœ¨æœåŠ¡ç«¯é¢„æ¸²æŸ“ï¼Œé¿å…å®¢æˆ·ç«¯çš„é‡å¤è¯·æ±‚ã€‚åˆç†ä½¿ç”¨ `key` å‚æ•°å¯ä»¥å®ç°æ›´ç²¾ç»†çš„ç¼“å­˜æ§åˆ¶ã€‚
::

### useLazyFetch å»¶è¿ŸåŠ è½½

`useLazyFetch` æä¾›éé˜»å¡çš„æ•°æ®è·å–æ–¹å¼ï¼Œç‰¹åˆ«é€‚ç”¨äºéå…³é”®æ•°æ®çš„åŠ è½½ï¼Œå¯ä»¥æå‡é¡µé¢çš„é¦–å±æ¸²æŸ“æ€§èƒ½ã€‚

#### åŸºç¡€æ¦‚å¿µ

```vue
<script setup lang="ts">
// ç«‹å³è¿”å›ï¼Œä¸é˜»å¡æ¸²æŸ“
const { 
  data: comments, 
  pending: loadingComments, 
  error: commentsError 
} = useLazyFetch('/api/posts/123/comments')

// å…³é”®æ•°æ®ä½¿ç”¨ useFetchï¼ˆé˜»å¡æ¸²æŸ“ï¼‰
const { data: post } = await useFetch('/api/posts/123')

// éå…³é”®æ•°æ®ä½¿ç”¨ useLazyFetchï¼ˆéé˜»å¡ï¼‰
const { data: relatedPosts } = useLazyFetch('/api/posts/123/related')
const { data: userStats } = useLazyFetch('/api/users/stats')
</script>

<template>
  <div>
    <!-- å…³é”®å†…å®¹ç«‹å³æ˜¾ç¤º -->
    <article>
      <h1>{{ post.title }}</h1>
      <div v-html="post.content"></div>
    </article>
    
    <!-- éå…³é”®å†…å®¹å»¶è¿ŸåŠ è½½ -->
    <aside>
      <div v-if="loadingComments">åŠ è½½è¯„è®ºä¸­...</div>
      <CommentList v-else-if="comments" :comments="comments" />
      
      <div v-if="relatedPosts">
        <h3>ç›¸å…³æ–‡ç« </h3>
        <PostCard v-for="post in relatedPosts" :key="post.id" :post="post" />
      </div>
    </aside>
  </div>
</template>
```

#### æ¡ä»¶å»¶è¿ŸåŠ è½½

```vue
<script setup lang="ts">
const user = useAuthUser()
const showAdvanced = ref(false)

// åªæœ‰åœ¨éœ€è¦æ—¶æ‰åŠ è½½é«˜çº§æ•°æ®
const { data: advancedData, pending: loadingAdvanced } = useLazyFetch('/api/advanced-stats', {
  server: false, // ä»…åœ¨å®¢æˆ·ç«¯æ‰§è¡Œ
  default: () => null,
  // æ¡ä»¶æ‰§è¡Œ
  execute: () => showAdvanced.value && user.value?.role === 'admin'
})

// åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
const toggleAdvanced = () => {
  showAdvanced.value = !showAdvanced.value
  if (showAdvanced.value && !advancedData.value) {
    // æ‰‹åŠ¨è§¦å‘æ•°æ®è·å–
    refresh()
  }
}
</script>
```

#### åˆ†é¡µå»¶è¿ŸåŠ è½½

```vue
<script setup lang="ts">
const page = ref(1)
const allPosts = ref<Post[]>([])

// åˆ†é¡µæ•°æ®å»¶è¿ŸåŠ è½½
const { data: newPosts, pending: loadingMore } = useLazyFetch('/api/posts', {
  query: computed(() => ({ page: page.value })),
  key: computed(() => `posts-page-${page.value}`),
  transform: (data: any) => data.posts,
  onResponse({ response }) {
    if (response.ok && response._data.posts.length > 0) {
      // è¿½åŠ æ–°æ•°æ®åˆ°ç°æœ‰åˆ—è¡¨
      allPosts.value.push(...response._data.posts)
    }
  }
})

// åŠ è½½æ›´å¤š
const loadMore = () => {
  page.value++
}

// ç›‘å¬æ•°æ®å˜åŒ–
watch(newPosts, (posts) => {
  if (posts && page.value === 1) {
    // é¦–é¡µæ•°æ®ï¼Œæ›¿æ¢ç°æœ‰æ•°æ®
    allPosts.value = posts
  }
})
</script>
```

### asyncData ä¸ fetch å¯¹æ¯”

åœ¨ Nuxt 2 ä¸­ï¼Œ`asyncData` å’Œ `fetch` æ˜¯ä¸»è¦çš„æ•°æ®è·å–æ–¹å¼ã€‚Nuxt 3 è¿›è¡Œäº†é‡å¤§æ”¹è¿›ï¼Œä½†ç†è§£å®ƒä»¬çš„å·®å¼‚æœ‰åŠ©äºè¿ç§»å’Œä¼˜åŒ–ã€‚

#### Nuxt 2 vs Nuxt 3 å¯¹æ¯”

| ç‰¹æ€§ | Nuxt 2 asyncData | Nuxt 2 fetch | Nuxt 3 useFetch |
|------|------------------|---------------|-----------------|
| æ‰§è¡Œæ—¶æœº | é¡µé¢ç»„ä»¶æ¸²æŸ“å‰ | ç»„ä»¶æ¸²æŸ“å‰/å | çµæ´»é…ç½® |
| æ•°æ®åˆå¹¶ | è‡ªåŠ¨åˆå¹¶åˆ° data | æ‰‹åŠ¨ç®¡ç† | å“åº”å¼å¼•ç”¨ |
| é”™è¯¯å¤„ç† | é¡µé¢çº§é”™è¯¯ | ç»„ä»¶çº§é”™è¯¯ | ç»†ç²’åº¦æ§åˆ¶ |
| ç±»å‹æ”¯æŒ | æœ‰é™ | æœ‰é™ | å®Œæ•´ TypeScript |
| ç¼“å­˜æœºåˆ¶ | æ— å†…ç½®ç¼“å­˜ | æ— å†…ç½®ç¼“å­˜ | è‡ªåŠ¨ç¼“å­˜ |

#### è¿ç§»ç¤ºä¾‹

```typescript
// Nuxt 2 asyncData
export default {
  async asyncData({ params, $http }) {
    const post = await $http.$get(`/api/posts/${params.id}`)
    const comments = await $http.$get(`/api/posts/${params.id}/comments`)
    
    return {
      post,
      comments
    }
  }
}

// Nuxt 3 ç­‰ä»·å®ç°
<script setup lang="ts">
const route = useRoute()

const { data: post } = await useFetch(`/api/posts/${route.params.id}`)
const { data: comments } = useLazyFetch(`/api/posts/${route.params.id}/comments`)
</script>
```

```typescript
// Nuxt 2 fetch
export default {
  data() {
    return {
      posts: [],
      loading: false
    }
  },
  
  async fetch() {
    this.loading = true
    try {
      this.posts = await this.$http.$get('/api/posts')
    } finally {
      this.loading = false
    }
  }
}

// Nuxt 3 ç­‰ä»·å®ç°
<script setup lang="ts">
const { data: posts, pending: loading } = await useFetch('/api/posts')
</script>
```

### useAsyncData ä¸ useFetch æ·±åº¦è§£æ

`useAsyncData` æ˜¯æ›´åº•å±‚çš„æ•°æ®è·å–ç»„åˆå‡½æ•°ï¼Œ`useFetch` å®é™…ä¸Šæ˜¯åŸºäº `useAsyncData` æ„å»ºçš„é«˜çº§å°è£…ã€‚

#### useAsyncData æ ¸å¿ƒæœºåˆ¶

```vue
<script setup lang="ts">
// useAsyncData åº•å±‚ç”¨æ³•
const { data, pending, error, refresh } = await useAsyncData('users', async () => {
  // è‡ªå®šä¹‰æ•°æ®è·å–é€»è¾‘
  const users = await $fetch('/api/users')
  const profiles = await Promise.all(
    users.map(user => $fetch(`/api/users/${user.id}/profile`))
  )
  
  return users.map((user, index) => ({
    ...user,
    profile: profiles[index]
  }))
})

// å¤æ‚çš„æ•°æ®å¤„ç†
const { data: processedData } = await useAsyncData('analytics', async () => {
  const [users, orders, products] = await Promise.all([
    $fetch('/api/users'),
    $fetch('/api/orders'),
    $fetch('/api/products')
  ])
  
  // å¤æ‚çš„æ•°æ®å¤„ç†é€»è¾‘
  return {
    totalUsers: users.length,
    totalRevenue: orders.reduce((sum, order) => sum + order.amount, 0),
    topProducts: products
      .sort((a, b) => b.sales - a.sales)
      .slice(0, 5)
  }
}, {
  default: () => ({
    totalUsers: 0,
    totalRevenue: 0,
    topProducts: []
  })
})
</script>
```

#### useFetch å®ç°åŸç†

```typescript
// useFetch çš„ç®€åŒ–å®ç°åŸç†
function useFetch(url: string, options: FetchOptions = {}) {
  return useAsyncData(options.key || url, () => {
    return $fetch(url, options)
  }, options)
}

// è‡ªå®šä¹‰ useFetch å¢å¼ºç‰ˆ
function useEnhancedFetch<T>(url: string, options: EnhancedFetchOptions<T> = {}) {
  const {
    transform,
    validator,
    retry = 3,
    retryDelay = 1000,
    ...fetchOptions
  } = options
  
  return useAsyncData<T>(
    options.key || url,
    async () => {
      let lastError: Error
      
      for (let i = 0; i <= retry; i++) {
        try {
          const data = await $fetch(url, fetchOptions)
          
          // æ•°æ®éªŒè¯
          if (validator && !validator(data)) {
            throw new Error('æ•°æ®éªŒè¯å¤±è´¥')
          }
          
          // æ•°æ®è½¬æ¢
          return transform ? transform(data) : data
        } catch (error) {
          lastError = error as Error
          
          if (i < retry) {
            await new Promise(resolve => setTimeout(resolve, retryDelay))
          }
        }
      }
      
      throw lastError!
    },
    {
      ...options,
      default: options.default || (() => null)
    }
  )
}
```

#### é€‰æ‹©ç­–ç•¥

```typescript
// å†³ç­–æ ‘ï¼šä½•æ—¶ä½¿ç”¨å“ªç§æ–¹æ³•

// 1. ç®€å•çš„ API è°ƒç”¨ â†’ useFetch
const { data: users } = await useFetch('/api/users')

// 2. éœ€è¦è‡ªå®šä¹‰æ•°æ®å¤„ç†é€»è¾‘ â†’ useAsyncData
const { data: dashboard } = await useAsyncData('dashboard', async () => {
  // å¤æ‚çš„æ•°æ®èšåˆé€»è¾‘
  return await aggregateDashboardData()
})

// 3. å®¢æˆ·ç«¯åŠ¨æ€è°ƒç”¨ â†’ $fetch
const handleSubmit = async () => {
  const result = await $fetch('/api/submit', {
    method: 'POST',
    body: formData
  })
}

// 4. éé˜»å¡æ•°æ® â†’ useLazyFetch
const { data: recommendations } = useLazyFetch('/api/recommendations')
```

### å…±äº«é¢„æ¸²æŸ“æ•°æ®æœºåˆ¶ä¸æ€§èƒ½ä¼˜åŒ–

Nuxt çš„æ•°æ®è·å–æœºåˆ¶åŒ…å«äº†å¤æ‚çš„ç¼“å­˜å’Œå…±äº«æœºåˆ¶ï¼Œç†è§£è¿™äº›æœºåˆ¶å¯¹æ€§èƒ½ä¼˜åŒ–è‡³å…³é‡è¦ã€‚

#### æ•°æ®ç¼“å­˜æœºåˆ¶

```typescript
// å…¨å±€ç¼“å­˜é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: true,
  nitro: {
    storage: {
      cache: {
        driver: 'redis', // æˆ–è€… 'memory', 'fs'
        host: 'localhost',
        port: 6379
      }
    }
  }
})

// ç»„ä»¶ä¸­çš„ç¼“å­˜æ§åˆ¶
const { data: expensiveData } = await useFetch('/api/expensive-operation', {
  key: 'expensive-data',
  // ç¼“å­˜ 1 å°æ—¶
  getCachedData: (key) => {
    return nuxtApp.ssrContext?.cache?.[key] ?? nuxtApp.payload.data[key]
  },
  // è‡ªå®šä¹‰ç¼“å­˜ç­–ç•¥
  server: true,
  lazy: false
})
```

#### é¢„æ¸²æŸ“æ•°æ®å…±äº«

```vue
<!-- pages/posts/[id].vue -->
<script setup lang="ts">
// æœåŠ¡ç«¯é¢„æ¸²æŸ“çš„æ•°æ®ä¼šè‡ªåŠ¨åºåˆ—åŒ–åˆ°å®¢æˆ·ç«¯
const { data: post } = await useFetch(`/api/posts/${route.params.id}`, {
  key: `post-${route.params.id}` // ç¡®ä¿å”¯ä¸€çš„ç¼“å­˜é”®
})

// å­ç»„ä»¶å¯ä»¥å¤ç”¨çˆ¶ç»„ä»¶çš„æ•°æ®
const { data: author } = await useFetch(`/api/users/${post.value.authorId}`, {
  key: `author-${post.value.authorId}`,
  // ä»…åœ¨æ²¡æœ‰ç¼“å­˜æ—¶æ‰§è¡Œ
  default: () => null
})
</script>

<template>
  <div>
    <PostContent :post="post" />
    <AuthorInfo :author="author" />
  </div>
</template>
```

#### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```typescript
// 1. æ•°æ®é¢„å–ç­–ç•¥
// åœ¨è·¯ç”±åˆ‡æ¢å‰é¢„å–æ•°æ®
const router = useRouter()

router.beforeEach(async (to) => {
  if (to.name === 'post-detail') {
    // é¢„å–æ–‡ç« æ•°æ®
    await $fetch(`/api/posts/${to.params.id}`)
  }
})

// 2. æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
const { data: posts, refresh } = await useFetch('/api/posts', {
  key: 'posts-list',
  // åŸºäºæ—¶é—´æˆ³çš„ç¼“å­˜å¤±æ•ˆ
  getCachedData: (key) => {
    const cached = getCachedData(key)
    if (cached && Date.now() - cached.timestamp < 5 * 60 * 1000) {
      return cached.data
    }
    return null
  }
})

// 3. æ¡ä»¶æ•°æ®è·å–
const user = useAuthUser()

const { data: privateData } = await useFetch('/api/private-data', {
  // åªæœ‰è®¤è¯ç”¨æˆ·æ‰è·å–
  execute: () => !!user.value,
  server: false, // ç§äººæ•°æ®ä¸åœ¨æœåŠ¡ç«¯è·å–
  key: `private-${user.value?.id}`
})

// 4. æ•°æ®åˆ†ç‰‡åŠ è½½
const { data: posts } = await useFetch('/api/posts', {
  query: { 
    fields: 'id,title,excerpt', // åªè·å–å¿…è¦å­—æ®µ
    limit: 20 
  },
  key: 'posts-summary'
})

// è¯¦ç»†æ•°æ®å»¶è¿ŸåŠ è½½
const loadPostDetail = async (postId: string) => {
  return await $fetch(`/api/posts/${postId}`, {
    query: { fields: 'content,metadata,tags' }
  })
}
```

::alert{icon="lucide:performance" color="yellow"}
**æ€§èƒ½è¦ç‚¹**: 
1. åˆç†ä½¿ç”¨ç¼“å­˜é”®é¿å…é‡å¤è¯·æ±‚
2. ä¼˜å…ˆåŠ è½½å…³é”®æ•°æ®ï¼Œå»¶è¿ŸåŠ è½½éå…³é”®æ•°æ®
3. åˆ©ç”¨æœåŠ¡ç«¯æ¸²æŸ“å‡å°‘å®¢æˆ·ç«¯è¯·æ±‚
4. å®ç°æ™ºèƒ½çš„ç¼“å­˜å¤±æ•ˆç­–ç•¥
::

## æœåŠ¡ç«¯æ•°æ®è·å–

### æœåŠ¡ç«¯æ¸²æŸ“ä¸­çš„æ•°æ®è·å–

åœ¨ SSR ç¯å¢ƒä¸­ï¼Œæ•°æ®è·å–çš„æ‰§è¡Œç¯å¢ƒå’Œæ—¶æœºä¸å®¢æˆ·ç«¯æœ‰æ˜¾è‘—å·®å¼‚ï¼Œéœ€è¦ç‰¹åˆ«æ³¨æ„ä¸Šä¸‹æ–‡å’Œç”Ÿå‘½å‘¨æœŸã€‚

#### SSR æ•°æ®è·å–åŸç†

```typescript
// æœåŠ¡ç«¯æ¸²æŸ“æµç¨‹
/*
1. æ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚
2. æ‰§è¡Œé¡µé¢ç»„ä»¶çš„ setup()
3. è¿è¡Œ useFetch/useAsyncData
4. ç­‰å¾…æ‰€æœ‰å¼‚æ­¥æ•°æ®è·å–å®Œæˆ
5. æ¸²æŸ“ HTML å¹¶åºåˆ—åŒ–æ•°æ®
6. å‘é€å®Œæ•´çš„ HTML åˆ°å®¢æˆ·ç«¯
7. å®¢æˆ·ç«¯ hydrationï¼Œå¤ç”¨æœåŠ¡ç«¯æ•°æ®
*/

// pages/posts/index.vue
<script setup lang="ts">
// åœ¨æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯éƒ½ä¼šæ‰§è¡Œ
const { data: posts, pending } = await useFetch('/api/posts', {
  server: true, // ç¡®ä¿åœ¨æœåŠ¡ç«¯æ‰§è¡Œ
  key: 'posts-list',
  // æœåŠ¡ç«¯ä¸Šä¸‹æ–‡è®¿é—®
  onRequest({ options }) {
    // æ·»åŠ æœåŠ¡ç«¯ç‰¹æœ‰çš„è¯·æ±‚å¤´
    if (process.server) {
      options.headers = {
        ...options.headers,
        'x-server-request': 'true',
        'x-request-id': crypto.randomUUID()
      }
    }
  }
})

// ä»…åœ¨æœåŠ¡ç«¯æ‰§è¡Œçš„é€»è¾‘
if (process.server) {
  console.log('è¿è¡Œåœ¨æœåŠ¡ç«¯')
  // å¯ä»¥è®¿é—®æœåŠ¡ç«¯ç‰¹æœ‰çš„ API
  const serverOnlyData = await getServerSideData()
}
</script>
```

#### ä¸Šä¸‹æ–‡æ•°æ®ä¼ é€’

```typescript
// ä»æœåŠ¡ç«¯ä¼ é€’æ•°æ®åˆ°å®¢æˆ·ç«¯
// server/api/posts.get.ts
export default defineEventHandler(async (event) => {
  // è·å–è¯·æ±‚ä¸Šä¸‹æ–‡
  const headers = getHeaders(event)
  const query = getQuery(event)
  
  // æœåŠ¡ç«¯ç‰¹æœ‰çš„æ•°æ®è·å–
  const posts = await getPosts({
    userId: headers['x-user-id'],
    serverTime: new Date(),
    requestId: headers['x-request-id']
  })
  
  return {
    posts,
    meta: {
      total: posts.length,
      serverTime: new Date().toISOString(),
      requestId: headers['x-request-id']
    }
  }
})

// é¡µé¢ç»„ä»¶ä¸­æ¥æ”¶å’Œä½¿ç”¨
<script setup lang="ts">
const { data: postsData } = await useFetch('/api/posts')

// æœåŠ¡ç«¯æ•°æ®ä¼šè‡ªåŠ¨åºåˆ—åŒ–åˆ°å®¢æˆ·ç«¯
console.log('æœåŠ¡ç«¯æ—¶é—´:', postsData.value.meta.serverTime)
console.log('è¯·æ±‚ID:', postsData.value.meta.requestId)
</script>
```

#### SSR ç‰¹æœ‰çš„æ•°æ®å¤„ç†

```typescript
// composables/useSSRData.ts
export const useSSRData = () => {
  const nuxtApp = useNuxtApp()
  
  // æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†
  const setServerState = (key: string, value: any) => {
    if (process.server) {
      nuxtApp.ssrContext!.payload.data[key] = value
    }
  }
  
  const getServerState = (key: string) => {
    if (process.server) {
      return nuxtApp.ssrContext?.payload?.data[key]
    } else {
      return nuxtApp.payload.data[key]
    }
  }
  
  // æœåŠ¡ç«¯æ•°æ®é¢„å¤„ç†
  const preprocessServerData = async (data: any) => {
    if (process.server) {
      // åœ¨æœåŠ¡ç«¯å¯¹æ•°æ®è¿›è¡Œé¢„å¤„ç†
      return {
        ...data,
        processedAt: new Date().toISOString(),
        serverGenerated: true
      }
    }
    return data
  }
  
  return {
    setServerState,
    getServerState,
    preprocessServerData
  }
}

// ä½¿ç”¨ç¤ºä¾‹
<script setup lang="ts">
const { preprocessServerData } = useSSRData()

const { data: processedPosts } = await useFetch('/api/posts', {
  transform: preprocessServerData,
  key: 'processed-posts'
})
</script>
```

### æ•°æ®ç¼“å­˜æœºåˆ¶

Nuxt æä¾›äº†å¤šå±‚æ¬¡çš„ç¼“å­˜æœºåˆ¶ï¼Œä»å†…å­˜ç¼“å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨ï¼Œæ»¡è¶³ä¸åŒçš„æ€§èƒ½éœ€æ±‚ã€‚

#### å†…ç½®ç¼“å­˜ç­–ç•¥

```typescript
// nuxt.config.ts - å…¨å±€ç¼“å­˜é…ç½®
export default defineNuxtConfig({
  nitro: {
    // è·¯ç”±çº§ç¼“å­˜
    routeRules: {
      '/': { prerender: true },
      '/posts/**': { isr: 60 }, // 60ç§’ ISR ç¼“å­˜
      '/api/posts': { 
        headers: { 'Cache-Control': 's-maxage=60' } 
      }
    },
    
    // å­˜å‚¨å¼•æ“é…ç½®
    storage: {
      cache: {
        driver: 'cloudflare-kv', // åˆ†å¸ƒå¼ç¼“å­˜
        // driver: 'redis',
        // driver: 'memory',
        binding: 'CACHE'
      }
    }
  }
})

// ç»„ä»¶çº§ç¼“å­˜æ§åˆ¶
<script setup lang="ts">
const { data: cachedPosts } = await useFetch('/api/posts', {
  key: 'posts-cache',
  // è‡ªå®šä¹‰ç¼“å­˜é€»è¾‘
  getCachedData: (key) => {
    return getCachedData(key, {
      maxAge: 5 * 60 * 1000, // 5åˆ†é’Ÿç¼“å­˜
      staleWhileRevalidate: 24 * 60 * 60 * 1000 // 24å°æ—¶ SWR
    })
  }
})
</script>
```

#### æ™ºèƒ½ç¼“å­˜ç­–ç•¥

```typescript
// composables/useSmartCache.ts
export const useSmartCache = () => {
  const storage = useStorage()
  
  // å¤šå±‚ç¼“å­˜ç­–ç•¥
  const getWithCache = async <T>(
    key: string, 
    fetcher: () => Promise<T>,
    options: CacheOptions = {}
  ): Promise<T> => {
    const {
      ttl = 5 * 60 * 1000, // é»˜è®¤5åˆ†é’Ÿ
      staleTime = 2 * 60 * 1000, // 2åˆ†é’Ÿå†…è®¤ä¸ºæ˜¯æ–°é²œçš„
      maxStale = 24 * 60 * 60 * 1000 // æœ€å¤šä½¿ç”¨24å°æ—¶è¿‡æœŸæ•°æ®
    } = options
    
    const cacheKey = `cache:${key}`
    const cached = await storage.getItem(cacheKey)
    
    if (cached) {
      const age = Date.now() - cached.timestamp
      
      // æ•°æ®ä»ç„¶æ–°é²œ
      if (age < staleTime) {
        return cached.data
      }
      
      // æ•°æ®è¿‡æœŸä½†å¯ç”¨ï¼Œåå°æ›´æ–°
      if (age < maxStale) {
        // åå°å¼‚æ­¥æ›´æ–°
        Promise.resolve().then(async () => {
          try {
            const fresh = await fetcher()
            await storage.setItem(cacheKey, {
              data: fresh,
              timestamp: Date.now()
            })
          } catch (error) {
            console.warn('åå°ç¼“å­˜æ›´æ–°å¤±è´¥:', error)
          }
        })
        
        return cached.data
      }
    }
    
    // è·å–æ–°æ•°æ®å¹¶ç¼“å­˜
    try {
      const fresh = await fetcher()
      await storage.setItem(cacheKey, {
        data: fresh,
        timestamp: Date.now()
      })
      return fresh
    } catch (error) {
      // å¦‚æœæœ‰è¿‡æœŸç¼“å­˜ï¼Œé™çº§ä½¿ç”¨
      if (cached) {
        console.warn('API è¯·æ±‚å¤±è´¥ï¼Œä½¿ç”¨è¿‡æœŸç¼“å­˜:', error)
        return cached.data
      }
      throw error
    }
  }
  
  // ç¼“å­˜å¤±æ•ˆ
  const invalidateCache = async (pattern: string) => {
    const keys = await storage.getKeys(`cache:${pattern}`)
    await Promise.all(keys.map(key => storage.removeItem(key)))
  }
  
  return {
    getWithCache,
    invalidateCache
  }
}

// ä½¿ç”¨æ™ºèƒ½ç¼“å­˜
<script setup lang="ts">
const { getWithCache } = useSmartCache()

const { data: posts } = await useAsyncData('smart-posts', () => 
  getWithCache('posts-list', () => $fetch('/api/posts'), {
    ttl: 10 * 60 * 1000, // 10åˆ†é’Ÿç¼“å­˜
    staleTime: 5 * 60 * 1000 // 5åˆ†é’Ÿå†…è®¤ä¸ºæ–°é²œ
  })
)
</script>
```

#### ç¼“å­˜åŒæ­¥å’Œå¤±æ•ˆ

```typescript
// stores/cache.ts
export const useCacheStore = defineStore('cache', () => {
  const pendingInvalidations = ref<Set<string>>(new Set())
  
  // å…¨å±€ç¼“å­˜å¤±æ•ˆ
  const invalidatePattern = async (pattern: string) => {
    if (pendingInvalidations.value.has(pattern)) return
    
    pendingInvalidations.value.add(pattern)
    
    try {
      // å®¢æˆ·ç«¯ç¼“å­˜å¤±æ•ˆ
      await clearNuxtData(pattern)
      
      // æœåŠ¡ç«¯ç¼“å­˜å¤±æ•ˆï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (process.client) {
        await $fetch('/api/cache/invalidate', {
          method: 'POST',
          body: { pattern }
        })
      }
    } finally {
      pendingInvalidations.value.delete(pattern)
    }
  }
  
  // æ¡ä»¶æ€§ç¼“å­˜å¤±æ•ˆ
  const conditionalInvalidate = async (conditions: CacheInvalidationCondition[]) => {
    for (const condition of conditions) {
      if (await condition.check()) {
        await invalidatePattern(condition.pattern)
      }
    }
  }
  
  return {
    invalidatePattern,
    conditionalInvalidate
  }
})

// ä½¿ç”¨ç¤ºä¾‹
<script setup lang="ts">
const cacheStore = useCacheStore()

// æ•°æ®æ›´æ–°åå¤±æ•ˆç›¸å…³ç¼“å­˜
const updatePost = async (postId: string, data: PostUpdateData) => {
  await $fetch(`/api/posts/${postId}`, {
    method: 'PUT',
    body: data
  })
  
  // å¤±æ•ˆç›¸å…³ç¼“å­˜
  await cacheStore.invalidatePattern(`post-${postId}`)
  await cacheStore.invalidatePattern('posts-list')
  await cacheStore.invalidatePattern('posts-*')
}
</script>
```

### é”™è¯¯å¤„ç†ä¸é‡è¯•

å¥å£®çš„é”™è¯¯å¤„ç†æœºåˆ¶æ˜¯ç”Ÿäº§ç¯å¢ƒåº”ç”¨çš„å…³é”®ï¼Œéœ€è¦è€ƒè™‘ç½‘ç»œå¼‚å¸¸ã€æœåŠ¡å™¨é”™è¯¯ã€æ•°æ®éªŒè¯å¤±è´¥ç­‰å¤šç§åœºæ™¯ã€‚

#### å…¨å±€é”™è¯¯å¤„ç†

```typescript
// plugins/error-handler.client.ts
export default defineNuxtPlugin(() => {
  // å…¨å±€ API é”™è¯¯å¤„ç†
  const { $fetch } = useNuxtApp()
  
  // æ‹¦æˆªæ‰€æœ‰ $fetch é”™è¯¯
  $fetch.create({
    onResponseError({ response, error }) {
      const errorStore = useErrorStore()
      
      // æ ¹æ®é”™è¯¯ç±»å‹åˆ†ç±»å¤„ç†
      switch (response.status) {
        case 401:
          // æœªæˆæƒï¼Œè·³è½¬ç™»å½•
          navigateTo('/login')
          break
          
        case 403:
          // æƒé™ä¸è¶³
          errorStore.setError({
            type: 'permission',
            message: 'æƒé™ä¸è¶³ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'
          })
          break
          
        case 429:
          // è¯·æ±‚é™åˆ¶
          errorStore.setError({
            type: 'rate-limit',
            message: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
          })
          break
          
        case 500:
          // æœåŠ¡å™¨é”™è¯¯
          errorStore.setError({
            type: 'server',
            message: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•'
          })
          break
          
        default:
          // å…¶ä»–é”™è¯¯
          errorStore.setError({
            type: 'unknown',
            message: error.message || 'è¯·æ±‚å¤±è´¥'
          })
      }
    }
  })
})

// stores/error.ts
export const useErrorStore = defineStore('error', () => {
  const errors = ref<ErrorInfo[]>([])
  
  const setError = (error: ErrorInfo) => {
    errors.value.push({
      ...error,
      id: crypto.randomUUID(),
      timestamp: Date.now()
    })
    
    // è‡ªåŠ¨æ¸…é™¤é”™è¯¯ï¼ˆ5ç§’åï¼‰
    setTimeout(() => {
      clearError(error.id)
    }, 5000)
  }
  
  const clearError = (id: string) => {
    const index = errors.value.findIndex(e => e.id === id)
    if (index > -1) {
      errors.value.splice(index, 1)
    }
  }
  
  return {
    errors: readonly(errors),
    setError,
    clearError
  }
})
```

#### æ™ºèƒ½é‡è¯•æœºåˆ¶

```typescript
// composables/useRetryableFetch.ts
export const useRetryableFetch = <T>(
  url: string, 
  options: RetryableFetchOptions<T> = {}
) => {
  const {
    retries = 3,
    retryDelay = 1000,
    retryCondition = (error) => error.status >= 500,
    exponentialBackoff = true,
    maxDelay = 30000,
    onRetry,
    ...fetchOptions
  } = options
  
  return useAsyncData<T>(
    options.key || url,
    async () => {
      let lastError: any
      
      for (let attempt = 0; attempt <= retries; attempt++) {
        try {
          return await $fetch<T>(url, fetchOptions)
        } catch (error: any) {
          lastError = error
          
          // æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡è¯•
          if (attempt < retries && retryCondition(error)) {
            // è®¡ç®—å»¶è¿Ÿæ—¶é—´
            let delay = retryDelay
            if (exponentialBackoff) {
              delay = Math.min(retryDelay * Math.pow(2, attempt), maxDelay)
            }
            
            // è§¦å‘é‡è¯•å›è°ƒ
            onRetry?.(error, attempt + 1, delay)
            
            // ç­‰å¾…åé‡è¯•
            await new Promise(resolve => setTimeout(resolve, delay))
            continue
          }
          
          throw error
        }
      }
      
      throw lastError
    },
    {
      ...options,
      server: options.server ?? true
    }
  )
}

// ä½¿ç”¨ç¤ºä¾‹
<script setup lang="ts">
const { data: criticalData, error, pending } = useRetryableFetch('/api/critical-data', {
  retries: 5,
  retryDelay: 2000,
  exponentialBackoff: true,
  retryCondition: (error) => {
    // åªé‡è¯•æœåŠ¡å™¨é”™è¯¯å’Œç½‘ç»œé”™è¯¯
    return error.status >= 500 || error.name === 'NetworkError'
  },
  onRetry: (error, attempt, delay) => {
    console.log(`é‡è¯•ç¬¬ ${attempt} æ¬¡ï¼Œå»¶è¿Ÿ ${delay}ms`, error.message)
  }
})
</script>
```

#### é™çº§å’Œå®¹é”™æœºåˆ¶

```typescript
// composables/useFallbackData.ts
export const useFallbackData = <T>(
  primaryFetcher: () => Promise<T>,
  fallbackStrategies: FallbackStrategy<T>[],
  options: FallbackOptions<T> = {}
) => {
  const { defaultValue, timeout = 10000 } = options
  
  return useAsyncData<T>(
    options.key || 'fallback-data',
    async () => {
      // è¶…æ—¶æ§åˆ¶
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('è¯·æ±‚è¶…æ—¶')), timeout)
      })
      
      try {
        // å°è¯•ä¸»è¦æ•°æ®æº
        return await Promise.race([primaryFetcher(), timeoutPromise])
      } catch (primaryError) {
        console.warn('ä¸»è¦æ•°æ®æºå¤±è´¥:', primaryError)
        
        // å°è¯•é™çº§ç­–ç•¥
        for (const strategy of fallbackStrategies) {
          try {
            const result = await strategy.execute()
            console.info(`ä½¿ç”¨é™çº§ç­–ç•¥: ${strategy.name}`)
            return result
          } catch (fallbackError) {
            console.warn(`é™çº§ç­–ç•¥ ${strategy.name} å¤±è´¥:`, fallbackError)
          }
        }
        
        // æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥ï¼Œè¿”å›é»˜è®¤å€¼æˆ–æŠ›å‡ºé”™è¯¯
        if (defaultValue !== undefined) {
          console.info('ä½¿ç”¨é»˜è®¤å€¼')
          return defaultValue
        }
        
        throw primaryError
      }
    },
    options
  )
}

// ä½¿ç”¨ç¤ºä¾‹
<script setup lang="ts">
const { data: posts } = useFallbackData(
  // ä¸»è¦æ•°æ®æº
  () => $fetch('/api/posts'),
  
  // é™çº§ç­–ç•¥
  [
    {
      name: 'cached-data',
      execute: () => getCachedPosts()
    },
    {
      name: 'backup-api',
      execute: () => $fetch('/api/backup/posts')
    },
    {
      name: 'local-storage',
      execute: () => getPostsFromLocalStorage()
    }
  ],
  
  // é…ç½®
  {
    key: 'posts-with-fallback',
    defaultValue: [],
    timeout: 5000
  }
)
</script>
```

::alert{icon="lucide:shield" color="red"}
**å®¹é”™è¦ç‚¹**:
1. å®ç°å¤šå±‚æ¬¡çš„é”™è¯¯å¤„ç†æœºåˆ¶
2. æä¾›åˆç†çš„é™çº§ç­–ç•¥
3. é¿å…é”™è¯¯çº§è”å½±å“ç”¨æˆ·ä½“éªŒ
4. è®°å½•é”™è¯¯ä¿¡æ¯ç”¨äºé—®é¢˜æ’æŸ¥
::

## API è·¯ç”±

### server/api ç›®å½•ç»“æ„

Nuxt çš„ API è·¯ç”±é‡‡ç”¨åŸºäºæ–‡ä»¶çš„è·¯ç”±ç³»ç»Ÿï¼Œæä¾›äº†ä¸€å¥—å®Œæ•´çš„æœåŠ¡ç«¯ API å¼€å‘è§£å†³æ–¹æ¡ˆã€‚

#### åŸºç¡€ç›®å½•ç»“æ„

```
server/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ login.post.ts          # POST /api/auth/login
â”‚   â”‚   â”œâ”€â”€ logout.post.ts         # POST /api/auth/logout
â”‚   â”‚   â”œâ”€â”€ refresh.post.ts        # POST /api/auth/refresh
â”‚   â”‚   â””â”€â”€ profile.get.ts         # GET /api/auth/profile
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ index.get.ts           # GET /api/users
â”‚   â”‚   â”œâ”€â”€ index.post.ts          # POST /api/users
â”‚   â”‚   â”œâ”€â”€ [id].get.ts            # GET /api/users/:id
â”‚   â”‚   â”œâ”€â”€ [id].put.ts            # PUT /api/users/:id
â”‚   â”‚   â”œâ”€â”€ [id].delete.ts         # DELETE /api/users/:id
â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚       â”œâ”€â”€ posts.get.ts       # GET /api/users/:id/posts
â”‚   â”‚       â””â”€â”€ avatar.put.ts      # PUT /api/users/:id/avatar
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”œâ”€â”€ index.get.ts           # GET /api/posts
â”‚   â”‚   â”œâ”€â”€ index.post.ts          # POST /api/posts
â”‚   â”‚   â”œâ”€â”€ [slug].get.ts          # GET /api/posts/:slug
â”‚   â”‚   â”œâ”€â”€ [slug].put.ts          # PUT /api/posts/:slug
â”‚   â”‚   â”œâ”€â”€ [slug].delete.ts       # DELETE /api/posts/:slug
â”‚   â”‚   â””â”€â”€ [...path].get.ts       # GET /api/posts/** (é€šé…ç¬¦è·¯ç”±)
â”‚   â”œâ”€â”€ upload.post.ts             # POST /api/upload
â”‚   â”œâ”€â”€ search.get.ts              # GET /api/search
â”‚   â””â”€â”€ health.get.ts              # GET /api/health
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ auth.ts                    # è®¤è¯ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ cors.ts                    # CORS ä¸­é—´ä»¶
â”‚   â””â”€â”€ rateLimit.ts               # é™æµä¸­é—´ä»¶
â””â”€â”€ utils/
    â”œâ”€â”€ db.ts                      # æ•°æ®åº“å·¥å…·
    â”œâ”€â”€ validation.ts              # æ•°æ®éªŒè¯
    â””â”€â”€ response.ts                # å“åº”æ ¼å¼åŒ–
```

#### è·¯ç”±è§„åˆ™è¯¦è§£

```typescript
// æ–‡ä»¶åè§„åˆ™ä¸å¯¹åº”è·¯ç”±
/*
index.get.ts        â†’ GET /api/
users.get.ts        â†’ GET /api/users
users/index.get.ts  â†’ GET /api/users/
users/[id].get.ts   â†’ GET /api/users/:id
users/[...path].get.ts â†’ GET /api/users/**
*/

// æ”¯æŒçš„ HTTP æ–¹æ³•
// .get.ts     â†’ GET
// .post.ts    â†’ POST
// .put.ts     â†’ PUT
// .patch.ts   â†’ PATCH
// .delete.ts  â†’ DELETE
// .head.ts    â†’ HEAD
// .options.ts â†’ OPTIONS

// é€šç”¨å¤„ç†å™¨ï¼ˆæ”¯æŒæ‰€æœ‰æ–¹æ³•ï¼‰
// server/api/users.ts
export default defineEventHandler(async (event) => {
  const method = getMethod(event)
  
  switch (method) {
    case 'GET':
      return await getUsers(event)
    case 'POST':
      return await createUser(event)
    case 'PUT':
      return await updateUser(event)
    case 'DELETE':
      return await deleteUser(event)
    default:
      throw createError({
        statusCode: 405,
        statusMessage: 'Method Not Allowed'
      })
  }
})
```

### åˆ›å»º API ç«¯ç‚¹

#### åŸºç¡€ API ç«¯ç‚¹

```typescript
// server/api/users/index.get.ts
export default defineEventHandler(async (event) => {
  try {
    // è·å–æŸ¥è¯¢å‚æ•°
    const query = getQuery(event)
    const { page = 1, limit = 10, search, sort } = query
    
    // æ•°æ®éªŒè¯
    const validatedQuery = await validateQuery(query, {
      page: z.number().int().min(1).optional(),
      limit: z.number().int().min(1).max(100).optional(),
      search: z.string().optional(),
      sort: z.enum(['name', 'email', 'created_at']).optional()
    })
    
    // ä¸šåŠ¡é€»è¾‘
    const users = await getUsersList({
      page: Number(validatedQuery.page),
      limit: Number(validatedQuery.limit),
      search: validatedQuery.search,
      sort: validatedQuery.sort
    })
    
    // ç»Ÿä¸€å“åº”æ ¼å¼
    return {
      success: true,
      data: users.data,
      meta: {
        total: users.total,
        page: Number(validatedQuery.page),
        limit: Number(validatedQuery.limit),
        totalPages: Math.ceil(users.total / Number(validatedQuery.limit))
      }
    }
  } catch (error) {
    // é”™è¯¯å¤„ç†
    throw createError({
      statusCode: error.statusCode || 500,
      statusMessage: error.message || 'Internal Server Error'
    })
  }
})
```

#### åŠ¨æ€è·¯ç”±å‚æ•°

```typescript
// server/api/users/[id].get.ts
export default defineEventHandler(async (event) => {
  // è·å–è·¯ç”±å‚æ•°
  const userId = getRouterParam(event, 'id')
  
  // å‚æ•°éªŒè¯
  if (!userId || isNaN(Number(userId))) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid user ID'
    })
  }
  
  // è·å–ç”¨æˆ·æ•°æ®
  const user = await getUserById(Number(userId))
  
  if (!user) {
    throw createError({
      statusCode: 404,
      statusMessage: 'User not found'
    })
  }
  
  return {
    success: true,
    data: user
  }
})

// server/api/users/[id]/posts.get.ts
export default defineEventHandler(async (event) => {
  const userId = getRouterParam(event, 'id')
  const query = getQuery(event)
  
  // éªŒè¯ç”¨æˆ·å­˜åœ¨
  const user = await getUserById(Number(userId))
  if (!user) {
    throw createError({
      statusCode: 404,
      statusMessage: 'User not found'
    })
  }
  
  // è·å–ç”¨æˆ·æ–‡ç« 
  const posts = await getUserPosts(Number(userId), {
    page: Number(query.page) || 1,
    limit: Number(query.limit) || 10,
    status: query.status
  })
  
  return {
    success: true,
    data: posts
  }
})
```

#### å¤æ‚ä¸šåŠ¡é€»è¾‘å¤„ç†

```typescript
// server/api/posts/index.post.ts
export default defineEventHandler(async (event) => {
  // æ£€æŸ¥è®¤è¯
  const user = await requireAuthenticatedUser(event)
  
  // è·å–è¯·æ±‚ä½“
  const body = await readBody(event)
  
  // æ•°æ®éªŒè¯
  const validatedData = await validateCreatePost(body)
  
  // æƒé™æ£€æŸ¥
  if (!hasPermission(user, 'create_post')) {
    throw createError({
      statusCode: 403,
      statusMessage: 'Insufficient permissions'
    })
  }
  
  // å¼€å§‹äº‹åŠ¡
  const db = await getDatabase()
  const transaction = await db.transaction()
  
  try {
    // åˆ›å»ºæ–‡ç« 
    const post = await transaction.posts.create({
      ...validatedData,
      authorId: user.id,
      status: 'draft',
      createdAt: new Date()
    })
    
    // å¤„ç†æ ‡ç­¾
    if (validatedData.tags?.length > 0) {
      await transaction.postTags.createMany(
        validatedData.tags.map(tag => ({
          postId: post.id,
          tagId: tag.id
        }))
      )
    }
    
    // å¤„ç†é™„ä»¶
    if (validatedData.attachments?.length > 0) {
      await processAttachments(post.id, validatedData.attachments)
    }
    
    // æäº¤äº‹åŠ¡
    await transaction.commit()
    
    // å¼‚æ­¥ä»»åŠ¡
    await Promise.all([
      // å‘é€é€šçŸ¥
      sendNotification(user.id, 'post_created', { postId: post.id }),
      // æ›´æ–°æœç´¢ç´¢å¼•
      updateSearchIndex('posts', post),
      // æ¸…ç†ç¼“å­˜
      invalidateCache(['posts', `user:${user.id}:posts`])
    ])
    
    return {
      success: true,
      data: post,
      message: 'Post created successfully'
    }
  } catch (error) {
    // å›æ»šäº‹åŠ¡
    await transaction.rollback()
    
    // è®°å½•é”™è¯¯
    console.error('åˆ›å»ºæ–‡ç« å¤±è´¥:', error)
    
    throw createError({
      statusCode: 500,
      statusMessage: 'Failed to create post'
    })
  }
})
```

### è¯·æ±‚å¤„ç†ä¸å“åº”æ ¼å¼

#### ç»Ÿä¸€è¯·æ±‚å¤„ç†ä¸­é—´ä»¶

```typescript
// server/middleware/request-handler.ts
export default defineEventHandler(async (event) => {
  // åªå¤„ç† API è·¯ç”±
  if (!event.node.req.url?.startsWith('/api/')) {
    return
  }
  
  // è®¾ç½® CORS å¤´
  setHeaders(event, {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type,Authorization',
  })
  
  // å¤„ç† OPTIONS è¯·æ±‚
  if (getMethod(event) === 'OPTIONS') {
    event.node.res.statusCode = 200
    return ''
  }
  
  // è¯·æ±‚æ—¥å¿—
  const startTime = Date.now()
  const requestId = crypto.randomUUID()
  
  // è®¾ç½®è¯·æ±‚ä¸Šä¸‹æ–‡
  event.context.requestId = requestId
  event.context.startTime = startTime
  
  console.log(`[${requestId}] ${getMethod(event)} ${event.node.req.url}`)
  
  // åœ¨å“åº”ç»“æŸæ—¶è®°å½•è€—æ—¶
  event.node.res.on('finish', () => {
    const duration = Date.now() - startTime
    console.log(`[${requestId}] ${event.node.res.statusCode} ${duration}ms`)
  })
})

// server/middleware/error-handler.ts
export default defineEventHandler(async (event) => {
  try {
    // ç»§ç»­å¤„ç†å…¶ä»–ä¸­é—´ä»¶
    return
  } catch (error: any) {
    // ç»Ÿä¸€é”™è¯¯å¤„ç†
    const statusCode = error.statusCode || 500
    const message = error.message || 'Internal Server Error'
    
    // è®°å½•é”™è¯¯
    console.error(`[${event.context.requestId}] é”™è¯¯:`, error)
    
    // è¿”å›ç»Ÿä¸€é”™è¯¯æ ¼å¼
    setResponseStatus(event, statusCode)
    return {
      success: false,
      error: {
        code: error.code || 'INTERNAL_ERROR',
        message,
        requestId: event.context.requestId,
        timestamp: new Date().toISOString()
      }
    }
  }
})
```

#### å“åº”æ ¼å¼æ ‡å‡†åŒ–

```typescript
// server/utils/response.ts
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
    requestId?: string
    timestamp?: string
  }
  meta?: {
    total?: number
    page?: number
    limit?: number
    totalPages?: number
    hasNext?: boolean
    hasPrev?: boolean
  }
}

// æˆåŠŸå“åº”
export const successResponse = <T>(
  data: T, 
  meta?: ApiResponse<T>['meta']
): ApiResponse<T> => ({
  success: true,
  data,
  meta
})

// é”™è¯¯å“åº”
export const errorResponse = (
  code: string,
  message: string,
  details?: any,
  statusCode: number = 500
): never => {
  throw createError({
    statusCode,
    data: {
      success: false,
      error: {
        code,
        message,
        details,
        timestamp: new Date().toISOString()
      }
    }
  })
}

// åˆ†é¡µå“åº”
export const paginatedResponse = <T>(
  data: T[],
  total: number,
  page: number,
  limit: number
): ApiResponse<T[]> => ({
  success: true,
  data,
  meta: {
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
    hasNext: page * limit < total,
    hasPrev: page > 1
  }
})

// ä½¿ç”¨ç¤ºä¾‹
// server/api/posts/index.get.ts
export default defineEventHandler(async (event) => {
  const query = getQuery(event)
  const page = Number(query.page) || 1
  const limit = Number(query.limit) || 10
  
  const { posts, total } = await getPosts({ page, limit })
  
  return paginatedResponse(posts, total, page, limit)
})
```

#### é«˜çº§å“åº”å¤„ç†

```typescript
// server/utils/advanced-response.ts
export class ResponseBuilder<T = any> {
  private response: Partial<ApiResponse<T>> = { success: true }
  
  constructor(private event: H3Event) {}
  
  data(data: T): this {
    this.response.data = data
    return this
  }
  
  meta(meta: ApiResponse<T>['meta']): this {
    this.response.meta = meta
    return this
  }
  
  cache(maxAge: number): this {
    setHeader(this.event, 'Cache-Control', `max-age=${maxAge}`)
    return this
  }
  
  etag(value: string): this {
    setHeader(this.event, 'ETag', value)
    return this
  }
  
  location(url: string): this {
    setHeader(this.event, 'Location', url)
    return this
  }
  
  status(code: number): this {
    setResponseStatus(this.event, code)
    return this
  }
  
  build(): ApiResponse<T> {
    return this.response as ApiResponse<T>
  }
}

// æµå¼å“åº”å¤„ç†
export const streamResponse = (event: H3Event, generator: AsyncGenerator<any>) => {
  setHeader(event, 'Content-Type', 'text/plain')
  setHeader(event, 'Transfer-Encoding', 'chunked')
  
  return sendStream(event, generator)
}

// ä½¿ç”¨ç¤ºä¾‹
// server/api/posts/[id].get.ts
export default defineEventHandler(async (event) => {
  const postId = getRouterParam(event, 'id')
  const post = await getPostById(Number(postId))
  
  if (!post) {
    throw createError({
      statusCode: 404,
      statusMessage: 'Post not found'
    })
  }
  
  // ç”Ÿæˆ ETag
  const etag = generateEtag(post)
  const clientEtag = getHeader(event, 'if-none-match')
  
  if (clientEtag === etag) {
    return new ResponseBuilder(event)
      .status(304)
      .etag(etag)
      .build()
  }
  
  return new ResponseBuilder(event)
    .data(post)
    .cache(300) // ç¼“å­˜5åˆ†é’Ÿ
    .etag(etag)
    .build()
})

// æ–‡ä»¶ä¸Šä¼ å“åº”
// server/api/upload.post.ts
export default defineEventHandler(async (event) => {
  const files = await readMultipartFormData(event)
  const uploadResults = []
  
  for (const file of files || []) {
    if (file.type?.startsWith('image/')) {
      const result = await uploadFile(file)
      uploadResults.push(result)
    }
  }
  
  return new ResponseBuilder(event)
    .status(201)
    .data(uploadResults)
    .location(`/api/files/${uploadResults[0]?.id}`)
    .build()
})
```

::alert{icon="lucide:code" color="green"}
**API è®¾è®¡æœ€ä½³å®è·µ**:
1. éµå¾ª RESTful è®¾è®¡åŸåˆ™
2. å®ç°ç»Ÿä¸€çš„å“åº”æ ¼å¼
3. æä¾›å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶
4. æ”¯æŒè¯·æ±‚éªŒè¯å’Œå®‰å…¨æ§åˆ¶
5. å®ç°åˆç†çš„ç¼“å­˜ç­–ç•¥
::

## æ€»ç»“

æœ¬æ–‡æ·±åº¦è§£æäº† Nuxt æ¡†æ¶ä¸­çš„æ•°æ®è·å–ä¸ API è°ƒç”¨æœºåˆ¶ï¼Œæ¶µç›–äº†ä»åŸºç¡€çš„å®¢æˆ·ç«¯è¯·æ±‚åˆ°å¤æ‚çš„æœåŠ¡ç«¯æ¸²æŸ“æ•°æ®è·å–çš„å®Œæ•´ç”Ÿæ€ç³»ç»Ÿã€‚

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **æ•°æ®è·å–æ–¹å¼é€‰æ‹©**
   - `$fetch`ï¼šé€‚ç”¨äºå®¢æˆ·ç«¯åŠ¨æ€è°ƒç”¨
   - `useFetch`ï¼šç»„ä»¶çº§å“åº”å¼æ•°æ®è·å–çš„é¦–é€‰
   - `useLazyFetch`ï¼šéé˜»å¡æ•°æ®è·å–ï¼Œæå‡é¦–å±æ€§èƒ½
   - `useAsyncData`ï¼šåº•å±‚ APIï¼Œé€‚ç”¨äºå¤æ‚æ•°æ®å¤„ç†åœºæ™¯

2. **æœåŠ¡ç«¯æ¸²æŸ“ä¼˜åŒ–**
   - åˆ©ç”¨æ•°æ®é¢„æ¸²æŸ“æœºåˆ¶å‡å°‘å®¢æˆ·ç«¯è¯·æ±‚
   - å®ç°å¤šå±‚æ¬¡ç¼“å­˜ç­–ç•¥æå‡æ€§èƒ½
   - æ„å»ºå¥å£®çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

3. **API è·¯ç”±å¼€å‘**
   - åŸºäºæ–‡ä»¶çš„è·¯ç”±ç³»ç»Ÿï¼Œç›´è§‚ä¸”å¯ç»´æŠ¤
   - ç»Ÿä¸€çš„è¯·æ±‚å¤„ç†å’Œå“åº”æ ¼å¼
   - å®Œæ•´çš„ä¸­é—´ä»¶å’Œé”™è¯¯å¤„ç†æœºåˆ¶

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

- åˆç†ä½¿ç”¨ç¼“å­˜é”®é¿å…é‡å¤è¯·æ±‚
- ä¼˜å…ˆåŠ è½½å…³é”®æ•°æ®ï¼Œå»¶è¿ŸåŠ è½½éå…³é”®æ•°æ®
- å®ç°æ™ºèƒ½çš„ç¼“å­˜å¤±æ•ˆç­–ç•¥
- åˆ©ç”¨æœåŠ¡ç«¯æ¸²æŸ“å‡å°‘å®¢æˆ·ç«¯ç½‘ç»œè¯·æ±‚

### å¼€å‘æœ€ä½³å®è·µ

- å§‹ç»ˆä½¿ç”¨ TypeScript ç¡®ä¿ç±»å‹å®‰å…¨
- å®ç°ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆæœºåˆ¶
- è®¾è®¡åˆç†çš„é™çº§ç­–ç•¥ä¿è¯å¯ç”¨æ€§
- éµå¾ª RESTful API è®¾è®¡åŸåˆ™

é€šè¿‡æŒæ¡è¿™äº›æ ¸å¿ƒæŠ€æœ¯å’Œæœ€ä½³å®è·µï¼Œä¸­é«˜çº§å‰ç«¯å¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ã€å¯ç»´æŠ¤çš„ç°ä»£ Web åº”ç”¨ï¼Œå……åˆ†å‘æŒ¥ Nuxt æ¡†æ¶çš„æŠ€æœ¯ä¼˜åŠ¿ã€‚ 