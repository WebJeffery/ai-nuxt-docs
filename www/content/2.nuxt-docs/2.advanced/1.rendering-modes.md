---
title: æ¸²æŸ“æ¨¡å¼å·¥ä½œåŸç†
description: æ·±åº¦è§£æ Nuxt æ¡†æ¶ä¸­çš„æ¸²æŸ“æ¨¡å¼å·¥ä½œåŸç†ï¼ŒåŒ…æ‹¬ SSRã€CSRã€SSGã€ISRã€æ··åˆæ¸²æŸ“ç­‰ç­–ç•¥
icon: 'lucide:cpu'
---

## æ¦‚è¿°

ç°ä»£ Web åº”ç”¨çš„æ€§èƒ½ä¼˜åŒ–æ˜¯å†³å®šç”¨æˆ·ä½“éªŒå’Œä¸šåŠ¡æˆåŠŸçš„å…³é”®å› ç´ ã€‚Nuxt æ¡†æ¶åŸºäºå¼ºå¤§çš„ Nitro å¼•æ“ï¼Œæä¾›äº†å¤šç§æ¸²æŸ“æ¨¡å¼å’Œä¼˜åŒ–ç­–ç•¥ï¼Œä»ä¼ ç»Ÿçš„æœåŠ¡ç«¯æ¸²æŸ“åˆ°ç°ä»£çš„æ··åˆæ¸²æŸ“ï¼Œæ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‹¬ç‰¹çš„é€‚ç”¨åœºæ™¯å’Œæ€§èƒ½ç‰¹ç‚¹ã€‚æœ¬æ–‡å°†æ·±åº¦è§£æè¿™äº›æ¸²æŸ“æ¨¡å¼çš„å·¥ä½œåŸç†ï¼Œå¹¶æä¾›ç”Ÿäº§çº§çš„ä¼˜åŒ–ç­–ç•¥ã€‚

### ğŸ¯ æ ¸å¿ƒç›®æ ‡

- æ·±å…¥ç†è§£ä¸åŒæ¸²æŸ“æ¨¡å¼çš„æŠ€æœ¯åŸç†å’Œæ€§èƒ½ç‰¹ç‚¹
- æŒæ¡æ··åˆæ¸²æŸ“ç­–ç•¥çš„é…ç½®å’Œæœ€ä½³å®è·µ
- å­¦ä¼šæ„å»ºé«˜æ•ˆçš„ç¼“å­˜ç­–ç•¥å’Œè¾¹ç¼˜æ¸²æŸ“æ–¹æ¡ˆ
- æŒæ¡æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–çš„å®ç”¨æŠ€å·§

### ğŸ’¡ æŠ€æœ¯æ¶æ„

- **Nitro å¼•æ“**: æä¾›ç»Ÿä¸€çš„æœåŠ¡ç«¯è¿è¡Œæ—¶å’Œä¼˜åŒ–æœºåˆ¶
- **æ··åˆæ¸²æŸ“**: æ”¯æŒå¤šç§æ¸²æŸ“æ¨¡å¼çš„çµæ´»ç»„åˆ
- **è¾¹ç¼˜è®¡ç®—**: åˆ©ç”¨ CDN å’Œ Edge ç½‘ç»œæå‡å…¨çƒæ€§èƒ½
- **æ™ºèƒ½ç¼“å­˜**: å¤šå±‚æ¬¡ç¼“å­˜ç­–ç•¥å’Œå¤±æ•ˆæœºåˆ¶

::alert{icon="lucide:lightbulb" color="blue"}
**æ¶æ„ç†å¿µ**: Nuxt çš„æ¸²æŸ“ç­–ç•¥åŸºäº "æ¸è¿›å¼ä¼˜åŒ–" åŸåˆ™ï¼Œå…è®¸æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©æœ€é€‚åˆçš„æ¸²æŸ“æ¨¡å¼ï¼Œå¹¶å¯ä»¥åœ¨åŒä¸€åº”ç”¨ä¸­æ··åˆä½¿ç”¨ä¸åŒç­–ç•¥ã€‚
::

## SSR(æœåŠ¡ç«¯) æ¸²æŸ“æ¨¡å¼

### SSR å·¥ä½œåŸç†

æœåŠ¡ç«¯æ¸²æŸ“æ˜¯ Nuxt çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼Œå®ƒåœ¨æœåŠ¡å™¨ä¸Šæ‰§è¡Œ Vue ç»„ä»¶ï¼Œç”Ÿæˆå®Œæ•´çš„ HTML å“åº”ã€‚

#### æŠ€æœ¯å®ç°æœºåˆ¶


 1. **è¯·æ±‚å¤„ç†é˜¶æ®µ**: Node.js æœåŠ¡å™¨æ¥æ”¶ HTTP è¯·æ±‚ï¼Œè§£æè¯·æ±‚ URL å’Œ headersï¼Œåˆ›å»ºå®ä¾‹åˆå§‹åŒ– Nuxt ä¸Šä¸‹æ–‡ (context)
 
 2. **åº”ç”¨å®ä¾‹åŒ–**: åˆ›å»ºéš”ç¦»çš„ Vue åº”ç”¨å®ä¾‹ï¼Œæ³¨å…¥ Nuxt è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ï¼Œåˆå§‹åŒ–è·¯ç”±åŒ¹é…ç³»ç»Ÿï¼ŒåŠ è½½é¡µé¢çº§ç»„ä»¶å’Œå¸ƒå±€
 
 3. **æ•°æ®é¢„å–é˜¶æ®µ**: æ‰§è¡Œé¡µé¢ç»„ä»¶çš„ asyncData æ–¹æ³•ï¼Œå¤„ç† useFetch/useAsyncData æ•°æ®è¯·æ±‚ï¼Œå®ç°è¯·æ±‚çº§ç¼“å­˜ï¼ˆå½“é…ç½® cache ç­–ç•¥æ—¶ï¼‰

4. **HTML ç”Ÿæˆé˜¶æ®µ**: è°ƒç”¨ renderToString è¿›è¡Œç»„ä»¶æ¸²æŸ“ï¼Œå¤„ç†æœåŠ¡ç«¯ only çš„ç»„ä»¶é€»è¾‘ï¼Œæ”¶é›† head å…ƒä¿¡æ¯ï¼ˆé€šè¿‡ useHeadï¼‰ï¼Œç”Ÿæˆæœ€ç»ˆ HTML ç»“æ„
 
5. **å®¢æˆ·ç«¯æ¿€æ´»é˜¶æ®µ**: åœ¨ HTML ä¸­åµŒå…¥åºåˆ—åŒ–çš„ Store çŠ¶æ€ï¼Œæ³¨å…¥å®¢æˆ·ç«¯ hydration è„šæœ¬ï¼Œæ·»åŠ æ€§èƒ½ç›‘æ§åŸ‹ç‚¹ï¼Œå®ç°æ¸è¿›å¼ hydration ç­–ç•¥
 
 **å…³é”®ä¼˜åŒ–æœºåˆ¶**:
 - ç»„ä»¶çº§ç¼“å­˜ (Component Caching)
 - æµå¼æ¸²æŸ“ (Streaming Rendering)
 - é€‰æ‹©æ€§ hydration (Selective Hydration)
 - è¯·æ±‚çº§å†…å­˜ç®¡ç† (Request-scoped Memory)



```typescript
// SSR æ¸²æŸ“æµç¨‹ç¤ºä¾‹
export default defineEventHandler(async (event) => {
  // 1. æ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚
  const url = getRequestURL(event)
  const path = url.pathname
  
  // 2. åˆ›å»º Vue åº”ç”¨å®ä¾‹
  const { vueApp, head } = await createSSRApp({
    url: path,
    route: parseURL(path)
  })
  
  // 3. æœåŠ¡ç«¯æ¸²æŸ“
  const appHTML = await renderToString(vueApp)
  
  // 4. ç”Ÿæˆå®Œæ•´ HTML
  const html = `
    <!DOCTYPE html>
    <html ${head.htmlAttrs}>
      <head>${head.headTags}</head>
      <body ${head.bodyAttrs}>
        <div id="__nuxt">${appHTML}</div>
        <script>window.__NUXT__=${JSON.stringify(nuxtState)}</script>
        ${head.bodyTags}
      </body>
    </html>
  `
  
  return html
})

// é¡µé¢ç»„ä»¶ä¸­çš„ SSR æ•°æ®è·å–
<script setup lang="ts">
// æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯éƒ½ä¼šæ‰§è¡Œ
const { data: posts } = await useFetch('/api/posts', {
  key: 'posts-list',
  server: true, // ç¡®ä¿åœ¨æœåŠ¡ç«¯æ‰§è¡Œ
  transform: (data: any) => {
    return data.posts.map(post => ({
      id: post.id,
      title: post.title,
      publishedAt: new Date(post.published_at)
    }))
  }
})

// ä»…åœ¨æœåŠ¡ç«¯æ‰§è¡Œçš„é€»è¾‘
if (process.server) {
  console.log('è¿è¡Œåœ¨æœåŠ¡ç«¯ï¼Œå¯ä»¥è®¿é—® Node.js API')
  // è®¾ç½®æœåŠ¡ç«¯ç‰¹å®šçš„å“åº”å¤´
  setResponseHeader(event, 'Cache-Control', 'max-age=3600')
}
</script>
```

### SSR æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. å¤šçº§ç¼“å­˜ç­–ç•¥
```typescript
// æœåŠ¡ç«¯ç¼“å­˜ç¤ºä¾‹ï¼ˆé…åˆNitroå­˜å‚¨ï¼‰
const { data } = await useAsyncData('cachedData',
  () => $fetch('/api/heavy-data'),
  {
    getCachedData(key) {
      return useStorage().getItem(key) // ä½¿ç”¨Nitroå­˜å‚¨å¼•æ“
    },
    maxAge: 60 * 5 // 5åˆ†é’Ÿç¼“å­˜
  }
)

// ç»„ä»¶çº§ç¼“å­˜ï¼ˆv3.4+ï¼‰
defineComponent({
  name: 'HeavyComponent',
  serverCacheKey: props => props.id, // åŸºäºpropsçš„ç¼“å­˜é”®
  setup(props) { /* ... */ }
})
```

#### 2. æ™ºèƒ½ä»£ç åˆ†å‰²
```typescript
// åŠ¨æ€å¯¼å…¥é‡å‹ç»„ä»¶
const HeavyChart = defineAsyncComponent({
  loader: () => import('./HeavyChart.vue'),
  delay: 200, // å»¶è¿ŸåŠ è½½æ—¶é—´
  suspensible: true // æ”¯æŒSuspense
})

// è·¯ç”±çº§åˆ†å‰²
export default defineNuxtRouteMiddleware(() => {
  const route = useRoute()
  if (route.path.startsWith('/dashboard')) {
    useHead({ script: [{ src: '/js/dashboard-chunk.js', defer: true }] })
  }
})
```

#### 3. æµå¼æ¸²æŸ“ä¼˜åŒ–
```typescript
// å¯ç”¨Nitroæµå¼å“åº”
export default defineNitroConfig({
  renderer: process.env.NUXT_STREAMING ? 'stream' : 'default'
})

// ç»„ä»¶ä¸­ä½¿ç”¨Suspenseè¾¹ç•Œ
<template>
  <Suspense timeout="500">
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <LoadingSkeleton />
    </template>
  </Suspense>
</template>
```

#### 4. èµ„æºä¼˜åŒ–ç­–ç•¥
```typescript
// å…³é”®CSSå†…è”
useHead({
  style: [{
    innerHTML: () => extractCriticalCSS(app)
  }]
})

// æ™ºèƒ½é¢„åŠ è½½
const router = useRouter()
router.beforeEach((to) => {
  if (to.meta.preload) {
    preloadComponents(to.matchedComponents())
  }
})
```

#### 5. å¹¶å‘ä¸æ‰¹å¤„ç†
```typescript
// APIè¯·æ±‚æ‰¹å¤„ç†
const { data: user, data: posts } = await Promise.all([
  useAsyncData('user', () => $fetch('/api/user')),
  useAsyncData('posts', () => $fetch('/api/posts'))
])

// æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–ï¼ˆæœåŠ¡ç«¯ï¼‰
if (process.server) {
  const [user, notifications] = await Promise.all([
    db.user.findUnique({ where: { id: userId } }),
    db.notification.findMany({ where: { userId } })
  ])
}
```

#### 6. nuxt é…ç½®ä¼˜åŒ–

```typescript
// é«˜çº§ SSR ä¼˜åŒ–é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: true,
  
  // Nitro SSR ä¼˜åŒ–
  nitro: {
    // å‹ç¼©å“åº”
    compressPublicAssets: true,
    
    // é¢„æ¸²æŸ“é…ç½®
    prerender: {
      // æ™ºèƒ½çˆ¬å–ç­–ç•¥
      crawlLinks: true,
      // å¹¶å‘é¢„æ¸²æŸ“
      concurrency: 10,
      // å¿½ç•¥ç‰¹å®šè·¯ç”±
      ignore: ['/admin', '/api'],
      // è‡ªå®šä¹‰é¢„æ¸²æŸ“é€»è¾‘
      routes: ['/sitemap.xml']
    },
    
    // å­˜å‚¨é…ç½®ï¼ˆç”¨äºç¼“å­˜ï¼‰
    storage: {
      cache: {
        driver: 'redis',
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT),
        db: 0
      }
    }
  },
  
  // è·¯ç”±çº§ SSR é…ç½®
  routeRules: {
    // é¦–é¡µé¢„æ¸²æŸ“
    '/': { prerender: true },
    // åŠ¨æ€å†…å®¹ä½¿ç”¨ SSR
    '/posts/**': { ssr: true },
    // API è·¯ç”±ä¼˜åŒ–
    '/api/**': { 
      cors: true,
      headers: { 'Cache-Control': 's-maxage=60' }
    }
  }
})
```

#### 7. ç»„ä»¶çº§ SSR ä¼˜åŒ–
```ts
<script setup lang="ts">
// æ¡ä»¶æ€§ SSR
const route = useRoute()
const isPreview = route.query.preview === 'true'

const { data: content } = await useFetch('/api/content', {
  // é¢„è§ˆæ¨¡å¼ç¦ç”¨æœåŠ¡ç«¯ç¼“å­˜
  server: !isPreview,
  key: isPreview ? undefined : 'content-cache',
  // ç¼“å­˜æ§åˆ¶
  getCachedData: (key) => {
    if (isPreview) return null
    return nuxtApp.ssrContext?.cache?.[key] ?? nuxtApp.payload.data[key]
  }
})
</script>
```

#### æœ€ä½³å®è·µåŸåˆ™
1. **æŒ‰éœ€æ°´åˆ**ï¼šå¯¹éå…³é”®ç»„ä»¶ä½¿ç”¨`<ClientOnly>`æˆ–`useHydration`
2. **å†…å­˜ç®¡ç†**ï¼šæœåŠ¡ç«¯åŠæ—¶é‡Šæ”¾å¤§å¯¹è±¡ï¼Œé¿å…å†…å­˜æ³„æ¼
3. **ç¼“å­˜åˆ†å±‚**ï¼šç»“åˆCDNè¾¹ç¼˜ç¼“å­˜ã€æœåŠ¡ç«¯å†…å­˜ç¼“å­˜å’ŒæŒä¹…åŒ–ç¼“å­˜
4. **æ¸è¿›å¢å¼º**ï¼šæ ¸å¿ƒå†…å®¹SSR + éå…³é”®åŠŸèƒ½CSR
5. **å¥åº·æ£€æŸ¥**ï¼šå®ç°`/health`ç«¯ç‚¹ç›‘æ§SSRæœåŠ¡çŠ¶æ€

### SSR é”™è¯¯å¤„ç†å’Œé™çº§

```typescript
// å¥å£®çš„ SSR é”™è¯¯å¤„ç†
// server/api/posts.get.ts
export default defineEventHandler(async (event) => {
  try {
    // è®¾ç½®è¶…æ—¶
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 5000)
    
    const posts = await fetch('https://api.example.com/posts', {
      signal: controller.signal
    }).then(res => res.json())
    
    clearTimeout(timeoutId)
    
    return {
      success: true,
      data: posts
    }
  } catch (error) {
    // é™çº§ç­–ç•¥
    console.error('SSR æ•°æ®è·å–å¤±è´¥:', error)
    
    // è¿”å›ç¼“å­˜æ•°æ®æˆ–é»˜è®¤æ•°æ®
    const cachedData = await getCachedPosts()
    if (cachedData) {
      return {
        success: true,
        data: cachedData,
        fromCache: true
      }
    }
    
    // æœ€ç»ˆé™çº§åˆ°ç©ºçŠ¶æ€
    return {
      success: false,
      data: [],
      error: 'Failed to fetch posts'
    }
  }
})

// å®¢æˆ·ç«¯é™çº§å¤„ç†
<script setup lang="ts">
const { data: posts, error, pending } = await useFetch('/api/posts')

// é”™è¯¯è¾¹ç•Œå¤„ç†
if (error.value) {
  // å®¢æˆ·ç«¯é‡è¯•æœºåˆ¶
  const retryCount = ref(0)
  const maxRetries = 3
  
  const retry = async () => {
    if (retryCount.value < maxRetries) {
      retryCount.value++
      await refresh()
    }
  }
  
  // è‡ªåŠ¨é‡è¯•
  setTimeout(retry, 1000 retryCount.value)
}
</script>
```

## CSRï¼ˆå®¢æˆ·ç«¯ï¼‰æ¸²æŸ“æ¨¡å¼

### CSR å·¥ä½œåŸç†

CSR æ¨¡å¼å°†åº”ç”¨æ¸²æŸ“å®Œå…¨äº¤ç”±å®¢æˆ·ç«¯å¤„ç†ï¼ŒæœåŠ¡å™¨ä»…æä¾›åˆå§‹ HTML å’Œé™æ€èµ„æºã€‚è¿™ç§æ¨¡å¼é€‚ç”¨äºéœ€è¦å¤æ‚å®¢æˆ·ç«¯äº¤äº’çš„ç®¡ç†åå°ã€ä»ªè¡¨ç›˜ç­‰åº”ç”¨åœºæ™¯ã€‚

#### æŠ€æœ¯å®ç°æµç¨‹

1. **æœåŠ¡ç«¯é˜¶æ®µ**ï¼š
   - è¿”å›åŸºç¡€ HTML éª¨æ¶ï¼ˆåŒ…å« `<div id="__nuxt"></div>` å ä½ï¼‰
   - æ³¨å…¥å®¢æˆ·ç«¯æ‰“åŒ…çš„ JavaScript æ–‡ä»¶
   - åŒ…å«åˆå§‹åŒ–çš„åº”ç”¨é…ç½®å’Œå…ƒæ•°æ®

2. **å®¢æˆ·ç«¯é˜¶æ®µ**ï¼š
   - è§£æå¹¶æ‰§è¡Œ JavaScript å…¥å£æ–‡ä»¶
   - åˆå§‹åŒ– Vue åº”ç”¨å®ä¾‹
   - åˆ›å»º Vue Router å®ä¾‹å¹¶åŒ¹é…å½“å‰è·¯ç”±
   - æ‰§è¡Œé¡µé¢ç»„ä»¶çš„ `setup()` å’Œç”Ÿå‘½å‘¨æœŸé’©å­
   - é€šè¿‡ DOM æ“ä½œå°† Vue ç»„ä»¶æŒ‚è½½åˆ°å ä½å…ƒç´ 

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- å®¢æˆ·ç«¯è·¯ç”±å¯¼èˆªï¼ˆåŸºäº History API æˆ– Hash æ¨¡å¼ï¼‰
- åŠ¨æ€ä»£ç åˆ†å‰²ï¼ˆæŒ‰éœ€åŠ è½½é¡µé¢ç»„ä»¶ï¼‰
- å®¢æˆ·ç«¯çŠ¶æ€æŒä¹…åŒ–ï¼ˆé€šè¿‡ Pinia æˆ– Vuexï¼‰
- æ¸è¿›å¼ Hydrationï¼ˆä¼˜åŒ–å¤§å‹ç»„ä»¶æ ‘çš„äº¤äº’æ—¶é—´ï¼‰

```typescript
// CSR æ¨¡å¼åŸºç¡€é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: false, // å…³é”®é…ç½®é¡¹
  
  app: {
    // å®¢æˆ·ç«¯è·¯ç”±é…ç½®
    keepalive: true,
    layoutTransition: { 
      name: 'layout', 
      mode: 'out-in' 
    }
  },
  
  // å®¢æˆ·ç«¯ä¼˜åŒ–é…ç½®
  experimental: {
    payloadExtraction: false, // ç¦ç”¨é¢„åŠ è½½ payload
    clientFallback: true      // å¯ç”¨å®¢æˆ·ç«¯é™çº§ç­–ç•¥
  }
})

// å®¢æˆ·ç«¯åˆå§‹åŒ–æµç¨‹ç¤ºä¾‹
// app.vue
<script setup lang="ts">
onMounted(() => {
  // å®¢æˆ·ç«¯åˆå§‹åŒ–é€»è¾‘
  const nuxtApp = useNuxtApp()
  
  // æ³¨å†Œå®¢æˆ·ç«¯æ’ä»¶
  nuxtApp.hook('app:created', (vueApp) => {
    vueApp.use(SomeClientOnlyPlugin)
  })
  
  // æ€§èƒ½ç›‘æ§
  if (process.client) {
    const { trackPageView } = useAnalytics()
    trackPageView()
  }
})
</script>
```

#### ç”Ÿå‘½å‘¨æœŸå…³é”®èŠ‚ç‚¹
1. **èµ„æºåŠ è½½**ï¼šæµè§ˆå™¨è§£æ HTML å¹¶åŠ è½½ JS/CSS
2. **åº”ç”¨åˆå§‹åŒ–**ï¼šåˆ›å»º Vue å®ä¾‹å’Œè·¯ç”±ç³»ç»Ÿ
3. **è·¯ç”±åŒ¹é…**ï¼šæ ¹æ®å½“å‰ URL åŒ¹é…å¯¹åº”é¡µé¢ç»„ä»¶
4. **æ•°æ®è·å–**ï¼šæ‰§è¡Œ `useFetch`/`useAsyncData`
5. **ç»„ä»¶æ¸²æŸ“**ï¼šç”Ÿæˆ Virtual DOM å¹¶æŒ‚è½½åˆ°çœŸå® DOM
6. **Hydration**ï¼šå°† Vue å“åº”å¼ç³»ç»Ÿç»‘å®šåˆ°ç°æœ‰ DOM

::alert{icon="lucide:alert-circle" color="amber"}
**æ€§èƒ½æ³¨æ„ç‚¹**ï¼šCSR æ¨¡å¼éœ€è¦ç‰¹åˆ«æ³¨æ„é¦–å±åŠ è½½æ€§èƒ½ä¼˜åŒ–ï¼Œå»ºè®®é…åˆä»£ç åˆ†å‰²ã€é¢„åŠ è½½å…³é”®èµ„æºã€éª¨æ¶å±ç­‰æŠ€æœ¯ä½¿ç”¨ã€‚
::


### CSR ä¼˜åŒ–ç­–ç•¥

#### 1. ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½
```typescript
// åŠ¨æ€è·¯ç”±ç»„ä»¶åŠ è½½
const router = useRouter()
router.beforeEach((to) => {
  // é¢„åŠ è½½ç›®æ ‡è·¯ç”±ç»„ä»¶
  import(`~/pages/${to.name}.vue`).catch(() => {})
})

// æŒ‰éœ€åŠ è½½ç¬¬ä¸‰æ–¹åº“
const loadHeavyLibrary = () => import('heavy-library').then(({ init }) => init())
```

#### 2. æ™ºèƒ½é¢„å–ç­–ç•¥
```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // é¢„å–è§†å£å†…é“¾æ¥
    payloadPrefetch: true,
    // é¢„æ¸²æŸ“å…³é”®è·¯å¾„
    prerenderRoutes: ['/landing', '/pricing']
  }
})

// æ‰‹åŠ¨è§¦å‘é¢„åŠ è½½
usePreloadRoutes(['/checkout', '/dashboard'])
```

#### 3. ç¼“å­˜ä¼˜åŒ–ç­–ç•¥
```typescript
// å®¢æˆ·ç«¯æ•°æ®ç¼“å­˜
const { data } = useFetch('/api/products', {
  key: 'products',
  getCachedData(key) {
    return useNuxtApp().payload.data[key] || useState(key).value
  }
})

// Service Worker ç¼“å­˜ç­–ç•¥
if (process.client) {
  navigator.serviceWorker.register('/sw.js', {
    type: 'module',
    scope: '/'
  })
}
```

#### 4. å…³é”®æ¸²æŸ“è·¯å¾„ä¼˜åŒ–
```typescript
// é¦–å±å…³é”®CSSå†…è”
useHead({
  style: [{
    innerHTML: `/* å…³é”®CSS */`
  }]
})

// å»¶è¿Ÿéå…³é”®èµ„æº
const nonCriticalStyles = [
  'https://cdn.example.com/non-critical.css'
]
onMounted(() => loadStyles(nonCriticalStyles))
```

#### 5. æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–
```typescript
// æ€§èƒ½æŒ‡æ ‡æ”¶é›†
const { metric } = useWebVitals()
onMounted(() => {
  metric((data) => {
    sendToAnalytics(data)
  })
})

// é•¿ä»»åŠ¡ç›‘æ§
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log('Long task:', entry)
  }
})
observer.observe({ entryTypes: ['longtask'] })
```

::alert{icon="lucide:alert-triangle" color="blue"}
**ä¼˜åŒ–å»ºè®®**ï¼š
- ä½¿ç”¨ `v-lazy` æŒ‡ä»¤å®ç°å›¾ç‰‡æ‡’åŠ è½½
- å¯¹é™æ€èµ„æºå¯ç”¨ Brotli å‹ç¼©
- é‡‡ç”¨ `Intersection Observer` å®ç°å…ƒç´ å¯è§æ—¶åŠ è½½
- ä½¿ç”¨ `useIdleCallback` å¤„ç†éå…³é”®ä»»åŠ¡
- å®šæœŸè¿›è¡Œ Lighthouse æ€§èƒ½å®¡è®¡
::

#### nuxt ä¼˜åŒ–é…ç½®

```typescript
// é«˜æ€§èƒ½ CSR é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: false, // å…¨å±€ CSR æ¨¡å¼
  
  // CSR ç‰¹å®šä¼˜åŒ–
  app: {
    // å¯ç”¨å®¢æˆ·ç«¯è·¯ç”±
    keepalive: true,
    // é¡µé¢è¿‡æ¸¡åŠ¨ç”»
    pageTransition: { 
      name: 'page', 
      mode: 'out-in',
      // é¿å… FOUC
      appear: true
    }
  },
  
  // Vite ä¼˜åŒ–é…ç½®
  vite: {
    build: {
      // ä»£ç åˆ†å‰²ç­–ç•¥
      rollupOptions: {
        output: {
          manualChunks: {
            // åˆ†ç¦»ç¬¬ä¸‰æ–¹åº“
            vendor: ['vue', 'vue-router'],
            // åˆ†ç¦» UI åº“
            ui: ['@headlessui/vue', '@heroicons/vue'],
            // åˆ†ç¦»å·¥å…·åº“
            utils: ['lodash-es', 'date-fns']
          }
        }
      },
      // å¯ç”¨å‹ç¼©
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: true,
          drop_debugger: true
        }
      }
    },
    
    // å¼€å‘æ—¶çš„æ¨¡å—çƒ­æ›¿æ¢
    server: {
      hmr: {
        overlay: false
      }
    }
  }
})

// è·¯ç”±çº§ CSR é…ç½®
export default defineNuxtConfig({
  routeRules: {
    // ç®¡ç†åå°ä½¿ç”¨ CSR
    '/admin/**': { ssr: false },
    // ç”¨æˆ·ä»ªè¡¨æ¿ä½¿ç”¨ CSR
    '/dashboard/**': { 
      ssr: false,
      prerender: false,
      index: false // ä¸è¢«æœç´¢å¼•æ“ç´¢å¼•
    }
  }
})
```

#### CSR æ‡’åŠ è½½å’Œä»£ç åˆ†å‰²

```vue
<!-- ç»„ä»¶çº§æ‡’åŠ è½½ -->
<script setup lang="ts">
// åŠ¨æ€å¯¼å…¥ç»„ä»¶
const HeavyChart = defineAsyncComponent(() => 
  import('~/components/HeavyChart.vue')
)

const UserDashboard = defineAsyncComponent({
  loader: () => import('~/components/UserDashboard.vue'),
  // åŠ è½½çŠ¶æ€
  loadingComponent: () => h('div', 'åŠ è½½ä¸­...'),
  // é”™è¯¯çŠ¶æ€
  errorComponent: () => h('div', 'åŠ è½½å¤±è´¥'),
  // å»¶è¿Ÿæ˜¾ç¤ºåŠ è½½çŠ¶æ€
  delay: 200,
  // è¶…æ—¶æ—¶é—´
  timeout: 10000
})

// æ¡ä»¶æ€§æ‡’åŠ è½½
const showChart = ref(false)
const ChartComponent = computed(() => {
  return showChart.value 
    ? defineAsyncComponent(() => import('~/components/Chart.vue'))
    : null
})

// è·¯ç”±çº§æ‡’åŠ è½½
const router = useRouter()

// é¢„åŠ è½½ä¸‹ä¸€ä¸ªå¯èƒ½çš„è·¯ç”±
const preloadRoute = (path: string) => {
  router.resolve(path).then(resolved => {
    // é¢„åŠ è½½è·¯ç”±ç»„ä»¶
    resolved.matched.forEach(record => {
      if (record.components) {
        Object.values(record.components).forEach(component => {
          if (typeof component === 'function') {
            component()
          }
        })
      }
    })
  })
}

// æ™ºèƒ½é¢„åŠ è½½
onMounted(() => {
  // ç”¨æˆ·å¯èƒ½è®¿é—®çš„è·¯å¾„
  const likelyPaths = ['/dashboard', '/profile', '/settings']
  
  // å»¶è¿Ÿé¢„åŠ è½½ï¼Œé¿å…å½±å“é¦–å±æ€§èƒ½
  setTimeout(() => {
    likelyPaths.forEach(preloadRoute)
  }, 2000)
})
</script>

<template>
  <div>
    <!-- æ¡ä»¶æ¸²æŸ“æ‡’åŠ è½½ç»„ä»¶ -->
    <Suspense>
      <template #default>
        <HeavyChart v-if="showChart" />
      </template>
      <template #fallback>
        <div class="animate-pulse bg-gray-200 h-64 rounded"></div>
      </template>
    </Suspense>
    
    <!-- å¼‚æ­¥ç»„ä»¶ -->
    <UserDashboard />
  </div>
</template>
```

## SSG æ¸²æŸ“æ¨¡å¼

SSG æ¸²æŸ“æ¨¡å¼åœ¨æ„å»ºæ—¶é¢„ç”Ÿæˆé™æ€ HTML æ–‡ä»¶ï¼Œé€‚ç”¨äºå†…å®¹ç›¸å¯¹å›ºå®šçš„åœºæ™¯ï¼ˆå¦‚åšå®¢ã€æ–‡æ¡£ç«™ç‚¹ã€è¥é”€é¡µé¢ç­‰ï¼‰ï¼Œå…·æœ‰æè‡´çš„åŠ è½½æ€§èƒ½å’Œ SEO å‹å¥½ç‰¹æ€§ã€‚

### SSG å·¥ä½œåŸç†

#### æŠ€æœ¯å®ç°æµç¨‹

1. **æ„å»ºé˜¶æ®µ**ï¼š
   - è§£æè·¯ç”±é…ç½®ç”Ÿæˆè·¯ç”±æ˜ å°„è¡¨
   - å¹¶è¡Œæ‰§è¡Œé¡µé¢ç»„ä»¶çš„ asyncData/useAsyncData
   - ä½¿ç”¨ Vue æœåŠ¡ç«¯æ¸²æŸ“å™¨ç”Ÿæˆé™æ€ HTML
   - è‡ªåŠ¨å¤„ç†åŠ¨æ€è·¯ç”±å‚æ•°ï¼ˆéœ€é…ç½® generate.routesï¼‰

2. **éƒ¨ç½²é˜¶æ®µ**ï¼š
   - å°†ç”Ÿæˆçš„ dist ç›®å½•éƒ¨ç½²åˆ° CDN æˆ–é™æ€æ‰˜ç®¡æœåŠ¡
   - è‡ªåŠ¨ç”Ÿæˆ _nuxt é™æ€èµ„æºç›®å½•
   - ç”Ÿæˆ sitemap.xml å’Œ robots.txtï¼ˆéœ€é…ç½®æ¨¡å—ï¼‰

3. **è¿è¡Œæ—¶é˜¶æ®µ**ï¼š
   - ç›´æ¥è¿”å›é¢„ç”Ÿæˆçš„ HTML æ–‡ä»¶
   - å®¢æˆ·ç«¯æ¿€æ´» Vue å“åº”å¼ç³»ç»Ÿ
   - å¤„ç†åç»­å®¢æˆ·ç«¯å¯¼èˆªï¼ˆé€šè¿‡ vue-routerï¼‰

```typescript
// SSG åŸºç¡€é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: true, // å¿…é¡»å¯ç”¨ SSR
  target: 'static', // å…³é”®é…ç½®é¡¹
  
  generate: {
    cache: false, // ç¦ç”¨æ„å»ºç¼“å­˜
    concurrency: 10, // å¹¶è¡Œç”Ÿæˆä»»åŠ¡æ•°
    interval: 1000, // ä»»åŠ¡é—´éš”æ—¶é—´(ms)
    routes: ['/dynamic/1', '/dynamic/2'] // åŠ¨æ€è·¯ç”±é¢„ç”Ÿæˆ
  },
  
  // é™æ€èµ„æºä¼˜åŒ–
  nitro: {
    prerender: {
      crawlLinks: true, // è‡ªåŠ¨çˆ¬å–é“¾æ¥é¢„ç”Ÿæˆ
      routes: ['/sitemap.xml'] // ç‰¹æ®Šæ–‡ä»¶ç”Ÿæˆ
    }
  }
})

// åŠ¨æ€è·¯ç”±ç”Ÿæˆç¤ºä¾‹
// nuxt.config.ts
export default defineNuxtConfig({
  generate: {
    async routes() {
      const posts = await fetch('https://api.example.com/posts').then(res => res.json())
      return posts.map(post => `/posts/${post.id}`)
    }
  }
})
```

#### æ ¸å¿ƒä¼˜åŠ¿ä¸é™åˆ¶

**ä¼˜åŠ¿**ï¼š
- å…¨çƒ CDN å¯ç¼“å­˜æ€§ï¼ˆCache-Control: max-age=31536000ï¼‰
- å®Œå…¨æ¶ˆé™¤æœåŠ¡ç«¯è®¡ç®—å¼€é”€
- æ”¯æŒç¦»çº¿è®¿é—®ï¼ˆé…åˆ Service Workerï¼‰
- å¤©ç„¶é˜²å¾¡ CSRF/XSS æ”»å‡»

**é™åˆ¶**ï¼š
- ä¸é€‚åˆå®æ—¶æ•°æ®åœºæ™¯
- åŠ¨æ€è·¯ç”±éœ€è¦é¢„ç”Ÿæˆ
- æ„å»ºæ—¶é—´éšå†…å®¹é‡çº¿æ€§å¢é•¿

### SSG ä¼˜åŒ–ç­–ç•¥

1. **å¢é‡ç”Ÿæˆ**ï¼š
```typescript
// å¢é‡æ„å»ºé…ç½®
export default defineNuxtConfig({
  experimental: {
    payloadExtraction: true, // æå–é¡µé¢æ•°æ®
    incrementalStaticGeneration: {
      enable: true, // å¯ç”¨å¢é‡ç”Ÿæˆ
      background: true // åå°å¢é‡æ›´æ–°
    }
  }
})
```

2. **æ··åˆç¼“å­˜ç­–ç•¥**ï¼š
```typescript
// æœåŠ¡ç«¯è·¯ç”±å¤„ç†
export default defineEventHandler((event) => {
  setHeader(event, 'Cache-Control', 'public, max-age=3600, stale-while-revalidate=86400')
  return proxyStaticRequest(event)
})
```

3. **èµ„æºé¢„åŠ è½½**ï¼š
```vue
<script setup lang="ts">
// é¢„åŠ è½½å…³é”®æ•°æ®
const { data } = await useAsyncData('critical-data', () => fetchCriticalData(), {
  preload: true // åœ¨çˆ¶è·¯ç”±é¢„åŠ è½½
})
</script>

<template>
  <Link rel="preload" href="/_nuxt/header.css" as="style">
  <Link rel="prefetch" href="/_nuxt/ProductModal.js" as="script">
</template>
```

::alert{icon="lucide:alert-triangle" color="blue"}
**æ³¨æ„äº‹é¡¹**ï¼š
- åŠ¨æ€å†…å®¹éœ€é€šè¿‡å®¢æˆ·ç«¯ hydration å¤„ç†
- å¤§å‹ç«™ç‚¹éœ€åˆ†æ‰¹æ¬¡ç”Ÿæˆï¼ˆä½¿ç”¨ generate.batchï¼‰
- é¿å…åœ¨ asyncData ä¸­ä½¿ç”¨ç¯å¢ƒæ•æ„Ÿå˜é‡
- å®šæœŸæ¸…ç†è¿‡æœŸé™æ€æ–‡ä»¶
::


## ISRï¼ˆå¢é‡é™æ€å†ç”Ÿï¼‰æ¸²æŸ“æ¨¡å¼

### ISR å·¥ä½œæœºåˆ¶åˆ†æ

ISR çš„æ ¸å¿ƒåŸç†æ˜¯é€šè¿‡æ™ºèƒ½ç¼“å­˜ç­–ç•¥å®ç°åŠ¨æ€å†…å®¹çš„å¢é‡æ›´æ–°ï¼Œä¸»è¦åˆ†ä¸ºä»¥ä¸‹é˜¶æ®µï¼š

1. **åˆå§‹ç”Ÿæˆé˜¶æ®µ**
- æ„å»ºæ—¶ç”Ÿæˆé™æ€é¡µé¢ï¼ˆåŒ SSGï¼‰
- è‡ªåŠ¨ç¼“å­˜åˆ° CDN è¾¹ç¼˜èŠ‚ç‚¹
- é€šè¿‡ `prerender` é…ç½®é¢„æ¸²æŸ“å…³é”®è·¯å¾„

2. **å†ç”Ÿè§¦å‘æ¡ä»¶**
- æ—¶é—´é©±åŠ¨ï¼š`ttl` å‚æ•°æ§åˆ¶ç¼“å­˜æœ‰æ•ˆæœŸï¼ˆå•ä½ï¼šç§’ï¼‰
- äº‹ä»¶é©±åŠ¨ï¼šé€šè¿‡ `revalidate()` æ–¹æ³•æ‰‹åŠ¨è§¦å‘å†ç”Ÿ
- æµé‡é©±åŠ¨ï¼šé¦–æ¬¡è®¿é—®è¿‡æœŸé¡µé¢æ—¶è§¦å‘åå°å†ç”Ÿ

3. **è¯·æ±‚å¤„ç†æµç¨‹**
```mermaid
graph TD
  A[ç”¨æˆ·è¯·æ±‚] --> B{ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ?}
  B -- æœ‰æ•ˆ --> C[ç«‹å³è¿”å›ç¼“å­˜]
  B -- è¿‡æœŸ --> D[è¿”å›æ—§ç¼“å­˜ + åå°å†ç”Ÿ]
  D --> E[ç”Ÿæˆæ–°é¡µé¢]
  E --> F[æ›´æ–° CDN ç¼“å­˜]
```

4. **ç¼“å­˜ç­–ç•¥**
- ä½¿ç”¨ `stale-while-revalidate` æ¨¡å¼
- é€šè¿‡ `Cache-Control` å¤´æ§åˆ¶ç¼“å­˜è¡Œä¸º
- æ”¯æŒå¤šçº§ç¼“å­˜ï¼ˆCDN/Edge/æµè§ˆå™¨ï¼‰

5. **å†ç”Ÿè¿‡ç¨‹ä¼˜åŒ–**
- å¢é‡æ›´æ–°ï¼šä»…ä¿®æ”¹å˜åŒ–éƒ¨åˆ†
- å¹¶å‘æ§åˆ¶ï¼š`concurrency` é™åˆ¶å†ç”Ÿä»»åŠ¡æ•°
- å¤±è´¥é™çº§ï¼šå†ç”Ÿå¤±è´¥æ—¶ç»§ç»­ä½¿ç”¨æ—§ç¼“å­˜

6. **åŠ¨æ€è·¯ç”±å¤„ç†**
- é€šè¿‡ `prerender:routes` é’©å­åŠ¨æ€æ·»åŠ è·¯ç”±
- æ”¯æŒåŸºäºæ•°æ®çš„è·¯ç”±é¢„ç”Ÿæˆ
- è‡ªåŠ¨å¤„ç†åˆ†é¡µ/è¯¦æƒ…é¡µçš„ç¼“å­˜å…³è”


ISR ç»“åˆäº† SSG çš„æ€§èƒ½ä¼˜åŠ¿å’Œ SSR çš„çµæ´»æ€§ï¼Œæ˜¯ç°ä»£ Web åº”ç”¨çš„ç†æƒ³é€‰æ‹©ã€‚

#### ISR é…ç½®

```typescript
// ISR é…ç½®å’Œå®ç°
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    // ISR å…¨å±€é…ç½®
    prerender: {
      // å¯ç”¨çˆ¬å–
      crawlLinks: true,
      // å¹¶å‘é™åˆ¶
      concurrency: 10,
      // è·¯ç”±ç”Ÿæˆé’©å­
      routes: ['/sitemap.xml']
    }
  },
  
  routeRules: {
    // ä¸åŒçš„ ISR ç­–ç•¥
    '/blog/**': { 
      isr: true // æ°¸ä¹…ç¼“å­˜ï¼Œç›´åˆ°æ‰‹åŠ¨å¤±æ•ˆ
    },
    '/products/**': { 
      isr: 60 // 60ç§’åé‡æ–°ç”Ÿæˆ
    },
    '/news/**': { 
      isr: { ttl: 300, staleWhileRevalidate: true } // é«˜çº§ ISR é…ç½®
    }
  },
  
  hooks: {
    // åŠ¨æ€è·¯ç”±ç”Ÿæˆ
    async 'prerender:routes'(ctx) {
      // ä» CMS è·å–è·¯ç”±
      const posts = await fetch('https://cms.example.com/posts')
        .then(res => res.json())
      
      // æ·»åŠ åˆ°é¢„æ¸²æŸ“é˜Ÿåˆ—
      for (const post of posts.data) {
        ctx.routes.add(`/blog/${post.slug}`)
      }
      
      // åˆ†é¡µè·¯ç”±
      const totalPages = Math.ceil(posts.total / 10)
      for (let i = 1; i <= totalPages; i++) {
        ctx.routes.add(`/blog/page/${i}`)
      }
    }
  }
})

// ISR ç¼“å­˜æ§åˆ¶
// server/api/posts/[slug].get.ts
export default defineEventHandler(async (event) => {
  const slug = getRouterParam(event, 'slug')
  
  // æ£€æŸ¥ç¼“å­˜é”®
  const cacheKey = `post:${slug}`
  
  try {
    // ä»æ•°æ®åº“è·å–æ–‡ç« 
    const post = await getPostBySlug(slug)
    
    if (!post) {
      throw createError({
        statusCode: 404,
        statusMessage: 'Post not found'
      })
    }
    
    // è®¾ç½® ISR ç¼“å­˜å¤´
    setResponseHeaders(event, {
      'Cache-Control': 'public, max-age=60, stale-while-revalidate=3600',
      'CDN-Cache-Control': 'public, max-age=3600',
      'Vercel-CDN-Cache-Control': 'public, max-age=3600'
    })
    
    // è®¾ç½® ETag ç”¨äºç¼“å­˜éªŒè¯
    const etag = generateETag(post)
    setResponseHeader(event, 'ETag', etag)
    
    // æ£€æŸ¥å®¢æˆ·ç«¯ç¼“å­˜
    const clientETag = getRequestHeader(event, 'if-none-match')
    if (clientETag === etag) {
      setResponseStatus(event, 304)
      return
    }
    
    return {
      success: true,
      data: post,
      meta: {
        cached: false,
        generated: new Date().toISOString()
      }
    }
  } catch (error) {
    // é”™è¯¯å¤„ç†
    throw createError({
      statusCode: error.statusCode || 500,
      statusMessage: error.message || 'Internal server error'
    })
  }
})
```

#### ISR ç¼“å­˜å¤±æ•ˆç­–ç•¥

```typescript
// æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
// server/api/revalidate.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { paths, tags } = body
  
  // éªŒè¯æƒé™
  const token = getRequestHeader(event, 'authorization')
  if (!await validateRevalidateToken(token)) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  
  const revalidated = []
  
  // è·¯å¾„çº§å¤±æ•ˆ
  if (paths?.length > 0) {
    for (const path of paths) {
      await invalidatePath(path)
      revalidated.push(path)
    }
  }
  
  // æ ‡ç­¾çº§å¤±æ•ˆ
  if (tags?.length > 0) {
    for (const tag of tags) {
      const taggedPaths = await getPathsByTag(tag)
      for (const path of taggedPaths) {
        await invalidatePath(path)
        revalidated.push(path)
      }
    }
  }
  
  return {
    success: true,
    revalidated: [...new Set(revalidated)],
    timestamp: new Date().toISOString()
  }
})

// CMS Webhook é›†æˆ
// server/api/webhook/cms.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  
  // éªŒè¯ Webhook ç­¾å
  const signature = getRequestHeader(event, 'x-webhook-signature')
  if (!await validateWebhookSignature(body, signature)) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid signature'
    })
  }
  
  const { event: eventType, data } = body
  
  switch (eventType) {
    case 'post.published':
    case 'post.updated':
      // å¤±æ•ˆç›¸å…³é¡µé¢
      await Promise.all([
        invalidatePath(`/blog/${data.slug}`),
        invalidatePath('/blog'),
        invalidatePath('/'),
        // å¤±æ•ˆç›¸å…³æ ‡ç­¾é¡µé¢
        ...data.tags.map(tag => invalidatePath(`/blog/tag/${tag}`))
      ])
      break
      
    case 'post.deleted':
      await invalidatePath(`/blog/${data.slug}`)
      break
  }
  
  return { success: true }
})
```

## æ··åˆæ¸²æŸ“ç­–ç•¥

æ··åˆæ¸²æŸ“æ˜¯ Nuxt 3 çš„æ ¸å¿ƒä¼˜åŠ¿ï¼Œå…è®¸åœ¨åŒä¸€åº”ç”¨ä¸­ä½¿ç”¨ä¸åŒçš„æ¸²æŸ“ç­–ç•¥ã€‚

#### é«˜çº§æ··åˆæ¸²æŸ“é…ç½®

```typescript
// ä¼ä¸šçº§æ··åˆæ¸²æŸ“ç­–ç•¥
// nuxt.config.ts
export default defineNuxtConfig({
  // åŸºç¡€æ··åˆæ¸²æŸ“é…ç½®
  routeRules: {
    // è¥é”€é¡µé¢ - é™æ€é¢„æ¸²æŸ“ï¼ˆSEO ä¼˜åŒ–ï¼‰
    '/': { prerender: true },
    '/about': { prerender: true },
    '/contact': { prerender: true },
    '/pricing': { prerender: true },
    
    // äº§å“é¡µé¢ - ISRï¼ˆå¹³è¡¡æ€§èƒ½å’Œæ›´æ–°é¢‘ç‡ï¼‰
    '/products': { isr: 300 }, // 5åˆ†é’Ÿç¼“å­˜
    '/products/**': { isr: 600 }, // 10åˆ†é’Ÿç¼“å­˜
    
    // åšå®¢ - SWRï¼ˆå†…å®¹æ›´æ–°é¢‘ç¹ï¼‰
    '/blog': { swr: 60 }, // 1åˆ†é’Ÿç¼“å­˜
    '/blog/**': { swr: 120 }, // 2åˆ†é’Ÿç¼“å­˜
    
    // ç”¨æˆ·ç›¸å…³ - SSRï¼ˆä¸ªæ€§åŒ–å†…å®¹ï¼‰
    '/profile/**': { ssr: true },
    '/orders/**': { ssr: true },
    
    // ç®¡ç†åå° - CSRï¼ˆå¤æ‚äº¤äº’ï¼‰
    '/admin/**': { 
      ssr: false,
      prerender: false,
      index: false,
      robots: false
    },
    
    // API è·¯ç”±ä¼˜åŒ–
    '/api/public/**': { 
      cors: true,
      headers: { 'Cache-Control': 'public, max-age=300' }
    },
    '/api/private/**': { 
      headers: { 'Cache-Control': 'private, no-cache' }
    }
  },
  
  // å®éªŒæ€§ç‰¹æ€§
  experimental: {
    // æœåŠ¡ç«¯ç»„ä»¶
    serverComponents: true,
    // æ¸è¿›å¼å¢å¼º
    noScripts: false
  }
})

// åŠ¨æ€è·¯ç”±è§„åˆ™
// plugins/dynamic-route-rules.client.ts
export default defineNuxtPlugin(() => {
  const router = useRouter()
  
  router.beforeEach((to) => {
    // æ ¹æ®ç”¨æˆ·çŠ¶æ€åŠ¨æ€è®¾ç½®æ¸²æŸ“è§„åˆ™
    const user = useAuthUser()
    
    if (to.path.startsWith('/dashboard')) {
      // å·²ç™»å½•ç”¨æˆ·ä½¿ç”¨ SSRï¼Œæœªç™»å½•ç”¨æˆ·é‡å®šå‘
      if (!user.value) {
        return navigateTo('/login')
      }
    }
    
    if (to.path.startsWith('/premium')) {
      // ä»˜è´¹ç”¨æˆ·ä½¿ç”¨ ISRï¼Œå…è´¹ç”¨æˆ·ä½¿ç”¨ SSG
      const renderRule = user.value?.isPremium ? { isr: 60 } : { prerender: true }
      // åŠ¨æ€åº”ç”¨æ¸²æŸ“è§„åˆ™ï¼ˆéœ€è¦æœåŠ¡ç«¯é…åˆï¼‰
      setRouteRule(to.path, renderRule)
    }
  })
})
```

#### æ¡ä»¶æ¸²æŸ“ç­–ç•¥

```vue
<!-- ç»„ä»¶çº§æ¸²æŸ“æ§åˆ¶ -->
<script setup lang="ts">
// æ ¹æ®è®¾å¤‡ç±»å‹é€‰æ‹©æ¸²æŸ“ç­–ç•¥
const { isMobile, isBot } = useDevice()

// æœç´¢å¼•æ“çˆ¬è™«ä½¿ç”¨ SSR
if (isBot) {
  defineRouteRules({ ssr: true })
}
// ç§»åŠ¨è®¾å¤‡ä½¿ç”¨é¢„æ¸²æŸ“
else if (isMobile) {
  defineRouteRules({ prerender: true })
}
// æ¡Œé¢è®¾å¤‡ä½¿ç”¨ CSR
else {
  defineRouteRules({ ssr: false })
}

// A/B æµ‹è¯•æ¸²æŸ“ç­–ç•¥
const experiment = useExperiment('rendering-strategy')
switch (experiment.variant) {
  case 'ssr':
    defineRouteRules({ ssr: true })
    break
  case 'isr':
    defineRouteRules({ isr: 60 })
    break
  case 'CSR':
    defineRouteRules({ ssr: false })
    break
}

// åœ°ç†ä½ç½®ä¼˜åŒ–
const { country } = useGeoLocation()
if (['US', 'EU', 'JP'].includes(country)) {
  // ä¸»è¦å¸‚åœºä½¿ç”¨ ISR
  defineRouteRules({ isr: 120 })
} else {
  // å…¶ä»–åœ°åŒºä½¿ç”¨ SSG
  defineRouteRules({ prerender: true })
}
</script>
```

## æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥

### æœåŠ¡å™¨ç«¯æ¸²æŸ“ï¼ˆSSRï¼‰ä¸é™æ€ç«™ç‚¹ç”Ÿæˆï¼ˆSSGï¼‰ä¼˜åŒ–

#### æ™ºèƒ½é¢„æ¸²æŸ“ç­–ç•¥

```typescript
// é«˜çº§é¢„æ¸²æŸ“é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    prerender: {
      // æ™ºèƒ½çˆ¬å–é…ç½®
      crawlLinks: true,
      // å¹¶å‘æ§åˆ¶
      concurrency: 15,
      // è¶…æ—¶è®¾ç½®
      timeout: 30000,
      // å¤±è´¥é‡è¯•
      retry: 3,
      // å¿½ç•¥è§„åˆ™
      ignore: [
        '/admin',
        '/api',
        '/404',
        '/500',
        '**/*.xml',
        '**/*.json'
      ],
      // è‡ªå®šä¹‰çˆ¬å–é€»è¾‘
      routes: async () => {
        const routes = new Set<string>()
        
        // ä» CMS è·å–å†…å®¹è·¯ç”±
        const cmsRoutes = await fetchCMSRoutes()
        cmsRoutes.forEach(route => routes.add(route))
        
        // ä»æ•°æ®åº“è·å–åŠ¨æ€è·¯ç”±
        const dbRoutes = await fetchDatabaseRoutes()
        dbRoutes.forEach(route => routes.add(route))
        
        // ç”Ÿæˆåˆ†é¡µè·¯ç”±
        const paginationRoutes = await generatePaginationRoutes()
        paginationRoutes.forEach(route => routes.add(route))
        
        return Array.from(routes)
      }
    },
    
    // å‹ç¼©ä¼˜åŒ–
    compressPublicAssets: {
      gzip: true,
      brotli: true
    },
    
    // å­˜å‚¨å¼•æ“é…ç½®
    storage: {
      // Redis ç¼“å­˜
      cache: {
        driver: 'redis',
        ...redisConfig
      },
      // æ–‡ä»¶ç³»ç»Ÿç¼“å­˜
      disk: {
        driver: 'fs',
        base: './.cache'
      }
    }
  }
})

// é¢„æ¸²æŸ“ç”Ÿæˆå™¨
// scripts/generate-routes.ts
import { $fetch } from 'ofetch'

interface RouteGenerator {
  pattern: string
  generator: () => Promise<string[]>
}

const routeGenerators: RouteGenerator[] = [
  // åšå®¢æ–‡ç« è·¯ç”±
  {
    pattern: '/blog/**',
    generator: async () => {
      const posts = await $fetch('/api/posts')
      return posts.data.map(post => `/blog/${post.slug}`)
    }
  },
  
  // äº§å“è·¯ç”±
  {
    pattern: '/products/**',
    generator: async () => {
      const products = await $fetch('/api/products')
      const routes = []
      
      // äº§å“è¯¦æƒ…é¡µ
      routes.push(...products.data.map(p => `/products/${p.slug}`))
      
      // åˆ†ç±»é¡µé¢
      const categories = [...new Set(products.data.map(p => p.category))]
      routes.push(...categories.map(c => `/products/category/${c}`))
      
      // å“ç‰Œé¡µé¢
      const brands = [...new Set(products.data.map(p => p.brand))]
      routes.push(...brands.map(b => `/products/brand/${b}`))
      
      return routes
    }
  },
  
  // ç”¨æˆ·èµ„æ–™é¡µ
  {
    pattern: '/users/**',
    generator: async () => {
      const users = await $fetch('/api/users/public')
      return users.data.map(user => `/users/${user.username}`)
    }
  }
]

export async function generateAllRoutes(): Promise<string[]> {
  const allRoutes = []
  
  for (const generator of routeGenerators) {
    try {
      const routes = await generator.generator()
      allRoutes.push(...routes)
      console.log(`Generated ${routes.length} routes for ${generator.pattern}`)
    } catch (error) {
      console.error(`Failed to generate routes for ${generator.pattern}:`, error)
    }
  }
  
  return allRoutes
}
```

#### SSG æ€§èƒ½ç›‘æ§

```typescript
// é¢„æ¸²æŸ“æ€§èƒ½ç›‘æ§
// scripts/monitor-prerender.ts
export default defineNuxtConfig({
  hooks: {
    'prerender:start': () => {
      console.log('å¼€å§‹é¢„æ¸²æŸ“...')
      startTime = Date.now()
    },
    
    'prerender:route': (route) => {
      const routeStartTime = Date.now()
      routePerformance.set(route.route, { 
        startTime: routeStartTime,
        size: 0 
      })
    },
    
    'prerender:generate': (route, result) => {
      const perf = routePerformance.get(route.route)
      if (perf) {
        perf.duration = Date.now() - perf.startTime
        perf.size = Buffer.byteLength(result.html, 'utf8')
        
        // æ€§èƒ½å‘Šè­¦
        if (perf.duration > 5000) {
          console.warn(`âš ï¸  æ…¢é€Ÿè·¯ç”±: ${route.route} (${perf.duration}ms)`)
        }
        
        if (perf.size > 500000) {
          console.warn(`âš ï¸  å¤§æ–‡ä»¶: ${route.route} (${perf.size} bytes)`)
        }
      }
    },
    
    'prerender:done': () => {
      const totalTime = Date.now() - startTime
      const totalRoutes = routePerformance.size
      
      console.log(`âœ… é¢„æ¸²æŸ“å®Œæˆ: ${totalRoutes} ä¸ªè·¯ç”±ï¼Œè€—æ—¶ ${totalTime}ms`)
      
      // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
      generatePerformanceReport(routePerformance)
    }
  }
})

function generatePerformanceReport(performance: Map<string, any>) {
  const report = {
    total: performance.size,
    average: Array.from(performance.values())
      .reduce((sum, p) => sum + p.duration, 0) / performance.size,
    slowest: Array.from(performance.entries())
      .sort(([,a], [,b]) => b.duration - a.duration)
      .slice(0, 10),
    largest: Array.from(performance.entries())
      .sort(([,a], [,b]) => b.size - a.size)
      .slice(0, 10)
  }
  
  // ä¿å­˜æŠ¥å‘Š
  writeFileSync('prerender-report.json', JSON.stringify(report, null, 2))
}
```

### æ··åˆæ¸²æŸ“ï¼ˆHybridï¼‰ç­–ç•¥

#### åŠ¨æ€è·¯ç”±ä¸é™æ€è·¯ç”±ç»“åˆ

```typescript
// æ™ºèƒ½æ··åˆæ¸²æŸ“ç­–ç•¥
// composables/useRenderingStrategy.ts
export const useRenderingStrategy = () => {
  const route = useRoute()
  const user = useAuthUser()
  const device = useDevice()
  
  // ç­–ç•¥å†³ç­–å¼•æ“
  const determineStrategy = () => {
    const strategies = []
    
    // åŸºäºè·¯ç”±æ¨¡å¼çš„ç­–ç•¥
    if (route.path.match(/^\/(about|contact|privacy)/)) {
      strategies.push({ mode: 'prerender', priority: 10, reason: 'Static pages' })
    }
    
    if (route.path.match(/^\/blog\//)) {
      strategies.push({ mode: 'isr', ttl: 300, priority: 8, reason: 'Content pages' })
    }
    
    if (route.path.match(/^\/products\//)) {
      strategies.push({ mode: 'swr', ttl: 60, priority: 7, reason: 'Product pages' })
    }
    
    // åŸºäºç”¨æˆ·çŠ¶æ€çš„ç­–ç•¥
    if (user.value) {
      if (route.path.startsWith('/dashboard')) {
        strategies.push({ mode: 'ssr', priority: 9, reason: 'Personalized content' })
      }
    } else {
      if (route.path.startsWith('/login')) {
        strategies.push({ mode: 'CSR', priority: 6, reason: 'Authentication flow' })
      }
    }
    
    // åŸºäºè®¾å¤‡ç±»å‹çš„ç­–ç•¥
    if (device.isMobile) {
      strategies.push({ mode: 'prerender', priority: 5, reason: 'Mobile optimization' })
    }
    
    // åŸºäºæ—¶é—´çš„ç­–ç•¥
    const hour = new Date().getHours()
    if (hour >= 9 && hour <= 17) {
      // å·¥ä½œæ—¶é—´æ›´é¢‘ç¹æ›´æ–°
      strategies.forEach(s => {
        if (s.mode === 'isr' || s.mode === 'swr') {
          s.ttl = Math.floor(s.ttl / 2)
        }
      })
    }
    
    // é€‰æ‹©æœ€é«˜ä¼˜å…ˆçº§ç­–ç•¥
    return strategies.sort((a, b) => b.priority - a.priority)[0]
  }
  
  return { determineStrategy }
}

// åº”ç”¨æ¸²æŸ“ç­–ç•¥
// plugins/apply-rendering-strategy.server.ts
export default defineNuxtPlugin(async () => {
  const strategy = useRenderingStrategy()
  const selectedStrategy = strategy.determineStrategy()
  
  if (selectedStrategy) {
    console.log(`åº”ç”¨æ¸²æŸ“ç­–ç•¥: ${selectedStrategy.mode} (${selectedStrategy.reason})`)
    
    // è®¾ç½®è·¯ç”±è§„åˆ™
    switch (selectedStrategy.mode) {
      case 'prerender':
        defineRouteRules({ prerender: true })
        break
      case 'ssr':
        defineRouteRules({ ssr: true })
        break
      case 'CSR':
        defineRouteRules({ ssr: false })
        break
      case 'isr':
        defineRouteRules({ isr: selectedStrategy.ttl })
        break
      case 'swr':
        defineRouteRules({ swr: selectedStrategy.ttl })
        break
    }
  }
})
```

### ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### SWR ä¸ Cache-Control é…ç½®

```typescript
// é«˜çº§ç¼“å­˜ç­–ç•¥
// server/middleware/cache-control.ts
export default defineEventHandler(async (event) => {
  const url = getRequestURL(event)
  const path = url.pathname
  
  // é™æ€èµ„æºç¼“å­˜
  if (path.startsWith('/_nuxt/') || path.match(/\.(js|css|png|jpg|jpeg|gif|svg|webp|woff2?|ttf)$/)) {
    setResponseHeaders(event, {
      'Cache-Control': 'public, max-age=31536000, immutable',
      'CDN-Cache-Control': 'public, max-age=31536000'
    })
    return
  }
  
  // HTML é¡µé¢ç¼“å­˜ç­–ç•¥
  const cacheStrategies = {
    // é¦–é¡µ - çŸ­æœŸç¼“å­˜ï¼Œé¢‘ç¹æ›´æ–°
    '/': {
      'Cache-Control': 'public, max-age=60, stale-while-revalidate=300',
      'CDN-Cache-Control': 'public, max-age=300'
    },
    
    // åšå®¢æ–‡ç«  - é•¿æœŸç¼“å­˜ï¼Œåå°æ›´æ–°
    '/blog/**': {
      'Cache-Control': 'public, max-age=3600, stale-while-revalidate=86400',
      'CDN-Cache-Control': 'public, max-age=86400'
    },
    
    // äº§å“é¡µé¢ - ä¸­æœŸç¼“å­˜
    '/products/**': {
      'Cache-Control': 'public, max-age=1800, stale-while-revalidate=3600',
      'CDN-Cache-Control': 'public, max-age=3600'
    },
    
    // API è·¯ç”± - åˆ†çº§ç¼“å­˜
    '/api/public/**': {
      'Cache-Control': 'public, max-age=300',
      'CDN-Cache-Control': 'public, max-age=600'
    },
    
    '/api/user/**': {
      'Cache-Control': 'private, max-age=60',
      'CDN-Cache-Control': 'private, no-cache'
    }
  }
  
  // åº”ç”¨ç¼“å­˜ç­–ç•¥
  for (const [pattern, headers] of Object.entries(cacheStrategies)) {
    if (matchRoute(path, pattern)) {
      setResponseHeaders(event, headers)
      break
    }
  }
  
  // Vary å¤´è®¾ç½®
  setResponseHeader(event, 'Vary', 'Accept-Encoding, User-Agent, Accept')
})

// æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
// server/api/cache/invalidate.post.ts
export default defineEventHandler(async (event) => {
  const { paths, tags, conditions } = await readBody(event)
  
  const invalidationResults = []
  
  // è·¯å¾„çº§å¤±æ•ˆ
  if (paths?.length > 0) {
    for (const path of paths) {
      await invalidateCacheByPath(path)
      invalidationResults.push({ type: 'path', target: path, success: true })
    }
  }
  
  // æ ‡ç­¾çº§å¤±æ•ˆ
  if (tags?.length > 0) {
    for (const tag of tags) {
      const taggedPaths = await getCachePathsByTag(tag)
      for (const path of taggedPaths) {
        await invalidateCacheByPath(path)
      }
      invalidationResults.push({ 
        type: 'tag', 
        target: tag, 
        affected: taggedPaths.length,
        success: true 
      })
    }
  }
  
  // æ¡ä»¶å¤±æ•ˆ
  if (conditions?.length > 0) {
    for (const condition of conditions) {
      const matchedPaths = await findCachePathsByCondition(condition)
      for (const path of matchedPaths) {
        await invalidateCacheByPath(path)
      }
      invalidationResults.push({
        type: 'condition',
        target: condition,
        affected: matchedPaths.length,
        success: true
      })
    }
  }
  
  return {
    success: true,
    invalidated: invalidationResults,
    timestamp: new Date().toISOString()
  }
})
```

#### å¤šå±‚ç¼“å­˜æ¶æ„

```typescript
// å¤šå±‚ç¼“å­˜å®ç°
// composables/useMultiTierCache.ts
export const useMultiTierCache = () => {
  const storage = useStorage()
  
  interface CacheConfig {
    l1?: { ttl: number; max: number }  // å†…å­˜ç¼“å­˜
    l2?: { ttl: number }               // Redis ç¼“å­˜
    l3?: { ttl: number }               // CDN ç¼“å­˜
  }
  
  const get = async <T>(key: string, config: CacheConfig = {}): Promise<T | null> => {
    // L1: å†…å­˜ç¼“å­˜
    if (config.l1) {
      const l1Cache = await storage.getItem(`l1:${key}`)
      if (l1Cache && Date.now() - l1Cache.timestamp < config.l1.ttl * 1000) {
        return l1Cache.data
      }
    }
    
    // L2: Redis ç¼“å­˜
    if (config.l2) {
      const l2Cache = await storage.getItem(`l2:${key}`)
      if (l2Cache && Date.now() - l2Cache.timestamp < config.l2.ttl * 1000) {
        // å›å¡« L1 ç¼“å­˜
        if (config.l1) {
          await storage.setItem(`l1:${key}`, {
            data: l2Cache.data,
            timestamp: Date.now()
          })
        }
        return l2Cache.data
      }
    }
    
    return null
  }
  
  const set = async <T>(key: string, data: T, config: CacheConfig = {}): Promise<void> => {
    const timestamp = Date.now()
    
    // L1: å†…å­˜ç¼“å­˜
    if (config.l1) {
      await storage.setItem(`l1:${key}`, { data, timestamp })
    }
    
    // L2: Redis ç¼“å­˜
    if (config.l2) {
      await storage.setItem(`l2:${key}`, { data, timestamp })
    }
    
    // L3: CDN ç¼“å­˜é€šè¿‡ HTTP å¤´æ§åˆ¶
    if (config.l3) {
      // åœ¨å“åº”ä¸­è®¾ç½®ç¼“å­˜å¤´
      const event = getCurrentEvent()
      if (event) {
        setResponseHeaders(event, {
          'Cache-Control': `public, max-age=${config.l3.ttl}`,
          'CDN-Cache-Control': `public, max-age=${config.l3.ttl}`
        })
      }
    }
  }
  
  const invalidate = async (pattern: string): Promise<void> => {
    // è·å–æ‰€æœ‰åŒ¹é…çš„é”®
    const l1Keys = await storage.getKeys('l1:')
    const l2Keys = await storage.getKeys('l2:')
    
    const matchingKeys = [...l1Keys, ...l2Keys].filter(key => 
      key.includes(pattern) || minimatch(key, pattern)
    )
    
    // åˆ é™¤åŒ¹é…çš„ç¼“å­˜
    await Promise.all(matchingKeys.map(key => storage.removeItem(key)))
    
    // CDN ç¼“å­˜å¤±æ•ˆéœ€è¦é€šè¿‡ API è°ƒç”¨
    await invalidateCDNCache(pattern)
  }
  
  return { get, set, invalidate }
}

// ä½¿ç”¨ç¤ºä¾‹
<script setup lang="ts">
const cache = useMultiTierCache()

// è·å–å¸¦ç¼“å­˜çš„æ•°æ®
const getCachedPosts = async () => {
  const cacheKey = 'posts:recent'
  
  let posts = await cache.get(cacheKey, {
    l1: { ttl: 60, max: 100 },    // 1åˆ†é’Ÿå†…å­˜ç¼“å­˜
    l2: { ttl: 300 },             // 5åˆ†é’Ÿ Redis ç¼“å­˜
    l3: { ttl: 600 }              // 10åˆ†é’Ÿ CDN ç¼“å­˜
  })
  
  if (!posts) {
    posts = await $fetch('/api/posts/recent')
    await cache.set(cacheKey, posts, {
      l1: { ttl: 60, max: 100 },
      l2: { ttl: 300 },
      l3: { ttl: 600 }
    })
  }
  
  return posts
}

const { data: posts } = await useAsyncData('recent-posts', getCachedPosts)
</script>
```

### è¾¹ç¼˜æ¸²æŸ“ï¼ˆEdge Renderingï¼‰ä¸éƒ¨ç½²ä¼˜åŒ–

#### Vercel Edge Runtime ä¼˜åŒ–

```typescript
// Vercel Edge Runtime é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'vercel-edge',
    
    // Edge Runtime ç‰¹å®šé…ç½®
    vercel: {
      // å‡½æ•°é…ç½®
      functions: {
        // API è·¯ç”±é…ç½®
        'api/**': {
          runtime: 'edge',
          regions: ['iad1', 'sfo1', 'hnd1'], // å¤šåœ°åŸŸéƒ¨ç½²
          memory: 128,
          maxDuration: 10
        },
        
        // é¡µé¢æ¸²æŸ“é…ç½®
        '**': {
          runtime: 'nodejs18.x',
          memory: 1024,
          maxDuration: 30
        }
      },
      
      // ISR é…ç½®
      isr: {
        // è¿‡æœŸæ—¶é—´
        expiration: 60,
        // å…è®¸çš„é”™è¯¯çŠ¶æ€ç 
        allowQuery: ['utm_source', 'utm_medium']
      }
    },
    
    // Edge ç‰¹å®šä¼˜åŒ–
    experimental: {
      wasm: true // å¯ç”¨ WebAssembly æ”¯æŒ
    }
  },
  
  // è·¯ç”±çº§ Edge é…ç½®
  routeRules: {
    // é™æ€èµ„æº - Edge ç¼“å­˜
    '/api/static/**': {
      headers: {
        'Cache-Control': 'public, max-age=31536000, immutable'
      },
      prerender: false
    },
    
    // åŠ¨æ€ API - Edge Runtime
    '/api/edge/**': {
      runtime: 'edge',
      headers: {
        'Cache-Control': 'public, max-age=60, stale-while-revalidate=300'
      }
    },
    
    // åœ°ç†ä½ç½®ç›¸å…³é¡µé¢
    '/geo/**': {
      runtime: 'edge',
      isr: true
    }
  }
})

// Edge Runtime API ç¤ºä¾‹
// server/api/edge/geo.ts
export default defineEventHandler(async (event) => {
  // è·å–åœ°ç†ä½ç½®ä¿¡æ¯
  const country = getRequestHeader(event, 'x-vercel-ip-country') || 'Unknown'
  const city = getRequestHeader(event, 'x-vercel-ip-city') || 'Unknown'
  const ip = getClientIP(event)
  
  // Edge ç‰¹å®šçš„ç¼“å­˜ç­–ç•¥
  setResponseHeaders(event, {
    'Cache-Control': 'public, max-age=300, stale-while-revalidate=900',
    'Vary': 'X-Vercel-IP-Country'
  })
  
  return {
    geo: {
      country,
      city,
      ip: ip?.replace(/\.\d+$/, '.xxx') // éšç§ä¿æŠ¤
    },
    edge: true,
    timestamp: new Date().toISOString()
  }
})
```

#### Cloudflare Workers ä¼˜åŒ–

```typescript
// Cloudflare Workers é…ç½®
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'cloudflare-pages',
    
    cloudflare: {
      // KV å­˜å‚¨é…ç½®
      kv: {
        CACHE: 'cache-nameCSRce',
        CONFIG: 'config-nameCSRce'
      },
      
      // D1 æ•°æ®åº“é…ç½®
      d1: {
        DB: 'main-database'
      },
      
      // R2 å­˜å‚¨é…ç½®
      r2: {
        ASSETS: 'assets-bucket'
      }
    },
    
    // Wrangler é…ç½®
    wrangler: {
      name: 'nuxt-app',
      compatibility_date: '2024-01-01',
      compatibility_flags: ['nodejs_compat']
    }
  }
})

// Cloudflare KV ç¼“å­˜
// server/api/cf/cached-data.ts
export default defineEventHandler(async (event) => {
  const cf = event.context.cloudflare
  const kv = cf?.env.CACHE
  
  if (!kv) {
    throw createError({
      statusCode: 500,
      statusMessage: 'KV storage not available'
    })
  }
  
  const cacheKey = `data:${getQuery(event).id || 'default'}`
  
  // å°è¯•ä» KV è·å–ç¼“å­˜
  const cached = await kv.get(cacheKey, 'json')
  if (cached) {
    setResponseHeaders(event, {
      'Cache-Control': 'public, max-age=300',
      'X-Cache': 'HIT'
    })
    return cached
  }
  
  // è·å–æ–°æ•°æ®
  const data = await fetchDataFromSource()
  
  // å­˜å‚¨åˆ° KVï¼ˆå¸¦ TTLï¼‰
  await kv.put(cacheKey, JSON.stringify(data), {
    expirationTtl: 3600 // 1å°æ—¶è¿‡æœŸ
  })
  
  setResponseHeaders(event, {
    'Cache-Control': 'public, max-age=300',
    'X-Cache': 'MISS'
  })
  
  return data
})

// Cloudflare D1 é›†æˆ
// server/api/cf/posts.get.ts
export default defineEventHandler(async (event) => {
  const cf = event.context.cloudflare
  const db = cf?.env.DB
  
  if (!db) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Database not available'
    })
  }
  
  const query = getQuery(event)
  const { page = 1, limit = 10 } = query
  
  try {
    // ä½¿ç”¨ D1 æŸ¥è¯¢
    const { results } = await db.prepare(`
      SELECT id, title, slug, content, created_at 
      FROM posts 
      WHERE published = 1 
      ORDER BY created_at DESC 
      LIMIT ? OFFSET ?
    `).bind(limit, (page - 1) * limit).all()
    
    // è·å–æ€»æ•°
    const { count } = await db.prepare(`
      SELECT COUNT(*) as count 
      FROM posts 
      WHERE published = 1
    `).first()
    
    return {
      success: true,
      data: results,
      meta: {
        total: count,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(count / limit)
      }
    }
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Database query failed'
    })
  }
})
```

#### å¤šäº‘éƒ¨ç½²ç­–ç•¥

```typescript
// å¤šäº‘éƒ¨ç½²é…ç½®
// scripts/deploy-multi-cloud.ts
interface DeploymentTarget {
  name: string
  preset: string
  config: any
  primary?: boolean
}

const deploymentTargets: DeploymentTarget[] = [
  {
    name: 'vercel',
    preset: 'vercel',
    config: {
      regions: ['iad1', 'sfo1', 'hnd1']
    },
    primary: true
  },
  {
    name: 'cloudflare',
    preset: 'cloudflare-pages',
    config: {
      compatibility_date: '2024-01-01'
    }
  },
  {
    name: 'netlify',
    preset: 'netlify',
    config: {
      edge: true
    }
  }
]

export async function deployToAllTargets() {
  const results = []
  
  for (const target of deploymentTargets) {
    try {
      console.log(`éƒ¨ç½²åˆ° ${target.name}...`)
      
      // ç”Ÿæˆç‰¹å®šé…ç½®
      const config = generateConfigForTarget(target)
      await writeConfig(config, target.name)
      
      // æ‰§è¡Œæ„å»º
      await executeCommand(`nuxi build --preset ${target.preset}`)
      
      // æ‰§è¡Œéƒ¨ç½²
      await executeCommand(`${target.name} deploy`)
      
      results.push({
        target: target.name,
        success: true,
        url: await getDeploymentURL(target.name)
      })
      
      console.log(`âœ… ${target.name} éƒ¨ç½²æˆåŠŸ`)
    } catch (error) {
      console.error(`âŒ ${target.name} éƒ¨ç½²å¤±è´¥:`, error)
      results.push({
        target: target.name,
        success: false,
        error: error.message
      })
    }
  }
  
  // æ›´æ–° DNS è®°å½•ï¼ˆå¦‚æœä¸»è¦éƒ¨ç½²æˆåŠŸï¼‰
  const primaryResult = results.find(r => r.success && deploymentTargets.find(t => t.name === r.target)?.primary)
  if (primaryResult) {
    await updateDNSRecords(primaryResult.url)
  }
  
  return results
}

// å¥åº·æ£€æŸ¥å’Œæ•…éšœè½¬ç§»
// server/middleware/health-check.ts
export default defineEventHandler(async (event) => {
  if (getRequestURL(event).pathname === '/health') {
    const health = {
      status: 'ok',
      timestamp: new Date().toISOString(),
      version: process.env.NUXT_APP_VERSION,
      deployment: {
        platform: process.env.DEPLOYMENT_PLATFORM,
        region: process.env.DEPLOYMENT_REGION
      },
      checks: {
        database: await checkDatabase(),
        cache: await checkCache(),
        external: await checkExternalServices()
      }
    }
    
    const allHealthy = Object.values(health.checks).every(check => check.status === 'ok')
    
    setResponseStatus(event, allHealthy ? 200 : 503)
    return health
  }
})
```

## æ€§èƒ½ç›‘æ§å’Œåˆ†æ

### æ ¸å¿ƒ Web æŒ‡æ ‡ä¼˜åŒ–

```typescript
// Web Vitals ç›‘æ§
// plugins/web-vitals.client.ts
export default defineNuxtPlugin(() => {
  if (process.client) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      // æ”¶é›† Web Vitals æŒ‡æ ‡
      const vitalsData = {}
      
      getCLS((metric) => {
        vitalsData.cls = metric
        sendVitalsData('CLS', metric)
      })
      
      getFID((metric) => {
        vitalsData.fid = metric
        sendVitalsData('FID', metric)
      })
      
      getFCP((metric) => {
        vitalsData.fcp = metric
        sendVitalsData('FCP', metric)
      })
      
      getLCP((metric) => {
        vitalsData.lcp = metric
        sendVitalsData('LCP', metric)
      })
      
      getTTFB((metric) => {
        vitalsData.ttfb = metric
        sendVitalsData('TTFB', metric)
      })
    })
  }
})

// æ€§èƒ½æ•°æ®å‘é€
function sendVitalsData(name: string, metric: any) {
  const data = {
    name,
    value: metric.value,
    id: metric.id,
    delta: metric.delta,
    url: window.location.href,
    userAgent: navigator.userAgent,
    connection: (navigator as any).connection?.effectiveType,
    timestamp: Date.now()
  }
  
  // å‘é€åˆ°åˆ†ææœåŠ¡
  $fetch('/api/analytics/vitals', {
    method: 'POST',
    body: data
  }).catch(console.error)
}

// æœåŠ¡ç«¯æ€§èƒ½ç›‘æ§
// server/api/analytics/vitals.post.ts
export default defineEventHandler(async (event) => {
  const vitalsData = await readBody(event)
  
  // å­˜å‚¨åˆ°æ•°æ®åº“æˆ–åˆ†ææœåŠ¡
  await storeVitalsData(vitalsData)
  
  // å®æ—¶å‘Šè­¦
  if (vitalsData.name === 'LCP' && vitalsData.value > 2500) {
    await sendAlert(`LCP è¿‡æ…¢: ${vitalsData.value}ms on ${vitalsData.url}`)
  }
  
  if (vitalsData.name === 'CLS' && vitalsData.value > 0.1) {
    await sendAlert(`CLS è¿‡é«˜: ${vitalsData.value} on ${vitalsData.url}`)
  }
  
  return { success: true }
})
```

### å®æ—¶æ€§èƒ½ä¼˜åŒ–

```typescript
// è‡ªé€‚åº”æ€§èƒ½ä¼˜åŒ–
// composables/useAdaptivePerformance.ts
export const useAdaptivePerformance = () => {
  const connection = ref(null)
  const deviceMemory = ref(null)
  const hardwareConcurrency = ref(null)
  
  onMounted(() => {
    if (process.client) {
      // ç½‘ç»œè¿æ¥ä¿¡æ¯
      connection.value = (navigator as any).connection
      // è®¾å¤‡å†…å­˜
      deviceMemory.value = (navigator as any).deviceMemory
      // CPU æ ¸å¿ƒæ•°
      hardwareConcurrency.value = navigator.hardwareConcurrency
    }
  })
  
  // åŠ¨æ€è°ƒæ•´ç­–ç•¥
  const getOptimizationStrategy = () => {
    const strategy = {
      imageQuality: 80,
      enableLazyLoading: true,
      prefetchLevel: 'normal',
      enableAnimations: true,
      chunkSizeLimit: 250 * 1024 // 250KB
    }
    
    // æ ¹æ®ç½‘ç»œè¿æ¥è°ƒæ•´
    if (connection.value) {
      switch (connection.value.effectiveType) {
        case 'slow-2g':
        case '2g':
          strategy.imageQuality = 60
          strategy.prefetchLevel = 'minimal'
          strategy.enableAnimations = false
          strategy.chunkSizeLimit = 100 * 1024
          break
        case '3g':
          strategy.imageQuality = 70
          strategy.prefetchLevel = 'reduced'
          strategy.chunkSizeLimit = 150 * 1024
          break
        case '4g':
          strategy.imageQuality = 90
          strategy.prefetchLevel = 'aggressive'
          strategy.chunkSizeLimit = 500 * 1024
          break
      }
    }
    
    // æ ¹æ®è®¾å¤‡å†…å­˜è°ƒæ•´
    if (deviceMemory.value && deviceMemory.value < 4) {
      strategy.enableLazyLoading = true
      strategy.prefetchLevel = 'minimal'
      strategy.chunkSizeLimit = Math.min(strategy.chunkSizeLimit, 200 * 1024)
    }
    
    return strategy
  }
  
  return {
    connection: readonly(connection),
    deviceMemory: readonly(deviceMemory),
    hardwareConcurrency: readonly(hardwareConcurrency),
    getOptimizationStrategy
  }
}

// è‡ªé€‚åº”å›¾ç‰‡åŠ è½½
<script setup lang="ts">
const { getOptimizationStrategy } = useAdaptivePerformance()
const strategy = getOptimizationStrategy()

// åŠ¨æ€å›¾ç‰‡è´¨é‡
const imageProps = computed(() => ({
  quality: strategy.imageQuality,
  loading: strategy.enableLazyLoading ? 'lazy' : 'eager',
  sizes: strategy.prefetchLevel === 'minimal' 
    ? '(max-width: 768px) 100vw, 50vw'
    : '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw'
}))
</script>

<template>
  <NuxtImg
    :src="imageSrc"
    :quality="imageProps.quality"
    :loading="imageProps.loading"
    :sizes="imageProps.sizes"
    alt="Adaptive image"
  />
</template>
```

## æ€»ç»“

### æ¸²æŸ“æ¨¡å¼å¯¹æ¯”çŸ©é˜µ

| æ¸²æŸ“æ¨¡å¼ | æŠ€æœ¯ç‰¹ç‚¹ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|---------|------|------|---------|
| **SSR**<br>(æœåŠ¡ç«¯æ¸²æŸ“) | æœåŠ¡ç«¯ç”Ÿæˆå®Œæ•´HTML<br>å®¢æˆ·ç«¯æ¿€æ´»hydration | âœ… SEOå‹å¥½<br>âœ… é¦–å±æ€§èƒ½å¿«<br>âœ… ç›´æ¥è¾“å‡ºå†…å®¹ | âš ï¸ æœåŠ¡å™¨å‹åŠ›å¤§<br>âš ï¸ TTFBæ—¶é—´è¾ƒé•¿<br>âš ï¸ å®¢æˆ·ç«¯JSä»éœ€åŠ è½½ | å†…å®¹å‹ç½‘ç«™<br>ç”µå•†äº§å“é¡µ<br>éœ€è¦SEOçš„é¡µé¢ |
| **CSR**<br>(å®¢æˆ·ç«¯æ¸²æŸ“) | å®¢æˆ·ç«¯JSæ¸²æŸ“å†…å®¹<br>SPAæ¨¡å¼ | âœ… äº¤äº’ä½“éªŒæµç•…<br>âœ… æœåŠ¡å™¨å‹åŠ›å°<br>âœ… é€‚åˆå¤æ‚å‰ç«¯é€»è¾‘ | âš ï¸ SEOä¸å‹å¥½<br>âš ï¸ é¦–å±æ€§èƒ½å·®<br>âš ï¸ ç™½å±æ—¶é—´æ˜æ˜¾ | ç®¡ç†åå°<br>ä»ªè¡¨ç›˜åº”ç”¨<br>å¼ºäº¤äº’å‹åº”ç”¨ |
| **SSG**<br>(é™æ€ç”Ÿæˆ) | æ„å»ºæ—¶ç”Ÿæˆé™æ€HTML<br>CDNç›´æ¥æ‰˜ç®¡ | âœ… æè‡´æ€§èƒ½<br>âœ… é›¶æœåŠ¡å™¨æˆæœ¬<br>âœ… é«˜å®‰å…¨æ€§ | âš ï¸ æ— åŠ¨æ€å†…å®¹<br>âš ï¸ æ›´æ–°éœ€è¦é‡æ–°æ„å»º<br>âš ï¸ ä¸é€‚åˆä¸ªæ€§åŒ–å†…å®¹ | æ–‡æ¡£ç½‘ç«™<br>è¥é”€è½åœ°é¡µ<br>åšå®¢ç³»ç»Ÿ |
| **ISR**<br>(å¢é‡é™æ€å†ç”Ÿ) | æŒ‰éœ€/å®šæ—¶æ›´æ–°é™æ€é¡µé¢<br>ç¼“å­˜ç­–ç•¥æ§åˆ¶ | âœ… åŠ¨æ€+é™æ€ç»“åˆ<br>âœ… é™ä½æ„å»ºæ—¶é—´<br>âœ… çµæ´»æ›´æ–°ç­–ç•¥ | âš ï¸ ç¼“å­˜å¤±æ•ˆé€»è¾‘å¤æ‚<br>âš ï¸ éœ€è¦åŸºç¡€è®¾æ–½æ”¯æŒ<br>âš ï¸ å®æ—¶æ€§æœ‰é™ | äº§å“ç›®å½•<br>æ–°é—»èµ„è®¯<br>é¢‘ç¹æ›´æ–°å†…å®¹ |
| **æ··åˆæ¸²æŸ“** | è·¯ç”±çº§æ¸²æŸ“ç­–ç•¥é…ç½®<br>å¤šç§æ¨¡å¼ç»„åˆä½¿ç”¨ | âœ… æœ€ä½³çµæ´»æ€§<br>âœ… æŒ‰éœ€ä¼˜åŒ–ç­–ç•¥<br>âœ… å¹³è¡¡SEOä¸æ€§èƒ½ | âš ï¸ é…ç½®å¤æ‚åº¦é«˜<br>âš ï¸ éœ€è¦æ¶æ„è®¾è®¡<br>âš ï¸ è°ƒè¯•éš¾åº¦å¢åŠ  | ä¼ä¸šçº§åº”ç”¨<br>å¤šç±»å‹é¡µé¢å…±å­˜<br>æ¸è¿›å¼ä¼˜åŒ–åœºæ™¯ |
| **è¾¹ç¼˜æ¸²æŸ“** | CDNè¾¹ç¼˜èŠ‚ç‚¹æ‰§è¡Œæ¸²æŸ“<br>åœ°ç†åˆ†å¸ƒå¼è®¡ç®— | âœ… å…¨çƒä½å»¶è¿Ÿ<br>âœ… è‡ªåŠ¨æ‰©å±•èƒ½åŠ›<br>âœ… å‡å°‘æºç«™å‹åŠ› | âš ï¸ å†·å¯åŠ¨é—®é¢˜<br>âš ï¸ è¿è¡Œç¯å¢ƒé™åˆ¶<br>âš ï¸ æˆæœ¬æ§åˆ¶å¤æ‚ | å…¨çƒåŒ–åº”ç”¨<br>é«˜å¹¶å‘åœºæ™¯<br>åŠ¨æ€å†…å®¹åŠ é€Ÿ |

::alert{icon="lucide:git-merge" color="green"}
**æ¨¡å¼é€‰æ‹©åŸåˆ™**ï¼š
1. **å†…å®¹ç‰¹æ€§**ï¼šé™æ€å†…å®¹ä¼˜å…ˆSSGï¼ŒåŠ¨æ€å†…å®¹è€ƒè™‘SSR/ISR
2. **æ›´æ–°é¢‘ç‡**ï¼šé«˜é¢‘æ›´æ–°ç”¨ISRï¼Œä½é¢‘ç”¨SSG
3. **äº¤äº’éœ€æ±‚**ï¼šå¼ºäº¤äº’ç”¨CSRï¼Œå†…å®¹å±•ç¤ºç”¨SSR
4. **åŸºç¡€è®¾æ–½**ï¼šæ ¹æ®æœåŠ¡å™¨èƒ½åŠ›é€‰æ‹©æ¸²æŸ“ç­–ç•¥
5. **æ¸è¿›å¢å¼º**ï¼šä»SSGå¼€å§‹ï¼ŒæŒ‰éœ€å‡çº§åˆ°ISR/SSR
::
