---
title: Nuxt æ€§èƒ½ä¼˜åŒ–æŒ‡å—
description: æ·±åº¦è§£æ Nuxt æ¡†æ¶æ€§èƒ½ä¼˜åŒ–æŒ‡å—ï¼Œä»åŸºç¡€é…ç½®åˆ°é«˜çº§ä¼˜åŒ–ç­–ç•¥ï¼Œæ¶µç›– SSRã€SSGã€ISRã€èµ„æºä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥ã€æ€§èƒ½ç›‘æ§ç­‰æ ¸å¿ƒæŠ€æœ¯ï¼Œæ„å»ºé«˜æ€§èƒ½ Web åº”ç”¨
icon: 'lucide:zap'
---

## æ¦‚è¿°

åœ¨ç°ä»£ Web å¼€å‘ä¸­ï¼Œæ€§èƒ½ä¼˜åŒ–å·²æˆä¸ºå†³å®šåº”ç”¨æˆåŠŸçš„å…³é”®å› ç´ ã€‚æ® Google ç ”ç©¶æ˜¾ç¤ºï¼Œé¡µé¢åŠ è½½æ—¶é—´è¶…è¿‡ 3 ç§’å°†å¯¼è‡´ 53% çš„ç”¨æˆ·æµå¤±ï¼Œè€Œä¼˜åŒ–åçš„åº”ç”¨å¯ä»¥æ˜¾è‘—æå‡è½¬åŒ–ç‡å’Œç”¨æˆ·ä½“éªŒã€‚Nuxt æ¡†æ¶åŸºäº Vue.js æ„å»ºï¼Œæä¾›äº†å®Œæ•´çš„æ€§èƒ½ä¼˜åŒ–å·¥å…·é“¾ï¼Œä»æœåŠ¡ç«¯æ¸²æŸ“åˆ°å®¢æˆ·ç«¯ä¼˜åŒ–ï¼Œä»æ„å»ºæ—¶ä¼˜åŒ–åˆ°è¿è¡Œæ—¶æ€§èƒ½è°ƒä¼˜ã€‚

æœ¬æŒ‡å—å°†æ·±å…¥æ¢è®¨ Nuxt æ€§èƒ½ä¼˜åŒ–çš„å…¨é“¾è·¯å®è·µï¼Œå¸®åŠ©å¼€å‘è€…æŒæ¡ä»ç†è®ºåˆ°å®è·µçš„å®Œæ•´ä¼˜åŒ–ä½“ç³»ã€‚

### ğŸ¯ æ ¸å¿ƒç›®æ ‡

- æŒæ¡ Nuxt æ€§èƒ½ä¼˜åŒ–çš„å…¨é“¾è·¯æ–¹æ³•è®ºå’Œæœ€ä½³å®è·µ
- æ·±å…¥ç†è§£æ¸²æŸ“æ¨¡å¼ã€ç¼“å­˜ç­–ç•¥å’Œèµ„æºä¼˜åŒ–çš„æŠ€æœ¯åŸç†
- å­¦ä¼šæ„å»ºé«˜æ•ˆçš„ç›‘æ§ä½“ç³»å’Œæ€§èƒ½è¯Šæ–­æ–¹æ³•
- æŒæ¡ä¼ä¸šçº§åº”ç”¨çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥å’Œæ¶æ„è®¾è®¡

### ğŸ’¡ æŠ€æœ¯æ¶æ„ä½“ç³»

- **Nitro å¼•æ“**: ç»Ÿä¸€çš„æœåŠ¡ç«¯è¿è¡Œæ—¶å’Œä¼˜åŒ–æœºåˆ¶
- **Vite/Webpack**: ç°ä»£åŒ–æ„å»ºå·¥å…·å’Œæ‰“åŒ…ä¼˜åŒ–
- **Vue 3**: ç»„åˆå¼ API å’Œå“åº”å¼ç³»ç»Ÿä¼˜åŒ–
- **è¾¹ç¼˜è®¡ç®—**: CDN å’Œ Edge Runtime æ€§èƒ½æå‡
- **æ™ºèƒ½ç¼“å­˜**: å¤šå±‚æ¬¡ç¼“å­˜ç­–ç•¥å’Œç¼“å­˜å¤±æ•ˆæœºåˆ¶

::alert{icon="lucide:lightbulb" color="blue"}
**æ€§èƒ½ä¼˜åŒ–ç†å¿µ**: Nuxt çš„æ€§èƒ½ä¼˜åŒ–åŸºäº "æ¸è¿›å¼å¢å¼º" å’Œ "æŒ‰éœ€åŠ è½½" åŸåˆ™ï¼Œé€šè¿‡æ™ºèƒ½çš„ä»£ç åˆ†å‰²ã€ç¼“å­˜ç­–ç•¥å’Œæ¸²æŸ“æ¨¡å¼ï¼Œå®ç°æœ€ä½³çš„é¦–å±åŠ è½½æ—¶é—´å’Œäº¤äº’å“åº”æ€§èƒ½ã€‚
::

## ç¬¬ä¸€éƒ¨åˆ†ï¼šæ€§èƒ½ä¼˜åŒ–åŸºç¡€ç†è®º

### Web æ€§èƒ½å…³é”®æŒ‡æ ‡æ·±å…¥è§£æ

ç°ä»£ Web æ€§èƒ½è¯„ä¼°åŸºäº Core Web Vitals å’Œå…¶ä»–å…³é”®æŒ‡æ ‡ï¼Œäº†è§£è¿™äº›æŒ‡æ ‡å¯¹äºåˆ¶å®šæœ‰æ•ˆçš„ä¼˜åŒ–ç­–ç•¥è‡³å…³é‡è¦ã€‚

#### Core Web Vitals æŒ‡æ ‡è¯¦è§£

**Largest Contentful Paint (LCP)**

LCPï¼ˆæœ€å¤§å†…å®¹ç»˜åˆ¶ï¼‰æ˜¯è¡¡é‡ç”¨æˆ·æ„ŸçŸ¥åŠ è½½é€Ÿåº¦çš„æ ¸å¿ƒæŒ‡æ ‡ï¼Œç”¨äºè®°å½•è§†çª—å†…æœ€å¤§å†…å®¹å…ƒç´ ï¼ˆå¦‚å›¾åƒã€è§†é¢‘ã€æ–‡æœ¬å—ï¼‰çš„æ¸²æŸ“æ—¶é—´ç‚¹ã€‚

å…³é”®è¦ç´ è§£æï¼š
1. **å†…å®¹ç±»å‹**ï¼šåŒ…æ‹¬ä½†ä¸é™äºï¼š
   - å›¾ç‰‡/è§†é¢‘
   - é¡µé¢ä¸»æ ‡é¢˜ï¼ˆH1ï¼‰
   - å…³é”®ä¿¡æ¯æ¨ªå¹…
   - é¦–å±äº§å“å¡ç‰‡

2. **æµ‹é‡æ ‡å‡†**ï¼š
   - å…ƒç´ å¿…é¡»å¯è§ä¸”åœ¨è§†çª—å†…
   - å†…å®¹éœ€ä¸ºå®é™…æ¸²æŸ“å†…å®¹ï¼ˆéèƒŒæ™¯æˆ–å ä½ç¬¦ï¼‰
   - å…ƒç´ å°ºå¯¸éœ€å è§†çª—é¢ç§¯ 30% ä»¥ä¸Š

æŠ€æœ¯åŸç†ï¼š
- æµè§ˆå™¨æ¸²æŸ“å¼•æ“ä¼šæŒç»­è¿½è¸ªå†…å®¹å…ƒç´ çš„å°ºå¯¸å’Œä½ç½®å˜åŒ–
- å½“å¸ƒå±€ç¨³å®šåï¼ˆæ— åç»­ DOM å˜æ›´å½±å“ï¼‰ï¼Œè®°å½•æœ€å¤§å…ƒç´ çš„æ¸²æŸ“æ—¶é—´
- æµ‹é‡æ—¶é—´ç‚¹åŒ…å«ç½‘ç»œè¯·æ±‚ã€èµ„æºè§£ç ã€æ¸²æŸ“ç®¡çº¿æ‰§è¡Œç­‰å…¨é“¾è·¯è€—æ—¶

ä¼˜åŒ–å…³æ³¨ç‚¹ï¼š
- æ¶ˆé™¤æ¸²æŸ“é˜»å¡èµ„æºï¼ˆRender-blocking Resourcesï¼‰
- ä¼˜åŒ–å…³é”®æ¸²æŸ“è·¯å¾„ï¼ˆCritical Rendering Pathï¼‰
- ç¡®ä¿æ–‡æœ¬å†…å®¹ä½¿ç”¨æ­£ç¡®çš„å­—ä½“åŠ è½½ç­–ç•¥ï¼ˆFOIT/FOUTï¼‰
- ä¼˜å…ˆä¿éšœé¦–å±å†…å®¹çš„ CSS äº¤ä»˜ä¼˜åŒ–ï¼ˆCritical CSSï¼‰

ä¼˜åŒ–ç›®æ ‡
- **ç›®æ ‡å€¼**: â‰¤ 2.5 ç§’
- **æŠ€æœ¯åŸç†**: è¡¡é‡é¡µé¢ä¸»è¦å†…å®¹çš„æ¸²æŸ“æ—¶é—´
- **ä¼˜åŒ–ç­–ç•¥**: æœåŠ¡ç«¯æ¸²æŸ“ã€å›¾åƒä¼˜åŒ–ã€å…³é”®èµ„æºé¢„åŠ è½½

```typescript
// LCP ä¼˜åŒ–ç¤ºä¾‹ï¼šå…³é”®èµ„æºé¢„åŠ è½½
export default defineNuxtConfig({
  app: {
    head: {
      link: [
        {
          rel: 'preload',
          href: '/images/hero-image.webp',
          as: 'image',
          fetchpriority: 'high'
        }
      ]
    }
  }
})
```

**First Input Delay (FID) / Interaction to Next Paint (INP)**




- **ç›®æ ‡å€¼**: FID â‰¤ 100ms, INP â‰¤ 200ms
- **æŠ€æœ¯åŸç†**: è¡¡é‡ç”¨æˆ·äº¤äº’å“åº”é€Ÿåº¦
- **ä¼˜åŒ–ç­–ç•¥**: ä»£ç åˆ†å‰²ã€ä¸»çº¿ç¨‹ä¼˜åŒ–ã€Web Workers

```typescript
// ä¸»çº¿ç¨‹ä¼˜åŒ–ï¼šä½¿ç”¨ Web Workers å¤„ç†è®¡ç®—å¯†é›†å‹ä»»åŠ¡
// composables/useWebWorker.ts
export const useWebWorker = () => {
  const processData = async (data: any) => {
    if (process.client) {
      const worker = new Worker('/workers/data-processor.js')
      
      return new Promise((resolve) => {
        worker.postMessage(data)
        worker.onmessage = (e) => {
          resolve(e.data)
          worker.terminate()
        }
      })
    }
  }
  
  return { processData }
}
```

**Cumulative Layout Shift (CLS)**
- **ç›®æ ‡å€¼**: â‰¤ 0.1
- **æŠ€æœ¯åŸç†**: è¡¡é‡è§†è§‰ç¨³å®šæ€§
- **ä¼˜åŒ–ç­–ç•¥**: å°ºå¯¸é¢„å®šä¹‰ã€éª¨æ¶å±ã€å­—ä½“ä¼˜åŒ–

```vue
<!-- CLS ä¼˜åŒ–ï¼šé¢„å®šä¹‰å›¾ç‰‡å°ºå¯¸ -->
<template>
  <div>
    <NuxtImg
      src="/images/product.jpg"
      width="400"
      height="300"
      :style="{ aspectRatio: '4/3' }"
      loading="lazy"
      placeholder
    />
  </div>
</template>
```

### Nuxt æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯æ ˆåˆ†æ

#### Nitro å¼•æ“æ ¸å¿ƒæœºåˆ¶

Nitro æ˜¯ Nuxt 3 çš„æœåŠ¡ç«¯å¼•æ“ï¼Œæä¾›äº†ç»Ÿä¸€çš„æœåŠ¡ç«¯è¿è¡Œæ—¶ç¯å¢ƒå’Œä¼˜åŒ–æœºåˆ¶ï¼š

```typescript
// nitro.config.ts - Nitro ä¼˜åŒ–é…ç½®
export default defineNitroConfig({
  // é¢„æ¸²æŸ“é…ç½®
  prerender: {
    routes: ['/sitemap.xml'],
    crawlLinks: true
  },
  
  // å‹ç¼©é…ç½®
  compression: true,
  
  // å®éªŒæ€§åŠŸèƒ½
  experimental: {
    wasm: true
  },
  
  // è·¯ç”±è§„åˆ™
  routeRules: {
    '/': { prerender: true },
    '/api/**': { headers: { 'cache-control': 's-maxage=60' } },
    '/admin/**': { ssr: false },
    '/blog/**': { isr: true }
  }
})
```

#### æ¸²æŸ“æ¨¡å¼æ€§èƒ½å¯¹æ¯”åˆ†æ

| æ¸²æŸ“æ¨¡å¼ | é¦–å±æ—¶é—´ | SEO å‹å¥½ | æœåŠ¡å™¨è´Ÿè½½ | ç¼“å­˜ç­–ç•¥ | é€‚ç”¨åœºæ™¯ |
|----------|----------|----------|------------|----------|----------|
| SSR | å¿« | ä¼˜ç§€ | é«˜ | åŠ¨æ€ | å†…å®¹ç½‘ç«™ã€ç”µå•† |
| SSG | æœ€å¿« | ä¼˜ç§€ | ä½ | é™æ€ | åšå®¢ã€æ–‡æ¡£ |
| SPA | æ…¢ | å·® | ä½ | å®¢æˆ·ç«¯ | ç®¡ç†åå° |
| ISR | å¿« | ä¼˜ç§€ | ä¸­ | æ™ºèƒ½ | å¤§å‹ç½‘ç«™ |
| æ··åˆæ¸²æŸ“ | ä¼˜åŒ– | çµæ´» | å¯æ§ | åˆ†å±‚ | ä¼ä¸šåº”ç”¨ |

## ç¬¬äºŒéƒ¨åˆ†ï¼šæ„å»ºæ—¶æ€§èƒ½ä¼˜åŒ–

### ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½ç­–ç•¥

#### è‡ªåŠ¨ä»£ç åˆ†å‰²æœºåˆ¶

Nuxt åŸºäºè·¯ç”±è‡ªåŠ¨è¿›è¡Œä»£ç åˆ†å‰²ï¼Œä½†æˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼š

```typescript
// nuxt.config.ts - é«˜çº§ä»£ç åˆ†å‰²é…ç½®
export default defineNuxtConfig({
  build: {
    splitChunks: {
      layouts: true,
      pages: true,
      commons: true
    }
  },
  
  // Vite ä¼˜åŒ–é…ç½®
  vite: {
    build: {
      rollupOptions: {
        output: {
          manualChunks(id) {
            // ç¬¬ä¸‰æ–¹åº“åˆ†ç¦»
            if (id.includes('node_modules')) {
              if (id.includes('vue') || id.includes('@vue')) {
                return 'vue-vendor'
              }
              if (id.includes('lodash')) {
                return 'lodash'
              }
              return 'vendor'
            }
          }
        }
      }
    }
  }
})
```

#### ç»„ä»¶çº§æ‡’åŠ è½½æœ€ä½³å®è·µ

```vue
<!-- pages/products/index.vue -->
<template>
  <div>
    <ProductHeader />
    
    <!-- å»¶è¿ŸåŠ è½½éå…³é”®ç»„ä»¶ -->
    <ClientOnly>
      <LazyProductRecommendations />
      <template #fallback>
        <div class="skeleton-loader">
          <div class="skeleton-item" v-for="i in 4" :key="i" />
        </div>
      </template>
    </ClientOnly>
    
    <!-- æ¡ä»¶æ‡’åŠ è½½ -->
    <LazyProductReviews v-if="showReviews" />
  </div>
</template>

<script setup>
// å¼‚æ­¥ç»„ä»¶å®šä¹‰
const LazyProductRecommendations = defineAsyncComponent(() => 
  import('~/components/ProductRecommendations.vue')
)

const showReviews = ref(false)

// å»¶è¿ŸåŠ è½½è¯„è®ºç»„ä»¶
onMounted(() => {
  setTimeout(() => {
    showReviews.value = true
  }, 2000)
})
</script>
```

#### åŠ¨æ€å¯¼å…¥ä¼˜åŒ–ç­–ç•¥

```typescript
// composables/useModuleLoader.ts
export const useModuleLoader = () => {
  const loadModule = async <T>(modulePath: string): Promise<T> => {
    try {
      // ä½¿ç”¨åŠ¨æ€å¯¼å…¥å¹¶æ·»åŠ é¢„å–æç¤º
      const module = await import(/* webpackChunkName: "dynamic-module" */ modulePath)
      return module.default
    } catch (error) {
      console.error(`Failed to load module: ${modulePath}`, error)
      throw error
    }
  }
  
  const preloadModule = (modulePath: string) => {
    // é¢„åŠ è½½æ¨¡å—ä»¥æå‡åç»­åŠ è½½é€Ÿåº¦
    if (process.client) {
      const link = document.createElement('link')
      link.rel = 'modulepreload'
      link.href = modulePath
      document.head.appendChild(link)
    }
  }
  
  return { loadModule, preloadModule }
}
```

### èµ„æºä¼˜åŒ–å’Œå‹ç¼©

#### å›¾åƒä¼˜åŒ–å…¨æ–¹ä½ç­–ç•¥

```typescript
// nuxt.config.ts - å›¾åƒä¼˜åŒ–é…ç½®
export default defineNuxtConfig({
  modules: ['@nuxt/image'],
  
  image: {
    // å›¾åƒæ ¼å¼ä¼˜åŒ–
    formats: {
      avif: {
        quality: 80
      },
      webp: {
        quality: 85
      }
    },
    
    // å“åº”å¼å›¾åƒé…ç½®
    screens: {
      xs: 320,
      sm: 640,
      md: 768,
      lg: 1024,
      xl: 1280,
      xxl: 1536
    },
    
    // å›¾åƒæä¾›å•†é…ç½®
    providers: {
      cloudinary: {
        baseURL: 'https://res.cloudinary.com/your-cloud/image/fetch/'
      }
    },
    
    // é¢„è®¾é…ç½®
    presets: {
      hero: {
        modifiers: {
          format: 'webp',
          quality: 90,
          width: 1200,
          height: 600
        }
      },
      thumbnail: {
        modifiers: {
          format: 'webp',
          quality: 80,
          width: 200,
          height: 200
        }
      }
    }
  }
})
```

```vue
<!-- é«˜æ€§èƒ½å›¾åƒç»„ä»¶ -->
<template>
  <div class="responsive-image-container">
    <NuxtPicture
      :src="imageSrc"
      :alt="imageAlt"
      :preset="imagePreset"
      :loading="imageLoading"
      :fetchpriority="fetchPriority"
      :sizes="responsiveSizes"
      @load="onImageLoad"
      @error="onImageError"
    />
  </div>
</template>

<script setup lang="ts">
interface Props {
  imageSrc: string
  imageAlt: string
  imagePreset?: 'hero' | 'thumbnail' | 'default'
  imageLoading?: 'lazy' | 'eager'
  fetchPriority?: 'high' | 'low' | 'auto'
  responsiveSizes?: string
}

const props = withDefaults(defineProps<Props>(), {
  imagePreset: 'default',
  imageLoading: 'lazy',
  fetchPriority: 'auto',
  responsiveSizes: '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw'
})

const onImageLoad = () => {
  // å›¾åƒåŠ è½½å®Œæˆåçš„å¤„ç†
  console.log('Image loaded successfully')
}

const onImageError = () => {
  // å›¾åƒåŠ è½½å¤±è´¥çš„å¤„ç†
  console.error('Failed to load image')
}
</script>
```

#### å­—ä½“ä¼˜åŒ–å’ŒåŠ è½½ç­–ç•¥

```typescript
// nuxt.config.ts - å­—ä½“ä¼˜åŒ–é…ç½®
export default defineNuxtConfig({
  modules: ['@nuxtjs/google-fonts'],
  
  googleFonts: {
    families: {
      'Inter': [400, 500, 600, 700],
      'JetBrains Mono': [400, 500]
    },
    display: 'swap',
    preload: true,
    useStylesheet: true,
    download: true,
    base64: false
  },
  
  app: {
    head: {
      link: [
        // å­—ä½“é¢„è¿æ¥
        { rel: 'preconnect', href: 'https://fonts.googleapis.com' },
        { rel: 'preconnect', href: 'https://fonts.gstatic.com', crossorigin: '' }
      ]
    }
  }
})
```

#### CSS ä¼˜åŒ–å’Œå…³é”®è·¯å¾„

```typescript
// nuxt.config.ts - CSS ä¼˜åŒ–é…ç½®
export default defineNuxtConfig({
  css: [
    '~/assets/css/critical.css', // å…³é”® CSS
    '~/assets/css/main.css'
  ],
  
  build: {
    // CSS æå–å’Œä¼˜åŒ–
    extractCSS: {
      ignoreOrder: true
    }
  },
  
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "~/assets/scss/variables.scss" as *;'
        }
      }
    }
  }
})
```

```scss
// assets/scss/critical.scss - å…³é”®è·¯å¾„ CSS
// é¦–å±å¿…éœ€çš„æ ·å¼
.layout-header {
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 1000;
  height: 64px;
  background: white;
  border-bottom: 1px solid #e5e7eb;
}

.hero-section {
  padding-top: 64px;
  min-height: 60vh;
  display: flex;
  align-items: center;
  justify-content: center;
}

// éª¨æ¶å±æ ·å¼
.skeleton-loader {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

.skeleton-item {
  height: 200px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
  border-radius: 8px;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
```

### Tree Shaking å’Œä¾èµ–ä¼˜åŒ–

#### æ™ºèƒ½ä¾èµ–åˆ†æå’Œä¼˜åŒ–

```typescript
// nuxt.config.ts - Tree Shaking ä¼˜åŒ–
export default defineNuxtConfig({
  build: {
    // åˆ†æåŒ…å¤§å°
    analyze: process.env.ANALYZE === 'true',
    
    // ä¼˜åŒ–ä¾èµ–
    optimization: {
      treeShake: true,
      minimize: true
    }
  },
  
  // è‡ªåŠ¨å¯¼å…¥ä¼˜åŒ–
  imports: {
    // ç¦ç”¨å…¨å±€å¯¼å…¥ï¼ŒæŒ‰éœ€å¯¼å…¥
    global: false,
    // è‡ªå®šä¹‰å¯¼å…¥
    imports: [
      { from: 'lodash-es', name: 'debounce', as: 'debounce' },
      { from: 'date-fns', name: 'format', as: 'formatDate' }
    ]
  }
})
```

```typescript
// utils/optimized-imports.ts - ä¼˜åŒ–çš„å¯¼å…¥ç­–ç•¥
// é”™è¯¯ç¤ºä¾‹ï¼šå¯¼å…¥æ•´ä¸ªåº“
// import _ from 'lodash'

// æ­£ç¡®ç¤ºä¾‹ï¼šæŒ‰éœ€å¯¼å…¥
import { debounce, throttle } from 'lodash-es'
import { format, addDays } from 'date-fns'

// åŠ¨æ€å¯¼å…¥å¤§å‹åº“
export const loadChartLibrary = async () => {
  const { Chart } = await import('chart.js/auto')
  return Chart
}

// æ¡ä»¶å¯¼å…¥
export const loadDevTools = async () => {
  if (process.dev) {
    const { setupDevtoolsPlugin } = await import('@vue/devtools-api')
    return setupDevtoolsPlugin
  }
}
```

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šè¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

### æœåŠ¡ç«¯æ¸²æŸ“ä¼˜åŒ–

#### SSR æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥

```typescript
// server/api/performance/[...slug].ts
export default defineEventHandler(async (event) => {
  const start = Date.now()
  
  try {
    // ç¼“å­˜æ£€æŸ¥
    const cached = await useStorage('redis').getItem(getRequestURL(event).pathname)
    if (cached) {
      setHeader(event, 'X-Cache', 'HIT')
      setHeader(event, 'X-Response-Time', `${Date.now() - start}ms`)
      return cached
    }
    
    // æ•°æ®è·å–ä¼˜åŒ–
    const [userData, contentData] = await Promise.all([
      $fetch('/api/user'),
      $fetch('/api/content')
    ])
    
    const result = {
      user: userData,
      content: contentData,
      timestamp: Date.now()
    }
    
    // è®¾ç½®ç¼“å­˜
    await useStorage('redis').setItem(
      getRequestURL(event).pathname, 
      result, 
      { ttl: 300 } // 5åˆ†é’Ÿç¼“å­˜
    )
    
    setHeader(event, 'X-Cache', 'MISS')
    setHeader(event, 'X-Response-Time', `${Date.now() - start}ms`)
    
    return result
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Internal Server Error'
    })
  }
})
```

#### æ•°æ®è·å–ä¼˜åŒ–æ¨¡å¼

```vue
<!-- pages/products/[id].vue -->
<template>
  <div>
    <ProductDetail :product="data.product" />
    <ProductReviews :reviews="data.reviews" />
    <ProductRecommendations :recommendations="data.recommendations" />
  </div>
</template>

<script setup>
// å¹¶è¡Œæ•°æ®è·å–
const { params } = useRoute()

const { data, error, pending } = await useLazyAsyncData(
  `product-${params.id}`,
  async () => {
    // å¹¶è¡Œè·å–æ‰€æœ‰éœ€è¦çš„æ•°æ®
    const [product, reviews, recommendations] = await Promise.all([
      $fetch(`/api/products/${params.id}`),
      $fetch(`/api/products/${params.id}/reviews`),
      $fetch(`/api/products/${params.id}/recommendations`)
    ])
    
    return {
      product,
      reviews,
      recommendations
    }
  },
  {
    // ç¼“å­˜é…ç½®
    server: true,
    client: true,
    default: () => ({
      product: null,
      reviews: [],
      recommendations: []
    })
  }
)

// SEO ä¼˜åŒ–
useHead({
  title: () => data.value?.product?.title || 'Product',
  meta: [
    {
      name: 'description',
      content: () => data.value?.product?.description || 'Product description'
    }
  ]
})
</script>
```

### å®¢æˆ·ç«¯æ€§èƒ½ä¼˜åŒ–

#### æ°´åˆ(Hydration)ä¼˜åŒ–

```vue
<!-- components/OptimizedComponent.vue -->
<template>
  <div>
    <!-- å…³é”®å†…å®¹ç«‹å³æ¸²æŸ“ -->
    <h1>{{ title }}</h1>
    <p>{{ description }}</p>
    
    <!-- éå…³é”®ç»„ä»¶å»¶è¿Ÿæ°´åˆ -->
    <ClientOnly>
      <InteractiveChart :data="chartData" />
      <template #fallback>
        <div class="chart-skeleton">Loading chart...</div>
      </template>
    </ClientOnly>
    
    <!-- æ¡ä»¶æ€§ç»„ä»¶ -->
    <LazyModal v-if="showModal" @close="showModal = false" />
  </div>
</template>

<script setup>
// ä½¿ç”¨ ref è€Œä¸æ˜¯ reactive æå‡æ€§èƒ½
const title = ref('')
const description = ref('')
const chartData = ref([])
const showModal = ref(false)

// ä¼˜åŒ–çš„æ•°æ®è·å–
onMounted(async () => {
  // åˆ†æ‰¹åŠ è½½æ•°æ®
  const basicData = await $fetch('/api/basic-data')
  title.value = basicData.title
  description.value = basicData.description
  
  // å»¶è¿ŸåŠ è½½å›¾è¡¨æ•°æ®
  setTimeout(async () => {
    chartData.value = await $fetch('/api/chart-data')
  }, 100)
})
</script>
```

#### çŠ¶æ€ç®¡ç†ä¼˜åŒ–

```typescript
// stores/performance.ts
export const usePerformanceStore = defineStore('performance', () => {
  // ä½¿ç”¨ Map æå‡æŸ¥æ‰¾æ€§èƒ½
  const cache = new Map<string, any>()
  const loadingStates = new Set<string>()
  
  // é˜²æŠ–çš„æ•°æ®è·å–
  const debouncedFetch = debounce(async (key: string, fetcher: Function) => {
    if (cache.has(key)) {
      return cache.get(key)
    }
    
    if (loadingStates.has(key)) {
      return new Promise(resolve => {
        const interval = setInterval(() => {
          if (cache.has(key)) {
            clearInterval(interval)
            resolve(cache.get(key))
          }
        }, 50)
      })
    }
    
    loadingStates.add(key)
    
    try {
      const result = await fetcher()
      cache.set(key, result)
      return result
    } finally {
      loadingStates.delete(key)
    }
  }, 100)
  
  // å†…å­˜ç®¡ç†
  const clearCache = () => {
    cache.clear()
    loadingStates.clear()
  }
  
  // ç¼“å­˜å¤§å°é™åˆ¶
  const limitCacheSize = (maxSize: number = 50) => {
    if (cache.size > maxSize) {
      const keys = Array.from(cache.keys())
      const keysToDelete = keys.slice(0, cache.size - maxSize)
      keysToDelete.forEach(key => cache.delete(key))
    }
  }
  
  return {
    debouncedFetch,
    clearCache,
    limitCacheSize,
    getCacheSize: () => cache.size
  }
})
```

### ç¼“å­˜ç­–ç•¥æ·±åº¦ä¼˜åŒ–

#### å¤šå±‚ç¼“å­˜æ¶æ„è®¾è®¡

```typescript
// utils/cache-manager.ts
interface CacheConfig {
  ttl?: number
  storage?: 'memory' | 'sessionStorage' | 'localStorage' | 'redis'
  namespace?: string
}

export class CacheManager {
  private memoryCache = new Map<string, { data: any; expires: number }>()
  private readonly defaultTTL = 300000 // 5åˆ†é’Ÿ
  
  async get<T>(key: string, config?: CacheConfig): Promise<T | null> {
    const fullKey = this.getFullKey(key, config?.namespace)
    
    // 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
    const memoryResult = this.getFromMemory<T>(fullKey)
    if (memoryResult !== null) return memoryResult
    
    // 2. æ£€æŸ¥æµè§ˆå™¨å­˜å‚¨
    if (process.client && config?.storage) {
      const browserResult = this.getFromBrowser<T>(fullKey, config.storage)
      if (browserResult !== null) {
        // å›å¡«å†…å­˜ç¼“å­˜
        this.setToMemory(fullKey, browserResult, config?.ttl)
        return browserResult
      }
    }
    
    // 3. æ£€æŸ¥æœåŠ¡ç«¯ç¼“å­˜ (Redis)
    if (process.server && config?.storage === 'redis') {
      const redisResult = await this.getFromRedis<T>(fullKey)
      if (redisResult !== null) return redisResult
    }
    
    return null
  }
  
  async set<T>(
    key: string, 
    data: T, 
    config?: CacheConfig
  ): Promise<void> {
    const fullKey = this.getFullKey(key, config?.namespace)
    const ttl = config?.ttl || this.defaultTTL
    
    // è®¾ç½®å†…å­˜ç¼“å­˜
    this.setToMemory(fullKey, data, ttl)
    
    // è®¾ç½®æµè§ˆå™¨å­˜å‚¨
    if (process.client && config?.storage) {
      this.setBrowser(fullKey, data, config.storage, ttl)
    }
    
    // è®¾ç½®æœåŠ¡ç«¯ç¼“å­˜
    if (process.server && config?.storage === 'redis') {
      await this.setRedis(fullKey, data, ttl)
    }
  }
  
  private getFromMemory<T>(key: string): T | null {
    const cached = this.memoryCache.get(key)
    if (cached && cached.expires > Date.now()) {
      return cached.data
    }
    
    if (cached) {
      this.memoryCache.delete(key)
    }
    
    return null
  }
  
  private setToMemory<T>(key: string, data: T, ttl: number): void {
    this.memoryCache.set(key, {
      data,
      expires: Date.now() + ttl
    })
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    this.cleanupMemoryCache()
  }
  
  private cleanupMemoryCache(): void {
    const now = Date.now()
    for (const [key, value] of this.memoryCache.entries()) {
      if (value.expires <= now) {
        this.memoryCache.delete(key)
      }
    }
  }
  
  private getFullKey(key: string, namespace?: string): string {
    return namespace ? `${namespace}:${key}` : key
  }
}

// å•ä¾‹æ¨¡å¼
export const cacheManager = new CacheManager()
```

#### æ™ºèƒ½ç¼“å­˜ç­–ç•¥å®ç°

```typescript
// composables/useSmartCache.ts
export const useSmartCache = () => {
  const getCacheStrategy = (path: string) => {
    // åŸºäºè·¯å¾„ç¡®å®šç¼“å­˜ç­–ç•¥
    if (path.startsWith('/api/static/')) {
      return { ttl: 86400000, storage: 'localStorage' } // 1å¤©
    }
    
    if (path.startsWith('/api/user/')) {
      return { ttl: 300000, storage: 'sessionStorage' } // 5åˆ†é’Ÿ
    }
    
    if (path.startsWith('/api/realtime/')) {
      return { ttl: 30000, storage: 'memory' } // 30ç§’
    }
    
    return { ttl: 600000, storage: 'memory' } // é»˜è®¤10åˆ†é’Ÿ
  }
  
  const cachedFetch = async <T>(
    url: string, 
    options?: RequestInit
  ): Promise<T> => {
    const cacheKey = `fetch:${url}:${JSON.stringify(options)}`
    const strategy = getCacheStrategy(url)
    
    // å°è¯•ä»ç¼“å­˜è·å–
    const cached = await cacheManager.get<T>(cacheKey, strategy)
    if (cached !== null) {
      return cached
    }
    
    // æ‰§è¡Œè¯·æ±‚
    const result = await $fetch<T>(url, options)
    
    // å­˜å‚¨åˆ°ç¼“å­˜
    await cacheManager.set(cacheKey, result, strategy)
    
    return result
  }
  
  return { cachedFetch }
}
```

## ç¬¬å››éƒ¨åˆ†ï¼šé«˜çº§ä¼˜åŒ–æŠ€æœ¯

### Nitro å¼•æ“æ·±åº¦ä¼˜åŒ–

#### è¾¹ç¼˜æ¸²æŸ“å’Œåˆ†å¸ƒå¼éƒ¨ç½²

```typescript
// nitro.config.ts - è¾¹ç¼˜ä¼˜åŒ–é…ç½®
export default defineNitroConfig({
  // è¾¹ç¼˜å‡½æ•°é…ç½®
  experimental: {
    wasm: true,
    legacyExternals: false
  },
  
  // é¢„è®¾é…ç½®ç”¨äºä¸åŒå¹³å°
  preset: 'cloudflare-pages', // æˆ– 'vercel-edge', 'netlify-edge'
  
  // è·¯ç”±è§„åˆ™ä¼˜åŒ–
  routeRules: {
    '/': { 
      prerender: true,
      headers: { 'cache-control': 's-maxage=31536000' }
    },
    '/api/edge/**': { 
      headers: { 'cache-control': 's-maxage=60' }
    },
    '/blog/**': { 
      isr: 86400, // 24å°æ—¶å¢é‡é™æ€å†ç”Ÿ
      headers: { 'cache-control': 's-maxage=86400' }
    }
  },
  
  // å‹ç¼©å’Œä¼˜åŒ–
  minify: true,
  sourceMap: false,
  
  // å­˜å‚¨é…ç½®
  storage: {
    redis: {
      driver: 'redis',
      host: process.env.REDIS_HOST || 'localhost',
      port: process.env.REDIS_PORT || 6379,
      password: process.env.REDIS_PASSWORD
    }
  }
})
```

#### æœåŠ¡ç«¯ç»„ä»¶å’Œå²›å±¿æ¶æ„

```vue
<!-- components/ServerOnlyComponent.vue -->
<template>
  <div class="server-component">
    <h2>{{ data.title }}</h2>
    <p>{{ data.description }}</p>
    
    <!-- æœåŠ¡ç«¯æ¸²æŸ“çš„å¤æ‚å†…å®¹ -->
    <div v-html="data.processedContent"></div>
  </div>
</template>

<script setup>
// æœåŠ¡ç«¯ä¸“ç”¨ç»„ä»¶ï¼Œä¸ä¼šå‘é€åˆ°å®¢æˆ·ç«¯
defineOptions({
  _hydrationKey: false // ç¦ç”¨æ°´åˆ
})

const { data } = await $fetch('/api/server-data')

// æœåŠ¡ç«¯å¤„ç†å¤æ‚é€»è¾‘
const processContent = (content: string) => {
  // å¤æ‚çš„å†…å®¹å¤„ç†é€»è¾‘
  return content.replace(/\[([^\]]+)\]/g, '<strong>$1</strong>')
}

data.processedContent = processContent(data.content)
</script>
```

```vue
<!-- pages/hybrid-example.vue -->
<template>
  <div>
    <!-- æœåŠ¡ç«¯ç»„ä»¶ -->
    <NuxtIsland name="ServerOnlyComponent" />
    
    <!-- å®¢æˆ·ç«¯äº¤äº’ç»„ä»¶ -->
    <ClientOnly>
      <InteractiveWidget />
    </ClientOnly>
    
    <!-- æ··åˆç»„ä»¶ -->
    <HybridComponent :initial-data="serverData" />
  </div>
</template>

<script setup>
// æœåŠ¡ç«¯æ•°æ®é¢„å–
const { data: serverData } = await useFetch('/api/initial-data')
</script>
```

### æ¨¡å—åŒ–æ€§èƒ½ä¼˜åŒ–

#### å…³é”®æ€§èƒ½æ¨¡å—é›†æˆ

```typescript
// nuxt.config.ts - æ€§èƒ½æ¨¡å—é…ç½®
export default defineNuxtConfig({
  modules: [
    '@nuxt/image',
    '@nuxtjs/fontaine',
    'nuxt-delay-hydration',
    '@nuxtjs/partytown',
    '@nuxt/scripts'
  ],
  
  // å›¾åƒä¼˜åŒ–æ¨¡å—
  image: {
    provider: 'cloudinary',
    cloudinary: {
      baseURL: 'https://res.cloudinary.com/your-cloud/image/fetch/'
    },
    presets: {
      cover: {
        modifiers: {
          fit: 'cover',
          format: 'avif,webp,jpg',
          quality: 'auto:best'
        }
      }
    }
  },
  
  // å­—ä½“ä¼˜åŒ–æ¨¡å—
  fontMetrics: {
    fonts: ['Inter', 'JetBrains Mono']
  },
  
  // å»¶è¿Ÿæ°´åˆæ¨¡å—
  delayHydration: {
    mode: 'mount',
    debug: process.env.NODE_ENV === 'development'
  },
  
  // Partytown é…ç½®ï¼ˆç¬¬ä¸‰æ–¹è„šæœ¬ä¼˜åŒ–ï¼‰
  partytown: {
    forward: ['dataLayer.push']
  },
  
  // è„šæœ¬ä¼˜åŒ–æ¨¡å—
  scripts: {
    registry: {
      googleAnalytics: {
        id: 'G-XXXXXXXXXX'
      }
    }
  }
})
```

#### è‡ªå®šä¹‰æ€§èƒ½ä¼˜åŒ–æ’ä»¶

```typescript
// plugins/performance-monitor.client.ts
export default defineNuxtPlugin(() => {
  if (process.client) {
    // æ€§èƒ½ç›‘æ§
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        // å‘é€æ€§èƒ½æ•°æ®åˆ°åˆ†ææœåŠ¡
        if (entry.name === 'largest-contentful-paint') {
          sendMetric('lcp', entry.startTime)
        }
        
        if (entry.name === 'first-input-delay') {
          sendMetric('fid', entry.processingStart - entry.startTime)
        }
        
        if (entry.name === 'cumulative-layout-shift') {
          sendMetric('cls', entry.value)
        }
      }
    })
    
    observer.observe({ type: 'largest-contentful-paint', buffered: true })
    observer.observe({ type: 'first-input', buffered: true })
    observer.observe({ type: 'layout-shift', buffered: true })
    
    // è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡
    const measureNavigationTiming = () => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      
      const metrics = {
        dns: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcp: navigation.connectEnd - navigation.connectStart,
        ttfb: navigation.responseStart - navigation.requestStart,
        download: navigation.responseEnd - navigation.responseStart,
        domLoad: navigation.domContentLoadedEventEnd - navigation.navigationStart,
        windowLoad: navigation.loadEventEnd - navigation.navigationStart
      }
      
      sendMetrics(metrics)
    }
    
    // é¡µé¢åŠ è½½å®Œæˆåæµ‹é‡
    window.addEventListener('load', measureNavigationTiming)
  }
})

const sendMetric = (name: string, value: number) => {
  if (navigator.sendBeacon) {
    const data = JSON.stringify({ metric: name, value, timestamp: Date.now() })
    navigator.sendBeacon('/api/metrics', data)
  }
}

const sendMetrics = (metrics: Record<string, number>) => {
  if (navigator.sendBeacon) {
    const data = JSON.stringify({ metrics, timestamp: Date.now() })
    navigator.sendBeacon('/api/metrics', data)
  }
}
```

### ç›‘æ§å’Œè¯Šæ–­ä½“ç³»

#### æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿

```typescript
// server/api/metrics.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  
  // å­˜å‚¨æ€§èƒ½æŒ‡æ ‡
  await useStorage('redis').setItem(
    `metrics:${Date.now()}`,
    {
      ...body,
      userAgent: getHeader(event, 'user-agent'),
      ip: getClientIP(event),
      timestamp: Date.now()
    }
  )
  
  return { status: 'ok' }
})
```

```vue
<!-- components/PerformanceDashboard.vue -->
<template>
  <div class="performance-dashboard">
    <div class="metrics-grid">
      <MetricCard 
        title="Largest Contentful Paint"
        :value="metrics.lcp"
        unit="ms"
        :threshold="2500"
      />
      
      <MetricCard 
        title="First Input Delay"
        :value="metrics.fid"
        unit="ms"
        :threshold="100"
      />
      
      <MetricCard 
        title="Cumulative Layout Shift"
        :value="metrics.cls"
        unit=""
        :threshold="0.1"
      />
      
      <MetricCard 
        title="Time to First Byte"
        :value="metrics.ttfb"
        unit="ms"
        :threshold="800"
      />
    </div>
    
    <PerformanceChart :data="chartData" />
  </div>
</template>

<script setup>
const { data: metrics } = await useFetch('/api/performance/summary')
const { data: chartData } = await useFetch('/api/performance/chart')
</script>
```

#### å®æ—¶æ€§èƒ½è¯Šæ–­å·¥å…·

```typescript
// composables/usePerformanceDiagnostics.ts
export const usePerformanceDiagnostics = () => {
  const diagnostics = ref({
    bundleSize: 0,
    unusedCSS: [],
    largeImages: [],
    slowQueries: [],
    memoryUsage: 0
  })
  
  const runDiagnostics = async () => {
    if (process.client) {
      // æ£€æŸ¥åŒ…å¤§å°
      diagnostics.value.bundleSize = await getBundleSize()
      
      // æ£€æŸ¥æœªä½¿ç”¨çš„ CSS
      diagnostics.value.unusedCSS = await getUnusedCSS()
      
      // æ£€æŸ¥å¤§å›¾åƒ
      diagnostics.value.largeImages = await getLargeImages()
      
      // æ£€æŸ¥å†…å­˜ä½¿ç”¨
      diagnostics.value.memoryUsage = getMemoryUsage()
    }
    
    if (process.server) {
      // æ£€æŸ¥æ…¢æŸ¥è¯¢
      diagnostics.value.slowQueries = await getSlowQueries()
    }
  }
  
  const getBundleSize = async (): Promise<number> => {
    const entries = performance.getEntriesByType('resource')
    return entries
      .filter(entry => entry.name.includes('.js'))
      .reduce((total, entry) => total + (entry as any).transferSize, 0)
  }
  
  const getUnusedCSS = async (): Promise<string[]> => {
    const stylesheets = Array.from(document.styleSheets)
    const unusedRules: string[] = []
    
    for (const stylesheet of stylesheets) {
      try {
        const rules = Array.from(stylesheet.cssRules)
        for (const rule of rules) {
          if (rule instanceof CSSStyleRule) {
            if (!document.querySelector(rule.selectorText)) {
              unusedRules.push(rule.selectorText)
            }
          }
        }
      } catch (e) {
        // Cross-origin stylesheets
      }
    }
    
    return unusedRules
  }
  
  const getLargeImages = async (): Promise<Array<{src: string, size: number}>> => {
    const images = Array.from(document.images)
    const largeImages: Array<{src: string, size: number}> = []
    
    for (const img of images) {
      const entry = performance.getEntriesByName(img.src)[0] as any
      if (entry && entry.transferSize > 100000) { // 100KB
        largeImages.push({
          src: img.src,
          size: entry.transferSize
        })
      }
    }
    
    return largeImages
  }
  
  const getMemoryUsage = (): number => {
    return (performance as any).memory?.usedJSHeapSize || 0
  }
  
  const getSlowQueries = async (): Promise<string[]> => {
    // æœåŠ¡ç«¯æŸ¥è¯¢æ€§èƒ½ç›‘æ§
    return await $fetch('/api/performance/slow-queries')
  }
  
  return {
    diagnostics: readonly(diagnostics),
    runDiagnostics
  }
}
```

## ç¬¬äº”éƒ¨åˆ†ï¼šä¼ä¸šçº§æ€§èƒ½ä¼˜åŒ–å®è·µ

### å¤§è§„æ¨¡åº”ç”¨æ€§èƒ½ä¼˜åŒ–

#### å¾®å‰ç«¯æ¶æ„ä¸‹çš„æ€§èƒ½ä¼˜åŒ–

```typescript
// nuxt.config.ts - å¾®å‰ç«¯é…ç½®
export default defineNuxtConfig({
  // æ¨¡å—è”é‚¦é…ç½®
  vite: {
    build: {
      rollupOptions: {
        external: ['vue', '@vue/shared'],
        output: {
          globals: {
            vue: 'Vue'
          }
        }
      }
    },
    plugins: [
      // æ¨¡å—è”é‚¦æ’ä»¶
      federation({
        name: 'host-app',
        remotes: {
          'micro-app-1': 'http://localhost:3001/assets/remoteEntry.js',
          'micro-app-2': 'http://localhost:3002/assets/remoteEntry.js'
        },
        shared: {
          vue: {
            singleton: true,
            requiredVersion: '^3.0.0'
          }
        }
      })
    ]
  },
  
  // è·¯ç”±é…ç½®
  hooks: {
    'render:route': (url, result, context) => {
      // åŠ¨æ€è·¯ç”±åˆ†å‘åˆ°å¾®åº”ç”¨
      if (url.startsWith('/micro-app-1')) {
        return loadMicroApp('micro-app-1', url, context)
      }
    }
  }
})
```

#### å¤šç¯å¢ƒæ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```typescript
// config/performance.config.ts
interface PerformanceConfig {
  cacheStrategy: 'aggressive' | 'moderate' | 'minimal'
  bundleSplitting: boolean
  imageOptimization: boolean
  serverRendering: boolean
}

const getPerformanceConfig = (): PerformanceConfig => {
  const env = process.env.NODE_ENV
  const isProduction = env === 'production'
  
  return {
    cacheStrategy: isProduction ? 'aggressive' : 'minimal',
    bundleSplitting: isProduction,
    imageOptimization: isProduction,
    serverRendering: isProduction
  }
}

export const performanceConfig = getPerformanceConfig()
```

### æŒç»­æ€§èƒ½ä¼˜åŒ–æµç¨‹

#### CI/CD æ€§èƒ½æ£€æŸ¥

```yaml
# .github/workflows/performance.yml
name: Performance Check

on:
  pull_request:
    branches: [main]

jobs:
  performance-audit:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build
      
      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
      
      - name: Bundle size check
        run: |
          npm run build:analyze
          node scripts/bundle-size-check.js
      
      - name: Performance regression test
        run: npm run test:performance
```

```javascript
// scripts/bundle-size-check.js
const fs = require('fs')
const path = require('path')

const MAX_BUNDLE_SIZE = 250 * 1024 // 250KB
const BUILD_DIR = '.output/public/_nuxt'

const checkBundleSize = () => {
  const files = fs.readdirSync(BUILD_DIR)
  const jsFiles = files.filter(file => file.endsWith('.js'))
  
  let totalSize = 0
  const largeBundles = []
  
  jsFiles.forEach(file => {
    const filePath = path.join(BUILD_DIR, file)
    const stats = fs.statSync(filePath)
    const size = stats.size
    
    totalSize += size
    
    if (size > MAX_BUNDLE_SIZE) {
      largeBundles.push({ file, size })
    }
  })
  
  console.log(`Total JS bundle size: ${(totalSize / 1024).toFixed(2)}KB`)
  
  if (largeBundles.length > 0) {
    console.error('Large bundles detected:')
    largeBundles.forEach(({ file, size }) => {
      console.error(`- ${file}: ${(size / 1024).toFixed(2)}KB`)
    })
    process.exit(1)
  }
  
  console.log('âœ… Bundle size check passed')
}

checkBundleSize()
```

## æœ€ä½³å®è·µæ€»ç»“

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

#### æ„å»ºæ—¶ä¼˜åŒ–
- [ ] å¯ç”¨ä»£ç åˆ†å‰²å’Œ Tree Shaking
- [ ] é…ç½®å›¾åƒå’Œå­—ä½“ä¼˜åŒ–
- [ ] å®æ–½ CSS ä¼˜åŒ–å’Œå…³é”®è·¯å¾„åˆ†ç¦»
- [ ] è®¾ç½®ä¾èµ–åˆ†æå’ŒåŒ…å¤§å°ç›‘æ§
- [ ] é…ç½®å‹ç¼©å’Œæœ€å°åŒ–

#### è¿è¡Œæ—¶ä¼˜åŒ–
- [ ] å®æ–½æ™ºèƒ½ç¼“å­˜ç­–ç•¥
- [ ] ä¼˜åŒ–æ•°æ®è·å–å’ŒçŠ¶æ€ç®¡ç†
- [ ] é…ç½®æœåŠ¡ç«¯æ¸²æŸ“ä¼˜åŒ–
- [ ] å®æ–½æ‡’åŠ è½½å’Œå»¶è¿Ÿæ°´åˆ
- [ ] è®¾ç½®æ€§èƒ½ç›‘æ§å’Œè¯Šæ–­

#### éƒ¨ç½²å’Œç›‘æ§
- [ ] é…ç½® CDN å’Œè¾¹ç¼˜è®¡ç®—
- [ ] è®¾ç½®æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿
- [ ] å®æ–½ CI/CD æ€§èƒ½æ£€æŸ¥
- [ ] é…ç½®é”™è¯¯ç›‘æ§å’Œå‘Šè­¦
- [ ] å»ºç«‹æ€§èƒ½ä¼˜åŒ–è¿­ä»£æµç¨‹

### æ€§èƒ½ä¼˜åŒ–æ³¨æ„äº‹é¡¹

::alert{icon="lucide:alert-triangle" color="amber"}
**é‡è¦æé†’**: 
1. æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦æ ¹æ®å®é™…ä¸šåŠ¡åœºæ™¯è¿›è¡Œè°ƒæ•´
2. è¿‡åº¦ä¼˜åŒ–å¯èƒ½å¯¼è‡´ä»£ç å¤æ‚åº¦å¢åŠ å’Œç»´æŠ¤å›°éš¾
3. å§‹ç»ˆä»¥ç”¨æˆ·ä½“éªŒä¸ºä¸­å¿ƒï¼Œå¹³è¡¡æ€§èƒ½å’ŒåŠŸèƒ½éœ€æ±‚
4. å®šæœŸè¿›è¡Œæ€§èƒ½æµ‹è¯•å’Œç›‘æ§ï¼ŒåŠæ—¶å‘ç°å’Œè§£å†³æ€§èƒ½é—®é¢˜
::

### æ¨èçš„æ€§èƒ½ä¼˜åŒ–å·¥å…·

- **åˆ†æå·¥å…·**: Lighthouse, WebPageTest, Chrome DevTools
- **ç›‘æ§å·¥å…·**: Google Analytics, Sentry, LogRocket
- **æ„å»ºå·¥å…·**: Vite, Webpack Bundle Analyzer
- **å›¾åƒä¼˜åŒ–**: Cloudinary, ImageKit, TinyPNG
- **CDNæœåŠ¡**: Cloudflare, AWS CloudFront, Vercel

é€šè¿‡ç³»ç»Ÿæ€§åœ°åº”ç”¨æœ¬æŒ‡å—ä¸­çš„ä¼˜åŒ–ç­–ç•¥ï¼Œæ‚¨å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„ Nuxt åº”ç”¨ï¼Œä¸ºç”¨æˆ·æä¾›å“è¶Šçš„ Web ä½“éªŒã€‚è®°ä½ï¼Œæ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦æ ¹æ®åº”ç”¨çš„å‘å±•å’Œç”¨æˆ·åé¦ˆä¸æ–­è°ƒæ•´å’Œæ”¹è¿›ã€‚ 