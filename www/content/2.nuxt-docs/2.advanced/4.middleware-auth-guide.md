---
title: ä¸­é—´ä»¶ä¸æƒé™æ§åˆ¶å®è·µæŒ‡å—å’ŒæŠ€æœ¯åŸç†
description: æ·±å…¥è§£æ Nuxt æ¡†æ¶ä¸­é—´ä»¶ç³»ç»Ÿçš„æŠ€æœ¯æ¶æ„å’Œå·¥ä½œåŸç†ï¼Œæ¶µç›–å…¨å±€ä¸­é—´ä»¶ã€è·¯ç”±ä¸­é—´ä»¶ã€æœåŠ¡ç«¯ä¸­é—´ä»¶çš„å®ç°æœºåˆ¶ï¼Œä»¥åŠ JWT è®¤è¯ã€OAuth2 é›†æˆã€æƒé™æ§åˆ¶ç­–ç•¥ç­‰å®è·µæŒ‡å—ï¼Œæ„å»ºå®‰å…¨å¯é çš„ä¼ä¸šçº§åº”ç”¨
icon: 'lucide:shield-check'
---

## æ¦‚è¿°

åœ¨ç°ä»£ Web åº”ç”¨å¼€å‘ä¸­ï¼Œå®‰å…¨æ€§å’Œæƒé™æ§åˆ¶æ˜¯ä¿éšœä¸šåŠ¡æ•°æ®å’Œç”¨æˆ·éšç§çš„æ ¸å¿ƒè¦ç´ ã€‚æ® OWASP 2023 æŠ¥å‘Šæ˜¾ç¤ºï¼Œèº«ä»½éªŒè¯å’Œæƒé™ç®¡ç†é—®é¢˜ä»ä½å±… Web åº”ç”¨åå¤§å®‰å…¨é£é™©ä¹‹åˆ—ã€‚Nuxt æ¡†æ¶åŸºäºå¼ºå¤§çš„ä¸­é—´ä»¶ç³»ç»Ÿï¼Œæä¾›äº†å®Œæ•´çš„æƒé™æ§åˆ¶è§£å†³æ–¹æ¡ˆï¼Œä»è·¯ç”±ä¿æŠ¤åˆ° API å®‰å…¨ï¼Œä»å®¢æˆ·ç«¯éªŒè¯åˆ°æœåŠ¡ç«¯é‰´æƒã€‚

æœ¬æŒ‡å—å°†æ·±å…¥æ¢è®¨ Nuxt ä¸­é—´ä»¶ç³»ç»Ÿçš„æŠ€æœ¯æ¶æ„å’Œå®ç°åŸç†ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºå®‰å…¨ã€é«˜æ•ˆçš„æƒé™æ§åˆ¶ä½“ç³»ã€‚

### ğŸ¯ æ ¸å¿ƒç›®æ ‡

- æ·±å…¥ç†è§£ Nuxt ä¸­é—´ä»¶ç³»ç»Ÿçš„æŠ€æœ¯æ¶æ„å’Œæ‰§è¡Œæœºåˆ¶
- æŒæ¡å…¨å±€ä¸­é—´ä»¶ã€è·¯ç”±ä¸­é—´ä»¶ã€æœåŠ¡ç«¯ä¸­é—´ä»¶çš„æœ€ä½³å®è·µ
- å­¦ä¼šæ„å»ºå®Œæ•´çš„è®¤è¯æˆæƒä½“ç³»ï¼ˆJWTã€OAuth2ã€RBACï¼‰
- æŒæ¡ Web å®‰å…¨é˜²æŠ¤æŠ€æœ¯ï¼ˆCSRFã€XSSã€è¯·æ±‚é™åˆ¶é˜²æŠ¤ï¼‰
- å­¦ä¼šè®¾è®¡ä¼ä¸šçº§æƒé™æ§åˆ¶æ¶æ„å’Œç›‘æ§ä½“ç³»

### ğŸ’¡ æŠ€æœ¯æ¶æ„ä½“ç³»

- **Nitro å¼•æ“**: ç»Ÿä¸€çš„æœåŠ¡ç«¯è¿è¡Œæ—¶å’Œä¸­é—´ä»¶æ‰§è¡Œç¯å¢ƒ
- **Vue Router**: å®¢æˆ·ç«¯è·¯ç”±ä¿æŠ¤å’Œå¯¼èˆªå®ˆå«æœºåˆ¶
- **H3**: è½»é‡çº§ HTTP æ¡†æ¶å’Œä¸­é—´ä»¶ç³»ç»Ÿ
- **unjs ç”Ÿæ€**: joseã€ofetchã€unstorage ç­‰å®‰å…¨å·¥å…·é“¾
- **è¾¹ç¼˜è®¡ç®—**: Edge Runtime å’Œåˆ†å¸ƒå¼è®¤è¯ç­–ç•¥

::alert{icon="lucide:lightbulb" color="blue"}
**å®‰å…¨æ¶æ„ç†å¿µ**: Nuxt çš„å®‰å…¨ä½“ç³»åŸºäº "çºµæ·±é˜²å¾¡" å’Œ "æœ€å°æƒé™åŸåˆ™"ï¼Œé€šè¿‡å¤šå±‚æ¬¡çš„ä¸­é—´ä»¶ç³»ç»Ÿå’Œå®‰å…¨ç­–ç•¥ï¼Œç¡®ä¿ä»å®¢æˆ·ç«¯åˆ°æœåŠ¡ç«¯çš„å…¨é“¾è·¯å®‰å…¨ä¿æŠ¤ã€‚
::

## ç¬¬ä¸€éƒ¨åˆ†ï¼šä¸­é—´ä»¶ç³»ç»Ÿæ·±åº¦è§£æ

### 8.1 ä¸­é—´ä»¶ç±»å‹ä¸æ‰§è¡Œæœºåˆ¶

Nuxt 3 åŸºäº Nitro å¼•æ“æä¾›äº†ä¸‰ç§ç±»å‹çš„ä¸­é—´ä»¶ï¼Œæ¯ç§ç±»å‹éƒ½æœ‰ç‰¹å®šçš„æ‰§è¡Œæ—¶æœºå’Œé€‚ç”¨åœºæ™¯ã€‚

#### 8.1.1 å…¨å±€ä¸­é—´ä»¶

å…¨å±€ä¸­é—´ä»¶åœ¨æ¯æ¬¡è·¯ç”±å˜åŒ–æ—¶è‡ªåŠ¨æ‰§è¡Œï¼Œæ˜¯å®ç°å…¨ç«™æƒé™æ§åˆ¶çš„æ ¸å¿ƒæœºåˆ¶ã€‚

**æŠ€æœ¯åŸç†ä¸æ‰§è¡Œæ—¶æœº**

```typescript
// middleware/auth.global.ts
export default defineNuxtRouteMiddleware((to) => {
  console.log('å…¨å±€ä¸­é—´ä»¶æ‰§è¡Œæ—¶æœºï¼š', {
    æ‰§è¡Œé˜¶æ®µ: 'è·¯ç”±å¯¼èˆªå‰',
    æ‰§è¡Œç¯å¢ƒ: process.client ? 'å®¢æˆ·ç«¯' : 'æœåŠ¡ç«¯',
    ç›®æ ‡è·¯ç”±: to.path,
    æ‰§è¡Œæ—¶é—´: Date.now()
  })
  
  // è·å–ç”¨æˆ·è®¤è¯çŠ¶æ€
  const { $auth } = useNuxtApp()
  const user = useAuthUser()
  
  // ç™½åå•è·¯ç”±æ£€æŸ¥
  const publicRoutes = ['/login', '/register', '/forgot-password', '/']
  const isPublicRoute = publicRoutes.some(route => 
    to.path.startsWith(route)
  )
  
  // æƒé™éªŒè¯é€»è¾‘
  if (!isPublicRoute && !user.value) {
    console.warn('æœªæˆæƒè®¿é—®å°è¯•ï¼š', {
      targetRoute: to.path,
      userAgent: process.client ? navigator.userAgent : 'SSR',
      timestamp: new Date().toISOString()
    })
    
    // ä¿å­˜ç›®æ ‡è·¯ç”±ç”¨äºç™»å½•åé‡å®šå‘
    if (process.client) {
      localStorage.setItem('redirectAfterAuth', to.fullPath)
    }
    
    return navigateTo('/login')
  }
})
```

**é«˜çº§åº”ç”¨åœºæ™¯**

```typescript
// middleware/security.global.ts
export default defineNuxtRouteMiddleware((to, from) => {
  // å®‰å…¨ç­–ç•¥æ£€æŸ¥
  const securityChecks = {
    // 1. æ£€æŸ¥æ¶æ„è·¯ç”±æ¨¡å¼
    validateRouteSecurity: () => {
      const suspiciousPatterns = [
        /\.\.\//, // è·¯å¾„éå†æ”»å‡»
        /<script/, // XSS æ”»å‡»æ¨¡å¼
        /union.*select/i, // SQL æ³¨å…¥æ¨¡å¼
      ]
      
      return !suspiciousPatterns.some(pattern => 
        pattern.test(to.path)
      )
    },
    
    // 2. æ£€æŸ¥è®¿é—®é¢‘ç‡é™åˆ¶
    validateRateLimit: () => {
      if (process.client) {
        const requestLog = JSON.parse(
          localStorage.getItem('requestLog') || '[]'
        )
        const now = Date.now()
        const recentRequests = requestLog.filter(
          (timestamp: number) => now - timestamp < 60000 // 1åˆ†é’Ÿå†…
        )
        
        if (recentRequests.length > 100) {
          console.warn('æ£€æµ‹åˆ°å¼‚å¸¸è®¿é—®é¢‘ç‡')
          return false
        }
        
        requestLog.push(now)
        localStorage.setItem('requestLog', JSON.stringify(
          requestLog.slice(-50) // ä¿ç•™æœ€è¿‘50æ¡è®°å½•
        ))
      }
      return true
    },
    
    // 3. æ£€æŸ¥è®¾å¤‡æŒ‡çº¹
    validateDeviceFingerprint: () => {
      if (process.client && from) {
        const deviceInfo = {
          userAgent: navigator.userAgent,
          screen: `${screen.width}x${screen.height}`,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language
        }
        
        const fingerprint = btoa(JSON.stringify(deviceInfo))
        const storedFingerprint = localStorage.getItem('deviceFingerprint')
        
        if (storedFingerprint && storedFingerprint !== fingerprint) {
          console.warn('è®¾å¤‡æŒ‡çº¹å˜åŒ–æ£€æµ‹')
          // å¯ä»¥è§¦å‘é¢å¤–éªŒè¯æˆ–ç™»å‡º
        } else {
          localStorage.setItem('deviceFingerprint', fingerprint)
        }
      }
      return true
    }
  }
  
  // æ‰§è¡Œå®‰å…¨æ£€æŸ¥
  const securityPassed = Object.values(securityChecks).every(check => check())
  
  if (!securityPassed) {
    throw createError({
      statusCode: 403,
      statusMessage: 'å®‰å…¨æ£€æŸ¥å¤±è´¥',
      data: { timestamp: new Date().toISOString() }
    })
  }
})
```

#### 8.1.2 è·¯ç”±ä¸­é—´ä»¶

è·¯ç”±ä¸­é—´ä»¶æä¾›æ›´ç»†ç²’åº¦çš„æƒé™æ§åˆ¶ï¼Œå¯ä»¥é’ˆå¯¹ç‰¹å®šé¡µé¢æˆ–é¡µé¢ç»„å®ç°å®šåˆ¶åŒ–çš„æƒé™éªŒè¯ã€‚

**åŸºç¡€æƒé™éªŒè¯ä¸­é—´ä»¶**

```typescript
// middleware/admin.ts
export default defineNuxtRouteMiddleware((to) => {
  const user = useAuthUser()
  
  // è§’è‰²æƒé™æ£€æŸ¥
  if (!user.value || !user.value.roles?.includes('admin')) {
    throw createError({
      statusCode: 403,
      statusMessage: 'éœ€è¦ç®¡ç†å‘˜æƒé™æ‰èƒ½è®¿é—®æ­¤é¡µé¢'
    })
  }
})

// middleware/subscription.ts
export default defineNuxtRouteMiddleware((to) => {
  const user = useAuthUser()
  
  // è®¢é˜…çŠ¶æ€æ£€æŸ¥
  if (!user.value?.subscription?.active) {
    return navigateTo('/upgrade', {
      query: { return: to.fullPath }
    })
  }
})
```

**é«˜çº§æƒé™ç­–ç•¥å®ç°**

```typescript
// middleware/rbac.ts
interface Permission {
  resource: string
  action: string
  conditions?: Record<string, any>
}

interface Role {
  name: string
  permissions: Permission[]
  inheritance?: string[]
}

export default defineNuxtRouteMiddleware((to) => {
  const user = useAuthUser()
  const { checkPermission } = useRBAC()
  
  // ä»è·¯ç”±å…ƒä¿¡æ¯è·å–æ‰€éœ€æƒé™
  const requiredPermissions = to.meta.permissions as Permission[]
  
  if (!requiredPermissions || requiredPermissions.length === 0) {
    return // æ— æƒé™è¦æ±‚çš„è·¯ç”±
  }
  
  // RBAC æƒé™æ£€æŸ¥
  const hasPermission = requiredPermissions.every(permission => 
    checkPermission(user.value, permission, {
      context: {
        route: to.path,
        params: to.params,
        query: to.query
      }
    })
  )
  
  if (!hasPermission) {
    console.warn('RBAC æƒé™æ£€æŸ¥å¤±è´¥ï¼š', {
      user: user.value?.id,
      route: to.path,
      requiredPermissions,
      userRoles: user.value?.roles,
      timestamp: new Date().toISOString()
    })
    
    throw createError({
      statusCode: 403,
      statusMessage: 'æƒé™ä¸è¶³ï¼Œæ— æ³•è®¿é—®æ­¤èµ„æº',
      data: {
        requiredPermissions,
        userPermissions: user.value?.permissions || []
      }
    })
  }
})
```

**é¡µé¢çº§æƒé™å®šä¹‰**

```vue
<!-- pages/admin/users.vue -->
<template>
  <div>
    <h1>ç”¨æˆ·ç®¡ç†</h1>
    <!-- ç”¨æˆ·ç®¡ç†ç•Œé¢ -->
  </div>
</template>

<script setup lang="ts">
// å®šä¹‰é¡µé¢æƒé™è¦æ±‚
definePageMeta({
  middleware: ['auth', 'rbac'],
  permissions: [
    { resource: 'users', action: 'read' },
    { resource: 'users', action: 'list' }
  ],
  layout: 'admin'
})
</script>
```

#### 8.1.3 æœåŠ¡ç«¯ä¸­é—´ä»¶

æœåŠ¡ç«¯ä¸­é—´ä»¶è¿è¡Œåœ¨ Nitro å¼•æ“ä¸­ï¼Œè´Ÿè´£ API è·¯ç”±çš„å®‰å…¨ä¿æŠ¤å’Œè¯·æ±‚å¤„ç†ã€‚

**API è®¤è¯ä¸­é—´ä»¶**

```typescript
// server/middleware/auth.ts
export default defineEventHandler(async (event) => {
  // åªå¤„ç† API è·¯ç”±
  if (!event.node.req.url?.startsWith('/api/')) {
    return
  }
  
  // è·³è¿‡å…¬å¼€ API
  const publicEndpoints = [
    '/api/auth/login',
    '/api/auth/register',
    '/api/auth/refresh',
    '/api/health'
  ]
  
  if (publicEndpoints.some(endpoint => 
    event.node.req.url?.startsWith(endpoint)
  )) {
    return
  }
  
  try {
    // è·å–æˆæƒä»¤ç‰Œ
    const authorization = getHeader(event, 'authorization')
    if (!authorization?.startsWith('Bearer ')) {
      throw createError({
        statusCode: 401,
        statusMessage: 'ç¼ºå°‘æœ‰æ•ˆçš„æˆæƒä»¤ç‰Œ'
      })
    }
    
    const token = authorization.slice(7)
    
    // JWT ä»¤ç‰ŒéªŒè¯
    const { verifyJWT } = useJWT()
    const payload = await verifyJWT(token)
    
    // ä»¤ç‰Œé»‘åå•æ£€æŸ¥
    const { isTokenBlacklisted } = useTokenBlacklist()
    if (await isTokenBlacklisted(token)) {
      throw createError({
        statusCode: 401,
        statusMessage: 'ä»¤ç‰Œå·²è¢«åŠé”€'
      })
    }
    
    // ç”¨æˆ·çŠ¶æ€æ£€æŸ¥
    const user = await getUserById(payload.userId)
    if (!user || !user.active) {
      throw createError({
        statusCode: 401,
        statusMessage: 'ç”¨æˆ·è´¦æˆ·å·²è¢«ç¦ç”¨'
      })
    }
    
    // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
    event.context.user = user
    event.context.tokenPayload = payload
    
  } catch (error) {
    console.error('API è®¤è¯å¤±è´¥ï¼š', {
      url: event.node.req.url,
      method: event.node.req.method,
      ip: getClientIP(event),
      userAgent: getHeader(event, 'user-agent'),
      error: error.message,
      timestamp: new Date().toISOString()
    })
    
    throw createError({
      statusCode: 401,
      statusMessage: 'è®¤è¯å¤±è´¥'
    })
  }
})
```

## ç¬¬äºŒéƒ¨åˆ†ï¼šè®¤è¯ä¸æˆæƒä½“ç³»

### 8.2.1 JWT è®¤è¯å®ç°

JSON Web Token (JWT) æ˜¯ç°ä»£ Web åº”ç”¨ä¸­æœ€å¸¸ç”¨çš„è®¤è¯æœºåˆ¶ï¼Œå…·æœ‰æ— çŠ¶æ€ã€è·¨åŸŸå‹å¥½ã€æ€§èƒ½ä¼˜ç§€ç­‰ç‰¹ç‚¹ã€‚

**JWT å·¥å…·å‡½æ•°å®ç°**

```typescript
// composables/useJWT.ts
import * as jose from 'jose'

export const useJWT = () => {
  const runtimeConfig = useRuntimeConfig()
  
  // JWT å¯†é’¥ç®¡ç†
  const getSecret = () => {
    const secret = runtimeConfig.jwtSecret
    if (!secret) {
      throw new Error('JWT_SECRET ç¯å¢ƒå˜é‡æœªé…ç½®')
    }
    return new TextEncoder().encode(secret)
  }
  
  // ç”Ÿæˆ JWT ä»¤ç‰Œ
  const generateJWT = async (payload: any, options: {
    expiresIn?: string
    audience?: string
    issuer?: string
  } = {}) => {
    const secret = getSecret()
    
    const jwt = await new jose.SignJWT(payload)
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setIssuer(options.issuer || 'nuxt-app')
      .setAudience(options.audience || 'nuxt-app-users')
      .setExpirationTime(options.expiresIn || '1h')
      .sign(secret)
    
    return jwt
  }
  
  // éªŒè¯ JWT ä»¤ç‰Œ
  const verifyJWT = async (token: string) => {
    try {
      const secret = getSecret()
      const { payload } = await jose.jwtVerify(token, secret, {
        issuer: 'nuxt-app',
        audience: 'nuxt-app-users'
      })
      
      return payload
    } catch (error) {
      console.error('JWT éªŒè¯å¤±è´¥ï¼š', error.message)
      throw new Error('æ— æ•ˆçš„ä»¤ç‰Œ')
    }
  }
  
  // åˆ·æ–°ä»¤ç‰Œ
  const refreshToken = async (token: string) => {
    try {
      const payload = await verifyJWT(token)
      
      // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦æ¥è¿‘è¿‡æœŸï¼ˆå‰©ä½™æ—¶é—´å°‘äº 15 åˆ†é’Ÿï¼‰
      const exp = payload.exp as number
      const now = Math.floor(Date.now() / 1000)
      
      if (exp - now > 15 * 60) {
        return token // ä»¤ç‰Œä»ç„¶æœ‰æ•ˆ
      }
      
      // ç”Ÿæˆæ–°ä»¤ç‰Œ
      const newPayload = {
        userId: payload.userId,
        email: payload.email,
        roles: payload.roles
      }
      
      return await generateJWT(newPayload)
    } catch (error) {
      throw new Error('ä»¤ç‰Œåˆ·æ–°å¤±è´¥')
    }
  }
  
  // è§£ç ä»¤ç‰Œï¼ˆä¸éªŒè¯ç­¾åï¼‰
  const decodeJWT = (token: string) => {
    try {
      return jose.decodeJwt(token)
    } catch {
      return null
    }
  }
  
  return {
    generateJWT,
    verifyJWT,
    refreshToken,
    decodeJWT
  }
}
```

**è®¤è¯æœåŠ¡å®ç°**

```typescript
// server/api/auth/login.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { email, password, rememberMe } = body
  
  // è¾“å…¥éªŒè¯
  if (!email || !password) {
    throw createError({
      statusCode: 400,
      statusMessage: 'é‚®ç®±å’Œå¯†ç ä¸èƒ½ä¸ºç©º'
    })
  }
  
  try {
    // ç”¨æˆ·è®¤è¯
    const user = await authenticateUser(email, password)
    
    if (!user) {
      // è®°å½•ç™»å½•å¤±è´¥æ—¥å¿—
      await logAuthEvent({
        type: 'login_failed',
        email,
        ip: getClientIP(event),
        userAgent: getHeader(event, 'user-agent'),
        reason: 'invalid_credentials'
      })
      
      throw createError({
        statusCode: 401,
        statusMessage: 'é‚®ç®±æˆ–å¯†ç é”™è¯¯'
      })
    }
    
    // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
    if (!user.active) {
      throw createError({
        statusCode: 403,
        statusMessage: 'è´¦æˆ·å·²è¢«ç¦ç”¨'
      })
    }
    
    // ç”Ÿæˆä»¤ç‰Œ
    const { generateJWT } = useJWT()
    const tokenPayload = {
      userId: user.id,
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    }
    
    const accessToken = await generateJWT(tokenPayload, {
      expiresIn: rememberMe ? '30d' : '1h'
    })
    
    const refreshToken = await generateJWT(
      { userId: user.id, type: 'refresh' },
      { expiresIn: '30d' }
    )
    
    // æ›´æ–°ç”¨æˆ·ç™»å½•ä¿¡æ¯
    await updateUserLastLogin(user.id, {
      lastLoginAt: new Date(),
      lastLoginIp: getClientIP(event),
      lastLoginUserAgent: getHeader(event, 'user-agent')
    })
    
    // è®°å½•ç™»å½•æˆåŠŸæ—¥å¿—
    await logAuthEvent({
      type: 'login_success',
      userId: user.id,
      email: user.email,
      ip: getClientIP(event),
      userAgent: getHeader(event, 'user-agent')
    })
    
    // è®¾ç½®å®‰å…¨ Cookie
    setCookie(event, 'auth-token', accessToken, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: rememberMe ? 30 * 24 * 60 * 60 : 60 * 60, // 30å¤©æˆ–1å°æ—¶
      path: '/'
    })
    
    setCookie(event, 'refresh-token', refreshToken, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60, // 30å¤©
      path: '/api/auth'
    })
    
    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        roles: user.roles,
        avatar: user.avatar
      },
      accessToken,
      expiresIn: rememberMe ? 30 * 24 * 60 * 60 : 60 * 60
    }
    
  } catch (error) {
    console.error('ç™»å½•è¿‡ç¨‹å‡ºé”™ï¼š', error)
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      statusMessage: 'ç™»å½•æœåŠ¡æš‚æ—¶ä¸å¯ç”¨'
    })
  }
})
```

### 8.2.2 OAuth2 é›†æˆ

OAuth2 æ˜¯ä¸šç•Œæ ‡å‡†çš„æˆæƒæ¡†æ¶ï¼Œæ”¯æŒç¬¬ä¸‰æ–¹ç™»å½•å’Œ API è®¿é—®æˆæƒã€‚

**OAuth2 æä¾›å•†é…ç½®**

```typescript
// server/api/auth/oauth/[provider].get.ts
export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const query = getQuery(event)
  
  const oauthConfig = {
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      redirectUri: `${process.env.BASE_URL}/api/auth/oauth/google/callback`,
      scope: 'openid email profile',
      authUrl: 'https://accounts.google.com/o/oauth2/v2/auth'
    },
    github: {
      clientId: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET,
      redirectUri: `${process.env.BASE_URL}/api/auth/oauth/github/callback`,
      scope: 'user:email',
      authUrl: 'https://github.com/login/oauth/authorize'
    }
  }
  
  const config = oauthConfig[provider as keyof typeof oauthConfig]
  if (!config) {
    throw createError({
      statusCode: 400,
      statusMessage: 'ä¸æ”¯æŒçš„ OAuth æä¾›å•†'
    })
  }
  
  // ç”Ÿæˆ state å‚æ•°é˜²æ­¢ CSRF
  const state = generateRandomString(32)
  
  // å­˜å‚¨ state åˆ°ä¼šè¯ä¸­
  await setSessionData(event, 'oauth_state', state)
  
  // æ„å»ºæˆæƒ URL
  const authUrl = new URL(config.authUrl)
  authUrl.searchParams.set('client_id', config.clientId)
  authUrl.searchParams.set('redirect_uri', config.redirectUri)
  authUrl.searchParams.set('scope', config.scope)
  authUrl.searchParams.set('response_type', 'code')
  authUrl.searchParams.set('state', state)
  
  if (provider === 'google') {
    authUrl.searchParams.set('access_type', 'offline')
  }
  
  return sendRedirect(event, authUrl.toString())
})
```

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®‰å…¨æ€§å¢å¼º

### 8.3.1 CSRF é˜²æŠ¤

è·¨ç«™è¯·æ±‚ä¼ªé€ ï¼ˆCSRFï¼‰æ˜¯ä¸€ç§å¸¸è§çš„ Web å®‰å…¨å¨èƒï¼Œéœ€è¦é€šè¿‡å¤šç§æœºåˆ¶è¿›è¡Œé˜²æŠ¤ã€‚

**CSRF Token ç”Ÿæˆä¸éªŒè¯**

```typescript
// server/utils/csrf.ts
import { randomBytes, createHmac } from 'crypto'

export class CSRFProtection {
  private secret: string
  
  constructor() {
    this.secret = process.env.CSRF_SECRET || 'default-csrf-secret'
  }
  
  // ç”Ÿæˆ CSRF Token
  generateToken(sessionId: string): string {
    const timestamp = Date.now().toString()
    const randomValue = randomBytes(16).toString('hex')
    const payload = `${sessionId}:${timestamp}:${randomValue}`
    
    const signature = createHmac('sha256', this.secret)
      .update(payload)
      .digest('hex')
    
    return Buffer.from(`${payload}:${signature}`).toString('base64')
  }
  
  // éªŒè¯ CSRF Token
  verifyToken(token: string, sessionId: string): boolean {
    try {
      const decoded = Buffer.from(token, 'base64').toString('utf8')
      const [session, timestamp, random, signature] = decoded.split(':')
      
      // æ£€æŸ¥ä¼šè¯ ID
      if (session !== sessionId) {
        return false
      }
      
      // æ£€æŸ¥æ—¶é—´æˆ³ï¼ˆtoken æœ‰æ•ˆæœŸ 1 å°æ—¶ï¼‰
      const tokenTime = parseInt(timestamp)
      const now = Date.now()
      if (now - tokenTime > 60 * 60 * 1000) {
        return false
      }
      
      // éªŒè¯ç­¾å
      const payload = `${session}:${timestamp}:${random}`
      const expectedSignature = createHmac('sha256', this.secret)
        .update(payload)
        .digest('hex')
      
      return signature === expectedSignature
    } catch {
      return false
    }
  }
}

const csrfProtection = new CSRFProtection()
export { csrfProtection }
```

### 8.3.2 XSS é˜²æŠ¤

è·¨ç«™è„šæœ¬æ”»å‡»ï¼ˆXSSï¼‰æ˜¯æœ€å¸¸è§çš„ Web å®‰å…¨å¨èƒä¹‹ä¸€ï¼Œéœ€è¦é€šè¿‡è¾“å…¥éªŒè¯ã€è¾“å‡ºç¼–ç ã€CSP ç­‰å¤šå±‚é˜²æŠ¤ã€‚

**è¾“å…¥éªŒè¯ä¸æ¸…ç†**

```typescript
// server/utils/xss-protection.ts
import DOMPurify from 'isomorphic-dompurify'
import validator from 'validator'

export class XSSProtection {
  // HTML å†…å®¹æ¸…ç†
  static sanitizeHTML(input: string, options: {
    allowedTags?: string[]
    allowedAttributes?: Record<string, string[]>
    strict?: boolean
  } = {}): string {
    if (!input || typeof input !== 'string') {
      return ''
    }
    
    const defaultConfig = {
      ALLOWED_TAGS: options.allowedTags || [
        'p', 'br', 'strong', 'em', 'u', 'ul', 'ol', 'li', 'h1', 'h2', 'h3'
      ],
      ALLOWED_ATTR: options.allowedAttributes || {
        'a': ['href', 'title'],
        'img': ['src', 'alt', 'title'],
        '*': ['class']
      },
      FORBID_SCRIPT: true,
      FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input'],
      FORBID_ATTR: ['onclick', 'onload', 'onerror', 'onfocus']
    }
    
    if (options.strict) {
      defaultConfig.ALLOWED_TAGS = ['p', 'br', 'strong', 'em']
      defaultConfig.ALLOWED_ATTR = {}
    }
    
    return DOMPurify.sanitize(input, defaultConfig)
  }
  
  // æ–‡æœ¬å†…å®¹è½¬ä¹‰
  static escapeHTML(input: string): string {
    if (!input || typeof input !== 'string') {
      return ''
    }
    
    return validator.escape(input)
  }
  
  // æ£€æµ‹æ½œåœ¨çš„ XSS æ”»å‡»
  static detectXSSAttempt(input: string): boolean {
    if (!input || typeof input !== 'string') {
      return false
    }
    
    const xssPatterns = [
      /<script[\s\S]*?>/i,
      /javascript:/i,
      /on\w+\s*=/i,
      /<iframe[\s\S]*?>/i,
      /<object[\s\S]*?>/i,
      /<embed[\s\S]*?>/i,
      /expression\s*\(/i,
      /vbscript:/i,
      /@import/i,
      /binding\s*:/i
    ]
    
    return xssPatterns.some(pattern => pattern.test(input))
  }
  
  // æ‰¹é‡å¤„ç†å¯¹è±¡å±æ€§
  static sanitizeObject<T extends Record<string, any>>(
    obj: T,
    rules: Record<keyof T, 'html' | 'text' | 'url' | 'skip'>
  ): T {
    const sanitized = { ...obj }
    
    for (const [key, rule] of Object.entries(rules)) {
      const value = sanitized[key]
      
      if (value && typeof value === 'string') {
        switch (rule) {
          case 'html':
            sanitized[key] = this.sanitizeHTML(value)
            break
          case 'text':
            sanitized[key] = this.escapeHTML(value)
            break
          case 'url':
            sanitized[key] = this.sanitizeURL(value)
            break
          case 'skip':
            // è·³è¿‡å¤„ç†
            break
        }
      }
    }
    
    return sanitized
  }
}
```

### 8.3.3 è¯·æ±‚é™åˆ¶ä¸é˜²æŠ¤

å®ç°æ™ºèƒ½çš„è¯·æ±‚é™åˆ¶å’Œæ”»å‡»é˜²æŠ¤æœºåˆ¶ï¼Œä¿æŠ¤åº”ç”¨å…å—å„ç§ç½‘ç»œæ”»å‡»ã€‚

**é«˜çº§è¯·æ±‚é™åˆ¶ç³»ç»Ÿ**

```typescript
// server/utils/rate-limiter.ts
import { LRUCache } from 'lru-cache'

interface RateLimitRule {
  windowMs: number    // æ—¶é—´çª—å£ï¼ˆæ¯«ç§’ï¼‰
  maxRequests: number // æœ€å¤§è¯·æ±‚æ•°
  message?: string    // è¶…é™æ¶ˆæ¯
  skipSuccessfulRequests?: boolean // æ˜¯å¦è·³è¿‡æˆåŠŸè¯·æ±‚
  keyGenerator?: (event: any) => string // è‡ªå®šä¹‰é”®ç”Ÿæˆå™¨
}

export class AdvancedRateLimiter {
  private cache: LRUCache<string, number[]>
  private rules: Map<string, RateLimitRule>
  
  constructor() {
    this.cache = new LRUCache({
      max: 10000,
      ttl: 1000 * 60 * 60 // 1å°æ—¶
    })
    this.rules = new Map()
  }
  
  // æ·»åŠ é™åˆ¶è§„åˆ™
  addRule(pattern: string, rule: RateLimitRule) {
    this.rules.set(pattern, rule)
  }
  
  // æ£€æŸ¥è¯·æ±‚æ˜¯å¦è¢«é™åˆ¶
  async checkLimit(event: any): Promise<{
    allowed: boolean
    remaining: number
    resetTime: number
    totalRequests: number
  }> {
    const url = getRequestURL(event)
    const rule = this.findMatchingRule(url.pathname)
    
    if (!rule) {
      return {
        allowed: true,
        remaining: -1,
        resetTime: -1,
        totalRequests: 0
      }
    }
    
    const key = rule.keyGenerator ? 
      rule.keyGenerator(event) : 
      this.generateDefaultKey(event)
    
    const now = Date.now()
    const windowStart = now - rule.windowMs
    
    // è·å–æ—¶é—´çª—å£å†…çš„è¯·æ±‚è®°å½•
    let requests = this.cache.get(key) || []
    
    // æ¸…ç†è¿‡æœŸè®°å½•
    requests = requests.filter(timestamp => timestamp > windowStart)
    
    const currentRequests = requests.length
    
    if (currentRequests >= rule.maxRequests) {
      // è®¡ç®—é‡ç½®æ—¶é—´
      const oldestRequest = Math.min(...requests)
      const resetTime = oldestRequest + rule.windowMs
      
      return {
        allowed: false,
        remaining: 0,
        resetTime,
        totalRequests: currentRequests
      }
    }
    
    // è®°å½•å½“å‰è¯·æ±‚
    requests.push(now)
    this.cache.set(key, requests)
    
    return {
      allowed: true,
      remaining: rule.maxRequests - requests.length,
      resetTime: now + rule.windowMs,
      totalRequests: requests.length
    }
  }
  
  private findMatchingRule(pathname: string): RateLimitRule | null {
    for (const [pattern, rule] of this.rules) {
      if (this.matchPattern(pattern, pathname)) {
        return rule
      }
    }
    return null
  }
  
  private matchPattern(pattern: string, pathname: string): boolean {
    // æ”¯æŒé€šé…ç¬¦åŒ¹é…
    const regex = new RegExp(
      pattern.replace(/\*/g, '.*').replace(/\?/g, '.')
    )
    return regex.test(pathname)
  }
  
  private generateDefaultKey(event: any): string {
    const ip = getClientIP(event)
    const url = getRequestURL(event)
    const method = getMethod(event)
    
    return `${ip}:${method}:${url.pathname}`
  }
}

// å…¨å±€é™åˆ¶å™¨å®ä¾‹
const rateLimiter = new AdvancedRateLimiter()

// é…ç½®é™åˆ¶è§„åˆ™
rateLimiter.addRule('/api/auth/login', {
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  maxRequests: 5, // æœ€å¤š5æ¬¡ç™»å½•å°è¯•
  message: 'ç™»å½•å°è¯•è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
})

rateLimiter.addRule('/api/*', {
  windowMs: 60 * 1000, // 1åˆ†é’Ÿ
  maxRequests: 100, // é€šç”¨ API é™åˆ¶
  keyGenerator: (event) => {
    // è®¤è¯ç”¨æˆ·ä½¿ç”¨ç”¨æˆ·IDï¼Œæœªè®¤è¯ä½¿ç”¨IP
    const user = event.context.user
    const ip = getClientIP(event)
    return user ? `user:${user.id}` : `ip:${ip}`
  }
})

export { rateLimiter }
```

## æ€»ç»“ä¸æœ€ä½³å®è·µ

### å®‰å…¨å¼€å‘ç”Ÿå‘½å‘¨æœŸ

1. **è®¾è®¡é˜¶æ®µ**
   - å¨èƒå»ºæ¨¡å’Œå®‰å…¨éœ€æ±‚åˆ†æ
   - æœ€å°æƒé™åŸåˆ™è®¾è®¡
   - çºµæ·±é˜²å¾¡æ¶æ„è§„åˆ’

2. **å¼€å‘é˜¶æ®µ**
   - å®‰å…¨ç¼–ç è§„èŒƒéµå¾ª
   - è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç 
   - å®‰å…¨ç»„ä»¶å¤ç”¨

3. **æµ‹è¯•é˜¶æ®µ**
   - å®‰å…¨æµ‹è¯•ç”¨ä¾‹è®¾è®¡
   - æ¸—é€æµ‹è¯•å’Œæ¼æ´æ‰«æ
   - å®‰å…¨ä»£ç å®¡æŸ¥

4. **éƒ¨ç½²é˜¶æ®µ**
   - å®‰å…¨é…ç½®ç®¡ç†
   - ç›‘æ§å’Œå‘Šè­¦è®¾ç½®
   - åº”æ€¥å“åº”å‡†å¤‡

### ç›‘æ§ä¸å®¡è®¡

```typescript
// composables/useSecurityMonitoring.ts
export const useSecurityMonitoring = () => {
  // å®‰å…¨äº‹ä»¶ç›‘æ§
  const monitorSecurityEvent = async (event: {
    type: string
    severity: 'low' | 'medium' | 'high' | 'critical'
    details: any
    user?: any
  }) => {
    // å®æ—¶å‘Šè­¦
    if (event.severity === 'critical') {
      await sendImmediateAlert(event)
    }
    
    // è®°å½•åˆ°å®‰å…¨æ—¥å¿—
    await logSecurityEvent(event)
    
    // æ›´æ–°å®‰å…¨ä»ªè¡¨æ¿
    await updateSecurityDashboard(event)
  }
  
  // å®¡è®¡æ—¥å¿—è®°å½•
  const auditLog = async (action: {
    user: string
    action: string
    resource: string
    result: 'success' | 'failure'
    details?: any
  }) => {
    await $fetch('/api/audit/log', {
      method: 'POST',
      body: {
        ...action,
        timestamp: new Date().toISOString(),
        ip: await getClientIP(),
        userAgent: navigator.userAgent
      }
    })
  }
  
  return {
    monitorSecurityEvent,
    auditLog
  }
}
```

é€šè¿‡æœ¬æŒ‡å—çš„å­¦ä¹ ï¼Œå¼€å‘è€…å¯ä»¥æŒæ¡ Nuxt æ¡†æ¶ä¸­å®Œæ•´çš„ä¸­é—´ä»¶å’Œæƒé™æ§åˆ¶ä½“ç³»ï¼Œæ„å»ºå®‰å…¨ã€å¯é çš„ä¼ä¸šçº§åº”ç”¨ã€‚å®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦åœ¨æ•´ä¸ªå¼€å‘ç”Ÿå‘½å‘¨æœŸä¸­è´¯å½»å®‰å…¨æ„è¯†ï¼ŒæŒç»­ç›‘æ§å’Œæ”¹è¿›å®‰å…¨æªæ–½ã€‚

::alert{icon="lucide:shield-check" color="green"}
**å®‰å…¨æé†’**: å®‰å…¨é˜²æŠ¤æ˜¯ä¸€ä¸ªåŠ¨æ€è¿‡ç¨‹ï¼Œéœ€è¦æ ¹æ®æœ€æ–°çš„å¨èƒæƒ…æŠ¥å’Œæ”»å‡»æ‰‹æ®µæŒç»­æ›´æ–°é˜²æŠ¤ç­–ç•¥ã€‚å»ºè®®å®šæœŸè¿›è¡Œå®‰å…¨è¯„ä¼°å’Œæ¸—é€æµ‹è¯•ï¼Œç¡®ä¿åº”ç”¨å®‰å…¨é˜²æŠ¤çš„æœ‰æ•ˆæ€§ã€‚
:: 