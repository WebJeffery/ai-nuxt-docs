---
title: TypeScript é›†æˆ
description: æŒæ¡TypeScriptåœ¨Nuxt3ä¸­çš„æ·±åº¦é›†æˆï¼Œæå‡ä»£ç è´¨é‡å’Œå¼€å‘ä½“éªŒï¼Œæ„å»ºç±»å‹å®‰å…¨çš„ä¼ä¸šçº§åº”ç”¨
icon: 'lucide:type'
---

## ğŸ¯ TypeScript æ¦‚è§ˆ

**TypeScript** æ˜¯JavaScriptçš„è¶…é›†ï¼Œä¸ºåŠ¨æ€è¯­è¨€JavaScriptæ·»åŠ äº†é™æ€ç±»å‹æ£€æŸ¥ã€‚åœ¨Nuxt3ä¸­ï¼ŒTypeScriptäº«æœ‰ä¸€æµçš„æ”¯æŒï¼Œæä¾›äº†å®Œæ•´çš„ç±»å‹æ¨å¯¼ã€æ™ºèƒ½æç¤ºå’Œé”™è¯¯æ£€æŸ¥ï¼Œå¤§å¤§æå‡äº†ä¼ä¸šçº§åº”ç”¨çš„å¼€å‘ä½“éªŒå’Œä»£ç è´¨é‡ã€‚

::alert{icon="lucide:info" color="blue"}
**ä¸ºä»€ä¹ˆåœ¨Nuxt3ä¸­ä½¿ç”¨TypeScriptï¼Ÿ**
- ğŸ” **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶å‘ç°æ½œåœ¨é”™è¯¯ï¼Œå‡å°‘è¿è¡Œæ—¶bug
- ğŸ’¡ **æ™ºèƒ½æç¤º**: IDEæä¾›æ›´å¥½çš„ä»£ç è¡¥å…¨å’Œå¯¼èˆª
- ğŸ“š **æ›´å¥½çš„æ–‡æ¡£**: ç±»å‹å³æ–‡æ¡£ï¼Œæå‡ä»£ç å¯è¯»æ€§
- ğŸ”§ **é‡æ„æ”¯æŒ**: å®‰å…¨çš„ä»£ç é‡æ„å’Œä¿®æ”¹
- ğŸ¢ **å›¢é˜Ÿåä½œ**: ç»Ÿä¸€çš„æ¥å£è§„èŒƒï¼Œé™ä½æ²Ÿé€šæˆæœ¬
::

## ğŸš€ TypeScript é…ç½®

### åŸºç¡€é…ç½®

Nuxt3é»˜è®¤æ”¯æŒTypeScriptï¼Œåªéœ€åˆ›å»ºæˆ–ä¿®æ”¹é…ç½®æ–‡ä»¶ï¼š

::code-group
```json [tsconfig.json]
{
  "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    // åŸºç¡€é…ç½®
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    // æ¨¡å—è§£æ
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,

    // è·¯å¾„æ˜ å°„
    "baseUrl": ".",
    "paths": {
      "~/*": ["./*"],
      "@/*": ["./*"],
      "~~/*": ["./*"],
      "@@/*": ["./*"]
    },

    // ç±»å‹æ£€æŸ¥
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    // è¾“å‡ºé…ç½®
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/*.vue"
  ],
  "exclude": [
    "node_modules",
    ".nuxt",
    ".output",
    "dist"
  ]
}
```

```typescript [nuxt.config.ts]
export default defineNuxtConfig({
  // TypeScripté…ç½®
  typescript: {
    strict: true,
    typeCheck: true
  },

  // æ„å»ºæ—¶ç±»å‹æ£€æŸ¥
  hooks: {
    'build:before': () => {
      console.log('å¼€å§‹TypeScriptç±»å‹æ£€æŸ¥...');
    }
  },

  // Viteé…ç½®
  vite: {
    vue: {
      script: {
        defineModel: true,
        propsDestructure: true
      }
    }
  }
});
```
::

### é«˜çº§é…ç½®

```json [tsconfig.json - ä¼ä¸šçº§é…ç½®]
{
  "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    // ä¸¥æ ¼æ¨¡å¼
    "strict": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "noImplicitReturns": true,
    "noPropertyAccessFromIndexSignature": true,
    "noUncheckedIndexedAccess": true,
    "noUncheckedSideEffectImports": true,

    // å®éªŒæ€§åŠŸèƒ½
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // è·¯å¾„æ˜ å°„ (ä¼ä¸šçº§)
    "paths": {
      "~/*": ["./*"],
      "@/*": ["./*"],
      "@/components/*": ["./components/*"],
      "@/composables/*": ["./composables/*"],
      "@/utils/*": ["./utils/*"],
      "@/types/*": ["./types/*"],
      "@/stores/*": ["./stores/*"],
      "@/server/*": ["./server/*"],
      "@/assets/*": ["./assets/*"]
    },

    // æ’ä»¶æ”¯æŒ
    "plugins": [
      {
        "name": "@vue/typescript-plugin"
      }
    ]
  },

  // é¡¹ç›®å¼•ç”¨ (Monorepoæ”¯æŒ)
  "references": [
    { "path": "./packages/shared" },
    { "path": "./packages/ui" }
  ]
}
```

## ğŸ§© æ ¸å¿ƒç±»å‹å®šä¹‰

### åŸºç¡€ç±»å‹

::code-group
```typescript [types/basic.ts]
// ç”¨æˆ·ç›¸å…³ç±»å‹
export interface User {
  readonly id: number;
  name: string;
  email: string;
  avatar?: string;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

export type UserRole = 'admin' | 'user' | 'guest';

export type CreateUserPayload = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

export type UpdateUserPayload = Partial<Pick<User, 'name' | 'email' | 'avatar'>>;

// APIå“åº”ç±»å‹
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message?: string;
  errors?: Record<string, string[]>;
}

export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    perPage: number;
    totalPages: number;
  };
}

// çŠ¶æ€ç±»å‹
export interface LoadingState {
  isLoading: boolean;
  error: string | null;
}

export type AsyncState<T> = LoadingState & {
  data: T | null;
};
```

```typescript [types/ai.ts]
// AIç›¸å…³ç±»å‹
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  metadata?: MessageMetadata;
}

export interface MessageMetadata {
  model?: string;
  temperature?: number;
  tokens?: number;
  cost?: number;
}

export interface AIGenerateOptions {
  model: 'gpt-4' | 'gpt-3.5-turbo' | 'claude-3-haiku' | 'claude-3-sonnet';
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
  stream?: boolean;
}

export interface AIProvider {
  name: string;
  models: string[];
  generateText: (prompt: string, options?: AIGenerateOptions) => Promise<string>;
  generateStream: (prompt: string, options?: AIGenerateOptions) => AsyncIterable<string>;
}

// æ³›å‹çº¦æŸ
export interface WithTimestamps {
  createdAt: Date;
  updatedAt: Date;
}

export type Entity<T = {}> = T & WithTimestamps & {
  id: number;
};
```
::

### é«˜çº§ç±»å‹æ¨¡å¼

::code-group
```typescript [types/advanced.ts]
// æ¡ä»¶ç±»å‹
export type NonNullable<T> = T extends null | undefined ? never : T;

export type FunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? K : never
}[keyof T];

export type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;

// æ¨¡æ¿å­—é¢é‡ç±»å‹
export type ApiEndpoint<T extends string> = `/api/${T}`;
export type EventName<T extends string> = `on${Capitalize<T>}`;

// ç¤ºä¾‹ä½¿ç”¨
type UserEndpoints = ApiEndpoint<'users' | 'auth' | 'profile'>;
// ç»“æœ: "/api/users" | "/api/auth" | "/api/profile"

type Events = EventName<'click' | 'change' | 'submit'>;
// ç»“æœ: "onClick" | "onChange" | "onSubmit"

// æ˜ å°„ç±»å‹
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export type RequiredBy<T, K extends keyof T> = T & Required<Pick<T, K>>;

// é€’å½’ç±»å‹
export interface TreeNode<T = any> {
  id: string;
  data: T;
  children?: TreeNode<T>[];
  parent?: TreeNode<T>;
}

// å·¥å…·ç±»å‹
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
};

export type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
};

// å“ç‰Œç±»å‹ (Branded Types)
declare const __brand: unique symbol;
type Brand<T, B> = T & { [__brand]: B };

export type UserId = Brand<number, 'UserId'>;
export type Email = Brand<string, 'Email'>;
export type JWT = Brand<string, 'JWT'>;

// ç±»å‹ä¿æŠ¤
export function isUserId(value: number): value is UserId {
  return typeof value === 'number' && value > 0;
}

export function isEmail(value: string): value is Email {
  return /^[^\s@]+@[^\s@][^\s.@]*\.[^\s@]+$/.test(value);
}
```

```typescript [types/api.ts]
// APIç±»å‹ç³»ç»Ÿ
export interface ApiClient {
  get: <T>(url: string, config?: RequestConfig) => Promise<T>;
  post: <T>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
  put: <T>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
  delete: <T>(url: string, config?: RequestConfig) => Promise<T>;
}

export interface RequestConfig {
  headers?: Record<string, string>;
  timeout?: number;
  retries?: number;
}

// RESTful APIç±»å‹
export interface RestfulApi<T, CreateT = Omit<T, 'id'>, UpdateT = Partial<T>> {
  list: (params?: ListParams) => Promise<PaginatedResponse<T>>;
  get: (id: number) => Promise<T>;
  create: (data: CreateT) => Promise<T>;
  update: (id: number, data: UpdateT) => Promise<T>;
  delete: (id: number) => Promise<void>;
}

export interface ListParams {
  page?: number;
  limit?: number;
  sort?: string;
  order?: 'asc' | 'desc';
  search?: string;
  filters?: Record<string, any>;
}

// å…·ä½“APIå®ç°ç±»å‹
export type UserApi = RestfulApi<User, CreateUserPayload, UpdateUserPayload>;

export interface AuthApi {
  login: (credentials: LoginCredentials) => Promise<AuthResponse>;
  register: (userData: RegisterPayload) => Promise<User>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<AuthResponse>;
  me: () => Promise<User>;
}

export interface AuthResponse {
  user: User;
  token: string;
  refreshToken: string;
  expiresIn: number;
}
```
::

## ğŸ¨ Vueç»„ä»¶ç±»å‹åŒ–

### ç»„ä»¶Propså’ŒEmits

::code-group
```vue [components/UserCard.vue]
<template>
  <div class="user-card">
    <img :src="user.avatar" :alt="user.name">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <UiButton
      :variant="buttonVariant"
      @click="handleEdit"
    >
      ç¼–è¾‘
    </UiButton>
  </div>
</template>

<script setup lang="ts">
// Propsç±»å‹å®šä¹‰
interface Props {
  user: User;
  editable?: boolean;
  size?: 'small' | 'medium' | 'large';
  variant?: 'default' | 'compact';
}

// ä½¿ç”¨æ³›å‹é»˜è®¤å€¼
const props = withDefaults(defineProps<Props>(), {
  editable: true,
  size: 'medium',
  variant: 'default'
});

const emit = defineEmits<Emits>();

// Emitsç±»å‹å®šä¹‰
interface Emits {
  edit: [user: User];
  delete: [userId: number];
  statusChange: [userId: number, status: UserStatus];
}

// è®¡ç®—å±æ€§
const buttonVariant = computed(() => {
  return props.size === 'small' ? 'ghost' : 'default';
});

// æ–¹æ³•
function handleEdit() {
  emit('edit', props.user);
}

// ç±»å‹åŒ–çš„ref
const cardElement = ref<HTMLDivElement>();

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  console.log('UserCard mounted for user:', props.user.name);
});
</script>
```

```vue [components/DataTable.vue]
<template>
  <div class="data-table">
    <table>
      <thead>
        <tr>
          <th
            v-for="column in columns"
            :key="column.key"
            @click="handleSort(column)"
          >
            {{ column.label }}
            <SortIcon
              v-if="column.sortable"
              :direction="getSortDirection(column.key)"
            />
          </th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="item in items" :key="getItemKey(item)">
          <td v-for="column in columns" :key="column.key">
            <slot
              :name="column.key"
              :item="item"
              :value="getColumnValue(item, column.key)"
            >
              {{ getColumnValue(item, column.key) }}
            </slot>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script setup lang="ts" generic="T extends Record<string, any>">
// æ³›å‹ç»„ä»¶ç±»å‹å®šä¹‰
interface Column<K extends keyof T = keyof T> {
  key: K;
  label: string;
  sortable?: boolean;
  width?: string;
  align?: 'left' | 'center' | 'right';
}

interface Props<T> {
  items: T[];
  columns: Column<keyof T>[];
  sortBy?: keyof T;
  sortOrder?: 'asc' | 'desc';
  keyField?: keyof T;
}

interface Emits<T> {
  sort: [column: keyof T, order: 'asc' | 'desc'];
  rowClick: [item: T];
  select: [selectedItems: T[]];
}

const props = withDefaults(defineProps<Props<T>>(), {
  keyField: 'id' as keyof T,
  sortOrder: 'asc'
});

const emit = defineEmits<Emits<T>>();

// å·¥å…·å‡½æ•°
function getItemKey(item: T): string | number {
  return item[props.keyField] as string | number;
}

function getColumnValue(item: T, key: keyof T): any {
  return item[key];
}

function getSortDirection(key: keyof T): 'asc' | 'desc' | null {
  return props.sortBy === key ? props.sortOrder : null;
}

function handleSort(column: Column<keyof T>) {
  if (!column.sortable)
    return;

  const newOrder = props.sortBy === column.key && props.sortOrder === 'asc'
    ? 'desc'
    : 'asc';

  emit('sort', column.key, newOrder);
}
</script>
```
::

### ç»„åˆå¼å‡½æ•°ç±»å‹åŒ–

::code-group
```typescript [composables/useApi.ts]
// æ³›å‹APIç»„åˆå¼å‡½æ•°
export function useApi<T = any>() {
  const { $fetch } = useNuxtApp();

  // çŠ¶æ€
  const data = ref<T | null>(null);
  const loading = ref(false);
  const error = ref<ApiError | null>(null);

  // è¯·æ±‚æ–¹æ³•
  const request = async <R = T>(
    url: string,
    options: FetchOptions = {}
  ): Promise<R> => {
    loading.value = true;
    error.value = null;

    try {
      const response = await $fetch<R>(url, options);
      data.value = response as unknown as T;
      return response;
    } catch (err) {
      const apiError = err as ApiError;
      error.value = apiError;
      throw apiError;
    } finally {
      loading.value = false;
    }
  };

  // CRUDæ“ä½œ
  const get = <R = T>(url: string, query?: Record<string, any>): Promise<R> => {
    return request<R>(url, { method: 'GET', query });
  };

  const post = <R = T>(url: string, body?: any): Promise<R> => {
    return request<R>(url, { method: 'POST', body });
  };

  const put = <R = T>(url: string, body?: any): Promise<R> => {
    return request<R>(url, { method: 'PUT', body });
  };

  const del = <R = void>(url: string): Promise<R> => {
    return request<R>(url, { method: 'DELETE' });
  };

  return {
    data: readonly(data),
    loading: readonly(loading),
    error: readonly(error),
    request,
    get,
    post,
    put,
    delete: del
  };
}

// ç‰¹å®šèµ„æºçš„API
export function useUserApi() {
  const api = useApi<User>();

  const users = ref<User[]>([]);
  const currentUser = ref<User | null>(null);

  const fetchUsers = async (params?: ListParams): Promise<PaginatedResponse<User>> => {
    const response = await api.get<PaginatedResponse<User>>('/api/users', params);
    users.value = response.data;
    return response;
  };

  const fetchUser = async (id: UserId): Promise<User> => {
    const user = await api.get<User>(`/api/users/${id}`);
    currentUser.value = user;
    return user;
  };

  const createUser = async (userData: CreateUserPayload): Promise<User> => {
    const newUser = await api.post<User>('/api/users', userData);
    users.value.push(newUser);
    return newUser;
  };

  const updateUser = async (id: UserId, userData: UpdateUserPayload): Promise<User> => {
    const updatedUser = await api.put<User>(`/api/users/${id}`, userData);

    // æ›´æ–°æœ¬åœ°çŠ¶æ€
    const index = users.value.findIndex(u => u.id === id);
    if (index !== -1) {
      users.value[index] = updatedUser;
    }

    if (currentUser.value?.id === id) {
      currentUser.value = updatedUser;
    }

    return updatedUser;
  };

  return {
    ...api,
    users: readonly(users),
    currentUser: readonly(currentUser),
    fetchUsers,
    fetchUser,
    createUser,
    updateUser
  };
}
```

```typescript [composables/useForm.ts]
// ç±»å‹åŒ–è¡¨å•ç»„åˆå¼å‡½æ•°
interface FormValidationRule<T = any> {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  email?: boolean;
  custom?: (value: T) => string | null;
}

type FormRules<T> = {
  [K in keyof T]?: FormValidationRule<T[K]>
};

type FormErrors<T> = {
  [K in keyof T]?: string
};

export function useForm<T extends Record<string, any>>(
  initialValues: T,
  rules?: FormRules<T>
) {
  // è¡¨å•æ•°æ®
  const form = reactive<T>({ ...initialValues });
  const errors = reactive<FormErrors<T>>({} as FormErrors<T>);
  const touched = reactive<Record<keyof T, boolean>>({} as Record<keyof T, boolean>);

  // éªŒè¯å•ä¸ªå­—æ®µ
  const validateField = (key: keyof T): boolean => {
    const value = form[key];
    const rule = rules?.[key];

    if (!rule) {
      errors[key] = undefined;
      return true;
    }

    // å¿…å¡«éªŒè¯
    if (rule.required && (!value || (typeof value === 'string' && !value.trim()))) {
      errors[key] = 'æ­¤å­—æ®µä¸ºå¿…å¡«é¡¹';
      return false;
    }

    // é•¿åº¦éªŒè¯
    if (typeof value === 'string') {
      if (rule.minLength && value.length < rule.minLength) {
        errors[key] = `æœ€å°‘éœ€è¦ ${rule.minLength} ä¸ªå­—ç¬¦`;
        return false;
      }

      if (rule.maxLength && value.length > rule.maxLength) {
        errors[key] = `æœ€å¤šå…è®¸ ${rule.maxLength} ä¸ªå­—ç¬¦`;
        return false;
      }
    }

    // é‚®ç®±éªŒè¯
    if (rule.email && typeof value === 'string') {
      const emailRegex = /^[^\s@]+@[^\s@][^\s.@]*\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        errors[key] = 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€';
        return false;
      }
    }

    // æ­£åˆ™éªŒè¯
    if (rule.pattern && typeof value === 'string') {
      if (!rule.pattern.test(value)) {
        errors[key] = 'æ ¼å¼ä¸æ­£ç¡®';
        return false;
      }
    }

    // è‡ªå®šä¹‰éªŒè¯
    if (rule.custom) {
      const customError = rule.custom(value);
      if (customError) {
        errors[key] = customError;
        return false;
      }
    }

    errors[key] = undefined;
    return true;
  };

  // éªŒè¯æ‰€æœ‰å­—æ®µ
  const validate = (): boolean => {
    let isValid = true;

    for (const key in form) {
      const fieldValid = validateField(key);
      if (!fieldValid) {
        isValid = false;
      }
    }

    return isValid;
  };

  // è®¡ç®—å±æ€§
  const isValid = computed(() => {
    return Object.keys(errors).every(key => !errors[key as keyof T]);
  });

  const isDirty = computed(() => {
    return Object.keys(form).some(key =>
      JSON.stringify(form[key as keyof T]) !== JSON.stringify(initialValues[key as keyof T])
    );
  });

  // é‡ç½®è¡¨å•
  const reset = () => {
    Object.assign(form, { ...initialValues });
    Object.keys(errors).forEach((key) => {
      errors[key as keyof T] = undefined;
    });
    Object.keys(touched).forEach((key) => {
      touched[key as keyof T] = false;
    });
  };

  // è®¾ç½®å­—æ®µå€¼
  const setFieldValue = <K extends keyof T>(key: K, value: T[K]) => {
    form[key] = value;
    touched[key] = true;
    validateField(key);
  };

  // è®¾ç½®å­—æ®µé”™è¯¯
  const setFieldError = <K extends keyof T>(key: K, error: string) => {
    errors[key] = error;
  };

  return {
    form,
    errors: readonly(errors),
    touched: readonly(touched),
    isValid,
    isDirty,
    validateField,
    validate,
    reset,
    setFieldValue,
    setFieldError
  };
}
```
::

## ğŸ”§ æœåŠ¡å™¨ç«¯ç±»å‹åŒ–

### APIè·¯ç”±ç±»å‹åŒ–

::code-group
```typescript [server/api/users/[id].get.ts]
import type { ApiResponse, User } from '~/types';

export default defineEventHandler(async (event): Promise<ApiResponse<User>> => {
  // è·å–è·¯ç”±å‚æ•°å¹¶ç±»å‹åŒ–
  const id = getRouterParam(event, 'id');

  if (!id || isNaN(Number(id))) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid user ID'
    });
  }

  const userId = Number(id) as UserId;

  try {
    // ä»æ•°æ®åº“è·å–ç”¨æˆ·
    const user = await getUserById(userId);

    if (!user) {
      throw createError({
        statusCode: 404,
        statusMessage: 'User not found'
      });
    }

    return {
      success: true,
      data: user
    };
  } catch (error) {
    console.error('Error fetching user:', error);

    throw createError({
      statusCode: 500,
      statusMessage: 'Internal server error'
    });
  }
});

// è¾…åŠ©å‡½æ•°
async function getUserById(id: UserId): Promise<User | null> {
  // æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
  // è¿”å›ç±»å‹åŒ–çš„ç”¨æˆ·å¯¹è±¡
  return null; // ç¤ºä¾‹
}
```

```typescript [server/api/ai/chat.post.ts]
import type { AIGenerateOptions, ApiResponse, ChatMessage } from '~/types';
import { OpenAI } from 'openai';

interface ChatRequest {
  message: string;
  conversation: ChatMessage[];
  options?: AIGenerateOptions;
}

interface ChatResponse {
  response: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export default defineEventHandler(async (event): Promise<ApiResponse<ChatResponse>> => {
  // éªŒè¯è¯·æ±‚ä½“
  const body = await readBody<ChatRequest>(event);

  if (!body.message?.trim()) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Message is required'
    });
  }

  // è·å–é…ç½®
  const config = useRuntimeConfig();
  const openai = new OpenAI({
    apiKey: config.openaiApiKey
  });

  try {
    // æ„å»ºæ¶ˆæ¯å†å²
    const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
      ...body.conversation.map(msg => ({
        role: msg.role,
        content: msg.content
      })),
      {
        role: 'user' as const,
        content: body.message
      }
    ];

    // è°ƒç”¨OpenAI API
    const completion = await openai.chat.completions.create({
      model: body.options?.model || 'gpt-3.5-turbo',
      messages,
      temperature: body.options?.temperature || 0.7,
      max_tokens: body.options?.maxTokens || 1000
    });

    const response = completion.choices[0]?.message?.content;

    if (!response) {
      throw new Error('No response from AI');
    }

    return {
      success: true,
      data: {
        response,
        usage: {
          promptTokens: completion.usage?.prompt_tokens || 0,
          completionTokens: completion.usage?.completion_tokens || 0,
          totalTokens: completion.usage?.total_tokens || 0
        }
      }
    };
  } catch (error) {
    console.error('AI API error:', error);

    throw createError({
      statusCode: 500,
      statusMessage: 'AI service error'
    });
  }
});
```
::

### ä¸­é—´ä»¶ç±»å‹åŒ–

```typescript [server/middleware/auth.ts]
import type { User } from '~/types';
import jwt from 'jsonwebtoken';

// æ‰©å±•H3äº‹ä»¶ä¸Šä¸‹æ–‡
declare module 'h3' {
  interface H3EventContext {
    user?: User;
    token?: string;
  }
}

export default defineEventHandler(async (event) => {
  // åªå¯¹APIè·¯ç”±è¿›è¡Œè®¤è¯æ£€æŸ¥
  if (!event.node.req.url?.startsWith('/api/')) {
    return;
  }

  // è·³è¿‡å…¬å¼€API
  const publicRoutes = ['/api/auth/login', '/api/auth/register'];
  if (publicRoutes.includes(event.node.req.url)) {
    return;
  }

  // è·å–token
  const authHeader = getHeader(event, 'authorization');
  const token = authHeader?.replace('Bearer ', '') || getCookie(event, 'auth-token');

  if (!token) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    });
  }

  try {
    // éªŒè¯JWT
    const config = useRuntimeConfig();
    const payload = jwt.verify(token, config.jwtSecret) as { userId: number };

    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await getUserById(payload.userId as UserId);

    if (!user) {
      throw new Error('User not found');
    }

    // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
    event.context.user = user;
    event.context.token = token;
  } catch (error) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid token'
    });
  }
});
```

## ğŸ¯ æœ€ä½³å®è·µ

::alert{icon="lucide:lightbulb" color="blue"}
### ğŸŒŸ TypeScriptå¼€å‘å»ºè®®

1. **ä¸¥æ ¼æ¨¡å¼**: å¯ç”¨æ‰€æœ‰ä¸¥æ ¼ç±»å‹æ£€æŸ¥é€‰é¡¹
2. **ç±»å‹ä¼˜å…ˆ**: å…ˆå®šä¹‰ç±»å‹ï¼Œå†ç¼–å†™å®ç°
3. **æ³›å‹ä½¿ç”¨**: åˆç†ä½¿ç”¨æ³›å‹æé«˜ä»£ç å¤ç”¨æ€§
4. **ç±»å‹ä¿æŠ¤**: ä½¿ç”¨ç±»å‹ä¿æŠ¤å‡½æ•°ç¡®ä¿è¿è¡Œæ—¶å®‰å…¨
5. **æ¸è¿›å¼é‡‡ç”¨**: åœ¨ç°æœ‰é¡¹ç›®ä¸­é€æ­¥å¼•å…¥TypeScript
6. **æ–‡æ¡£åŒ–**: ä½¿ç”¨JSDocä¸ºå¤æ‚ç±»å‹æ·»åŠ æ–‡æ¡£
::

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

::code-group
```typescript [ç±»å‹æ–­è¨€å’Œä¿æŠ¤]
// âŒ é¿å…ä½¿ç”¨ any
const data: any = await $fetch('/api/users');

// âœ… ä½¿ç”¨å…·ä½“ç±»å‹
const data: User[] = await $fetch<User[]>('/api/users');

// âŒ å¼ºåˆ¶ç±»å‹è½¬æ¢
const user = response as User;

// âœ… ä½¿ç”¨ç±»å‹ä¿æŠ¤
function isUser(obj: any): obj is User {
  return obj
    && typeof obj.id === 'number'
    && typeof obj.name === 'string'
    && typeof obj.email === 'string';
}

if (isUser(response)) {
  // è¿™é‡Œ response çš„ç±»å‹æ˜¯ User
  console.log(response.name);
}
```

```typescript [å·¥å…·ç±»å‹çš„ä½¿ç”¨]
// âœ… ä½¿ç”¨å·¥å…·ç±»å‹é¿å…é‡å¤
interface CreateUserForm extends Omit<User, 'id' | 'createdAt' | 'updatedAt'> {
  confirmPassword: string;
}

// âœ… æ¡ä»¶ç±»å‹ç”¨äºAPIå“åº”
type ApiResult<T, E = ApiError>
  = | { success: true; data: T }
    | { success: false; error: E };

// âœ… æ˜ å°„ç±»å‹ç”¨äºè¡¨å•çŠ¶æ€
type FormState<T> = {
  [K in keyof T]: {
    value: T[K];
    error?: string;
    touched: boolean;
  }
};
```
::

## ğŸš€ ä¸‹ä¸€æ­¥å­¦ä¹ 

æŒæ¡äº†TypeScripté›†æˆåï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

:::card-group{cols=2}
  ::::card{icon="lucide:workflow"}
  #title
  [å¼€å‘å·¥ä½œæµ](/getting-started/writing/development-workflow)
  #description
  å­¦ä¹ ç°ä»£åŒ–çš„å¼€å‘å·¥ä½œæµå’Œå·¥å…·é“¾
  ::::
:::

