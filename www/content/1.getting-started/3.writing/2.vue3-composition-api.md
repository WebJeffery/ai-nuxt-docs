---
title: Vue3 ç»„åˆå¼API
description: æ·±å…¥æŒæ¡Vue3ç»„åˆå¼APIçš„æ ¸å¿ƒæ¦‚å¿µã€æœ€ä½³å®è·µå’Œä¼ä¸šçº§åº”ç”¨ï¼Œæå‡ä»£ç å¤ç”¨æ€§å’Œå¯ç»´æŠ¤æ€§
icon: 'lucide:code'
---

## ğŸ¯ ç»„åˆå¼APIæ¦‚è§ˆ

**Vue3ç»„åˆå¼APIï¼ˆComposition APIï¼‰**æ˜¯Vue3å¼•å…¥çš„æ–°ç¼–ç¨‹èŒƒå¼ï¼Œå®ƒæä¾›äº†æ›´çµæ´»çš„é€»è¾‘ç»„ç»‡æ–¹å¼ï¼Œç‰¹åˆ«é€‚åˆå¤æ‚çš„ä¼ä¸šçº§åº”ç”¨å¼€å‘ã€‚ç›¸æ¯”äºé€‰é¡¹å¼APIï¼Œç»„åˆå¼APIæä¾›äº†æ›´å¥½çš„TypeScriptæ”¯æŒã€æ›´å¼ºçš„é€»è¾‘å¤ç”¨èƒ½åŠ›å’Œæ›´æ¸…æ™°çš„ä»£ç ç»„ç»‡ç»“æ„ã€‚

::alert{icon="lucide:info" color="blue"}
**ä¸ºä»€ä¹ˆä½¿ç”¨ç»„åˆå¼APIï¼Ÿ**
- ğŸ”§ **æ›´å¥½çš„é€»è¾‘å¤ç”¨**: é€šè¿‡ç»„åˆå¼å‡½æ•°å°è£…å’Œå¤ç”¨ä¸šåŠ¡é€»è¾‘
- ğŸ“š **æ›´æ¸…æ™°çš„ä»£ç ç»„ç»‡**: æŒ‰åŠŸèƒ½è€Œéé€‰é¡¹ç»„ç»‡ä»£ç 
- ğŸ¯ **æ›´å¼ºçš„TypeScriptæ”¯æŒ**: å¤©ç„¶çš„ç±»å‹æ¨å¯¼å’Œæ™ºèƒ½æç¤º
- âš¡ **æ›´å¥½çš„æ€§èƒ½**: æ›´ç²¾ç¡®çš„ä¾èµ–è¿½è¸ªå’Œæ›´å°‘çš„æ¸²æŸ“å‹åŠ›
::

## ğŸ§© æ ¸å¿ƒAPIè¯¦è§£

### ref() - å“åº”å¼å¼•ç”¨

`ref()` ç”¨äºåˆ›å»ºå“åº”å¼çš„æ•°æ®å¼•ç”¨ï¼š

::code-group
```vue [åŸºç¡€ç”¨æ³•]
<template>
  <div>
    <p>è®¡æ•°å™¨: {{ count }}</p>
    <p>ç”¨æˆ·å: {{ user.name }}</p>
    <button @click="increment">
      å¢åŠ 
    </button>
    <input v-model="user.name" placeholder="è¾“å…¥ç”¨æˆ·å">
  </div>
</template>

<script setup>
// åŸºæœ¬ç±»å‹çš„å“åº”å¼
const count = ref(0);

// å¯¹è±¡ç±»å‹çš„å“åº”å¼
const user = ref({
  name: 'å¼ ä¸‰',
  age: 25
});

// æ–¹æ³•
function increment() {
  count.value++;
}

// ç›‘å¬å˜åŒ–
watch(count, (newValue, oldValue) => {
  console.log(`è®¡æ•°ä» ${oldValue} å˜ä¸º ${newValue}`);
});
</script>
```

```vue [TypeScriptæ”¯æŒ]
<template>
  <div>
    <UserCard :user="currentUser" />
    <LoadingSpinner v-if="isLoading" />
  </div>
</template>

<script setup lang="ts">
// å®šä¹‰ç±»å‹
interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

// ç±»å‹åŒ–çš„ref
const currentUser = ref<User | null>(null);
const isLoading = ref<boolean>(false);
const userList = ref<User[]>([]);

// å¼‚æ­¥æ•°æ®è·å–
async function fetchUser(id: number) {
  isLoading.value = true;
  try {
    const response = await $fetch<User>(`/api/users/${id}`);
    currentUser.value = response;
  } catch (error) {
    console.error('è·å–ç”¨æˆ·å¤±è´¥:', error);
  } finally {
    isLoading.value = false;
  }
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  fetchUser(1);
});
</script>
```
::

### reactive() - å“åº”å¼å¯¹è±¡

`reactive()` ç”¨äºåˆ›å»ºæ·±åº¦å“åº”å¼çš„å¯¹è±¡ï¼š

```vue [reactiveç¤ºä¾‹]
<template>
  <div>
    <form @submit.prevent="handleSubmit">
      <input v-model="form.email" type="email" placeholder="é‚®ç®±">
      <input v-model="form.password" type="password" placeholder="å¯†ç ">
      <button type="submit" :disabled="!isFormValid">
        ç™»å½•
      </button>
    </form>

    <div v-if="form.errors.email" class="error">
      {{ form.errors.email }}
    </div>
  </div>
</template>

<script setup>
// å“åº”å¼è¡¨å•å¯¹è±¡
const form = reactive({
  email: '',
  password: '',
  errors: {
    email: '',
    password: ''
  }
});

// è®¡ç®—å±æ€§
const isFormValid = computed(() => {
  return form.email && form.password && !form.errors.email && !form.errors.password;
});

// è¡¨å•éªŒè¯
function validateEmail() {
  const emailRegex = /^[^\s@]+@[^\s@][^\s.@]*\.[^\s@]+$/;
  form.errors.email = emailRegex.test(form.email) ? '' : 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€';
}

// ç›‘å¬å­—æ®µå˜åŒ–
watch(() => form.email, validateEmail);

// è¡¨å•æäº¤
async function handleSubmit() {
  if (!isFormValid.value)
    return;

  try {
    await $fetch('/api/auth/login', {
      method: 'POST',
      body: {
        email: form.email,
        password: form.password
      }
    });

    // ç™»å½•æˆåŠŸåçš„å¤„ç†
    navigateTo('/dashboard');
  } catch (error) {
    form.errors.email = error.data?.message || 'ç™»å½•å¤±è´¥';
  }
}
</script>
```

### computed() - è®¡ç®—å±æ€§

è®¡ç®—å±æ€§ç”¨äºæ´¾ç”ŸçŠ¶æ€ï¼š

::code-group
```vue [åŸºç¡€è®¡ç®—å±æ€§]
<template>
  <div>
    <div class="shopping-cart">
      <div v-for="item in cartItems" :key="item.id" class="cart-item">
        <span>{{ item.name }}</span>
        <span>{{ item.price }} Ã— {{ item.quantity }}</span>
        <span>{{ item.total }}</span>
      </div>
      <div class="cart-summary">
        <p>å•†å“æ•°é‡: {{ totalItems }}</p>
        <p>æ€»ä»·æ ¼: Â¥{{ totalPrice }}</p>
        <p>ä¼˜æƒ å: Â¥{{ finalPrice }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
const cartItems = ref([
  { id: 1, name: 'å•†å“A', price: 100, quantity: 2 },
  { id: 2, name: 'å•†å“B', price: 200, quantity: 1 },
  { id: 3, name: 'å•†å“C', price: 50, quantity: 3 }
]);

const discount = ref(0.1); // 10%æŠ˜æ‰£

// è®¡ç®—æ¯ä¸ªå•†å“çš„å°è®¡
const enhancedCartItems = computed(() => {
  return cartItems.value.map(item => ({
    ...item,
    total: item.price * item.quantity
  }));
});

// è®¡ç®—æ€»æ•°é‡
const totalItems = computed(() => {
  return cartItems.value.reduce((sum, item) => sum + item.quantity, 0);
});

// è®¡ç®—æ€»ä»·æ ¼
const totalPrice = computed(() => {
  return cartItems.value.reduce((sum, item) => sum + (item.price * item.quantity), 0);
});

// è®¡ç®—æŠ˜æ‰£åä»·æ ¼
const finalPrice = computed(() => {
  return totalPrice.value * (1 - discount.value);
});
</script>
```

```vue [å¯å†™è®¡ç®—å±æ€§]
<template>
  <div>
    <input v-model="fullName" placeholder="è¯·è¾“å…¥å…¨å">
    <p>å§“: {{ firstName }}</p>
    <p>å: {{ lastName }}</p>
  </div>
</template>

<script setup>
const firstName = ref('å¼ ');
const lastName = ref('ä¸‰');

// å¯å†™çš„è®¡ç®—å±æ€§
const fullName = computed({
  get() {
    return `${firstName.value} ${lastName.value}`;
  },
  set(value) {
    const parts = value.split(' ');
    firstName.value = parts[0] || '';
    lastName.value = parts[1] || '';
  }
});
</script>
```
::

### watch() - ä¾¦å¬å™¨

ä¾¦å¬å™¨ç”¨äºå“åº”æ•°æ®å˜åŒ–ï¼š

::code-group
```vue [åŸºç¡€ä¾¦å¬]
<template>
  <div>
    <input v-model="searchQuery" placeholder="æœç´¢ç”¨æˆ·...">
    <div v-if="isSearching">
      æœç´¢ä¸­...
    </div>
    <UserList :users="searchResults" />
  </div>
</template>

<script setup>
const searchQuery = ref('');
const searchResults = ref([]);
const isSearching = ref(false);

// ç›‘å¬æœç´¢æŸ¥è¯¢
watch(searchQuery, async (newQuery, oldQuery) => {
  if (!newQuery) {
    searchResults.value = [];
    return;
  }

  // é˜²æŠ–æœç´¢
  clearTimeout(searchTimer.value);
  searchTimer.value = setTimeout(async () => {
    isSearching.value = true;
    try {
      const results = await $fetch('/api/users/search', {
        query: { q: newQuery }
      });
      searchResults.value = results;
    } catch (error) {
      console.error('æœç´¢å¤±è´¥:', error);
    } finally {
      isSearching.value = false;
    }
  }, 300);
});

const searchTimer = ref(null);

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨
onUnmounted(() => {
  clearTimeout(searchTimer.value);
});
</script>
```

```vue [æ·±åº¦ä¾¦å¬]
<template>
  <div>
    <UserProfile v-model:user="userProfile" />
    <div v-if="hasUnsavedChanges" class="warning">
      æ‚¨æœ‰æœªä¿å­˜çš„æ›´æ”¹
    </div>
  </div>
</template>

<script setup>
const userProfile = ref({
  personal: {
    name: '',
    email: '',
    phone: ''
  },
  preferences: {
    theme: 'light',
    language: 'zh-CN',
    notifications: {
      email: true,
      sms: false
    }
  }
});

const originalProfile = ref(null);
const hasUnsavedChanges = ref(false);

// æ·±åº¦ç›‘å¬å¯¹è±¡å˜åŒ–
watch(
  userProfile,
  (newProfile) => {
    hasUnsavedChanges.value = JSON.stringify(newProfile) !== JSON.stringify(originalProfile.value);
  },
  { deep: true }
);

// ç›‘å¬å¤šä¸ªæº
watch(
  [() => userProfile.value.personal.email, () => userProfile.value.personal.phone],
  ([newEmail, newPhone], [oldEmail, oldPhone]) => {
    console.log('è”ç³»æ–¹å¼å‘ç”Ÿå˜åŒ–');
    // éªŒè¯è”ç³»æ–¹å¼
    validateContactInfo();
  }
);

// ç«‹å³æ‰§è¡Œçš„ä¾¦å¬å™¨
watchEffect(() => {
  // è‡ªåŠ¨ä¿å­˜è‰ç¨¿
  if (hasUnsavedChanges.value) {
    saveDraft(userProfile.value);
  }
});
</script>
```
::

## ğŸ”„ ç”Ÿå‘½å‘¨æœŸé’©å­

Vue3åœ¨ç»„åˆå¼APIä¸­æä¾›äº†å¯¹åº”çš„ç”Ÿå‘½å‘¨æœŸé’©å­ï¼š

```vue [ç”Ÿå‘½å‘¨æœŸç¤ºä¾‹]
<template>
  <div>
    <div v-if="isLoading">
      åŠ è½½ä¸­...
    </div>
    <div v-else-if="error">
      {{ error }}
    </div>
    <div v-else>
      <DataVisualization :data="chartData" />
      <RealTimeUpdates />
    </div>
  </div>
</template>

<script setup>
const chartData = ref([]);
const isLoading = ref(true);
const error = ref(null);
const updateInterval = ref(null);

// ç»„ä»¶æŒ‚è½½å‰
onBeforeMount(() => {
  console.log('ç»„ä»¶å³å°†æŒ‚è½½');
  // åˆå§‹åŒ–é…ç½®
  initializeConfig();
});

// ç»„ä»¶æŒ‚è½½å
onMounted(async () => {
  console.log('ç»„ä»¶å·²æŒ‚è½½');

  try {
    // è·å–åˆå§‹æ•°æ®
    await fetchInitialData();

    // å¯åŠ¨å®æ—¶æ›´æ–°
    startRealTimeUpdates();

    // æ³¨å†Œé”®ç›˜äº‹ä»¶
    document.addEventListener('keydown', handleKeyPress);
  } catch (err) {
    error.value = 'æ•°æ®åŠ è½½å¤±è´¥';
  } finally {
    isLoading.value = false;
  }
});

// ç»„ä»¶æ›´æ–°å‰
onBeforeUpdate(() => {
  console.log('ç»„ä»¶å³å°†æ›´æ–°');
});

// ç»„ä»¶æ›´æ–°å
onUpdated(() => {
  console.log('ç»„ä»¶å·²æ›´æ–°');
  // é‡æ–°è®¡ç®—å›¾è¡¨å°ºå¯¸
  nextTick(() => {
    resizeCharts();
  });
});

// ç»„ä»¶å¸è½½å‰
onBeforeUnmount(() => {
  console.log('ç»„ä»¶å³å°†å¸è½½');
  // æ¸…ç†å®šæ—¶å™¨
  if (updateInterval.value) {
    clearInterval(updateInterval.value);
  }

  // ç§»é™¤äº‹ä»¶ç›‘å¬
  document.removeEventListener('keydown', handleKeyPress);
});

// ç»„ä»¶å¸è½½å
onUnmounted(() => {
  console.log('ç»„ä»¶å·²å¸è½½');
});

// é”™è¯¯æ•è·
onErrorCaptured((err, instance, info) => {
  console.error('æ•è·åˆ°é”™è¯¯:', err, info);
  error.value = 'åº”ç”¨å‡ºç°é”™è¯¯';
  return false; // é˜»æ­¢é”™è¯¯ç»§ç»­ä¼ æ’­
});

// ä¸šåŠ¡é€»è¾‘å‡½æ•°
async function fetchInitialData() {
  const response = await $fetch('/api/dashboard/data');
  chartData.value = response.data;
}

function startRealTimeUpdates() {
  updateInterval.value = setInterval(async () => {
    try {
      const updates = await $fetch('/api/dashboard/updates');
      applyUpdates(updates);
    } catch (err) {
      console.error('å®æ—¶æ›´æ–°å¤±è´¥:', err);
    }
  }, 5000);
}

function handleKeyPress(event) {
  if (event.key === 'F5') {
    event.preventDefault();
    refreshData();
  }
}
</script>
```

## ğŸ§° ç»„åˆå¼å‡½æ•°ï¼ˆComposablesï¼‰

ç»„åˆå¼å‡½æ•°æ˜¯Vue3ä¸­æœ€å¼ºå¤§çš„ç‰¹æ€§ä¹‹ä¸€ï¼Œç”¨äºå°è£…å’Œå¤ç”¨å“åº”å¼çŠ¶æ€é€»è¾‘ï¼š

### è®¤è¯ç›¸å…³ç»„åˆå¼å‡½æ•°

::code-group
```typescript [composables/useAuth.ts]
export interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
  avatar?: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export function useAuth() {
  // çŠ¶æ€
  const user = useState<User | null>('auth.user', () => null);
  const isLoading = ref(false);
  const error = ref<string>('');

  // è®¡ç®—å±æ€§
  const isLoggedIn = computed(() => !!user.value);
  const isAdmin = computed(() => user.value?.role === 'admin');
  const userName = computed(() => user.value?.name || 'æ¸¸å®¢');

  // ç™»å½•æ–¹æ³•
  const login = async (credentials: LoginCredentials) => {
    isLoading.value = true;
    error.value = '';

    try {
      const response = await $fetch<{ user: User; token: string }>('/api/auth/login', {
        method: 'POST',
        body: credentials
      });

      // å­˜å‚¨ç”¨æˆ·ä¿¡æ¯
      user.value = response.user;

      // å­˜å‚¨tokenåˆ°cookie
      const authCookie = useCookie('auth-token', {
        default: () => '',
        maxAge: 60 * 60 * 24 * 7, // 7å¤©
        secure: true,
        sameSite: 'strict'
      });
      authCookie.value = response.token;

      // å¯¼èˆªåˆ°ä»ªè¡¨æ¿
      await navigateTo('/dashboard');
    } catch (err: any) {
      error.value = err.data?.message || 'ç™»å½•å¤±è´¥';
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  // æ³¨å†Œæ–¹æ³•
  const register = async (userData: Omit<User, 'id'> & { password: string }) => {
    isLoading.value = true;
    error.value = '';

    try {
      const response = await $fetch<{ user: User }>('/api/auth/register', {
        method: 'POST',
        body: userData
      });

      // æ³¨å†ŒæˆåŠŸåè‡ªåŠ¨ç™»å½•
      await login({
        email: userData.email,
        password: userData.password
      });
    } catch (err: any) {
      error.value = err.data?.message || 'æ³¨å†Œå¤±è´¥';
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  // ç™»å‡ºæ–¹æ³•
  const logout = async () => {
    try {
      await $fetch('/api/auth/logout', { method: 'POST' });
    } catch (err) {
      console.error('ç™»å‡ºè¯·æ±‚å¤±è´¥:', err);
    } finally {
      // æ¸…ç†çŠ¶æ€
      user.value = null;

      // æ¸…ç†cookie
      const authCookie = useCookie('auth-token');
      authCookie.value = '';

      // å¯¼èˆªåˆ°ç™»å½•é¡µ
      await navigateTo('/login');
    }
  };

  // åˆ·æ–°ç”¨æˆ·ä¿¡æ¯
  const refreshUser = async () => {
    if (!isLoggedIn.value)
      return;

    try {
      const response = await $fetch<User>('/api/auth/me');
      user.value = response;
    } catch (err) {
      console.error('åˆ·æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', err);
      await logout();
    }
  };

  // æ£€æŸ¥æƒé™
  const hasPermission = (permission: string): boolean => {
    if (!user.value)
      return false;

    // ç®€å•çš„æƒé™æ£€æŸ¥é€»è¾‘
    const permissions = {
      admin: ['read', 'write', 'delete', 'manage'],
      user: ['read', 'write'],
      guest: ['read']
    };

    return permissions[user.value.role]?.includes(permission) || false;
  };

  return {
    // çŠ¶æ€
    user: readonly(user),
    isLoading: readonly(isLoading),
    error: readonly(error),

    // è®¡ç®—å±æ€§
    isLoggedIn,
    isAdmin,
    userName,

    // æ–¹æ³•
    login,
    register,
    logout,
    refreshUser,
    hasPermission
  };
}
```

```typescript [composables/useApi.ts]
interface ApiOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: any;
  headers?: Record<string, string>;
  query?: Record<string, any>;
}

interface ApiResponse<T> {
  data: T;
  loading: Ref<boolean>;
  error: Ref<string | null>;
  refresh: () => Promise<void>;
}

export function useApi() {
  const { isLoggedIn } = useAuth();

  // é€šç”¨APIè¯·æ±‚æ–¹æ³•
  const request = async <T>(url: string, options: ApiOptions = {}): Promise<T> => {
    const { method = 'GET', body, headers = {}, query } = options;

    // æ·»åŠ è®¤è¯å¤´
    if (isLoggedIn.value) {
      const authCookie = useCookie('auth-token');
      if (authCookie.value) {
        headers.Authorization = `Bearer ${authCookie.value}`;
      }
    }

    try {
      const response = await $fetch<T>(url, {
        method,
        body,
        headers,
        query
      });

      return response;
    } catch (error: any) {
      // ç»Ÿä¸€é”™è¯¯å¤„ç†
      if (error.status === 401) {
        // æœªæˆæƒï¼Œæ¸…é™¤è®¤è¯çŠ¶æ€
        const { logout } = useAuth();
        await logout();
      }

      throw error;
    }
  };

  // å“åº”å¼APIè°ƒç”¨
  const useAsyncData = <T>(
    key: string,
    url: string,
    options: ApiOptions = {}
  ): ApiResponse<T> => {
    const data = ref<T | null>(null);
    const loading = ref(false);
    const error = ref<string | null>(null);

    const execute = async () => {
      loading.value = true;
      error.value = null;

      try {
        const response = await request<T>(url, options);
        data.value = response;
      } catch (err: any) {
        error.value = err.data?.message || 'è¯·æ±‚å¤±è´¥';
      } finally {
        loading.value = false;
      }
    };

    // åˆå§‹æ‰§è¡Œ
    execute();

    return {
      data: readonly(data) as Ref<T>,
      loading: readonly(loading),
      error: readonly(error),
      refresh: execute
    };
  };

  return {
    request,
    useAsyncData
  };
}
```
::

### AIæœåŠ¡ç»„åˆå¼å‡½æ•°

```typescript [composables/useAI.ts]
interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
}

interface AIGenerateOptions {
  model?: 'gpt-4' | 'gpt-3.5-turbo' | 'claude-3-haiku';
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
}

export function useAI() {
  const conversation = ref<ChatMessage[]>([]);
  const isGenerating = ref(false);
  const error = ref<string>('');

  // å‘é€èŠå¤©æ¶ˆæ¯
  const sendMessage = async (content: string, options: AIGenerateOptions = {}) => {
    isGenerating.value = true;
    error.value = '';

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMessage: ChatMessage = {
      id: generateId(),
      role: 'user',
      content,
      timestamp: new Date()
    };
    conversation.value.push(userMessage);

    try {
      const response = await $fetch<{ response: string }>('/api/ai/chat', {
        method: 'POST',
        body: {
          message: content,
          conversation: conversation.value.slice(-10), // ä¿ç•™æœ€è¿‘10æ¡æ¶ˆæ¯
          options
        }
      });

      // æ·»åŠ AIå›å¤
      const aiMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: response.response,
        timestamp: new Date()
      };
      conversation.value.push(aiMessage);
    } catch (err: any) {
      error.value = err.data?.message || 'AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨';
    } finally {
      isGenerating.value = false;
    }
  };

  // ç”Ÿæˆæ–‡æœ¬
  const generateText = async (prompt: string, options: AIGenerateOptions = {}) => {
    const result = ref<string>('');
    const loading = ref(true);
    const generateError = ref<string>('');

    try {
      const response = await $fetch<{ text: string }>('/api/ai/generate', {
        method: 'POST',
        body: { prompt, options }
      });

      result.value = response.text;
    } catch (err: any) {
      generateError.value = err.data?.message || 'ç”Ÿæˆå¤±è´¥';
    } finally {
      loading.value = false;
    }

    return {
      result: readonly(result),
      loading: readonly(loading),
      error: readonly(generateError)
    };
  };

  // æ¸…ç©ºå¯¹è¯
  const clearConversation = () => {
    conversation.value = [];
  };

  // ç”Ÿæˆå”¯ä¸€ID
  const generateId = () => {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  };

  return {
    conversation: readonly(conversation),
    isGenerating: readonly(isGenerating),
    error: readonly(error),
    sendMessage,
    generateText,
    clearConversation
  };
}
```

## ğŸ¯ æœ€ä½³å®è·µ

::alert{icon="lucide:lightbulb" color="blue"}
### ğŸŒŸ ç»„åˆå¼APIå¼€å‘å»ºè®®

1. **é€»è¾‘åˆ†ç»„**: å°†ç›¸å…³çš„çŠ¶æ€å’Œé€»è¾‘ç»„ç»‡åœ¨ä¸€èµ·
2. **ç»„åˆå¼å‡½æ•°**: å°†å¯å¤ç”¨çš„é€»è¾‘å°è£…æˆç»„åˆå¼å‡½æ•°
3. **ç±»å‹å®‰å…¨**: å……åˆ†åˆ©ç”¨TypeScriptç±»å‹å®šä¹‰
4. **æ€§èƒ½ä¼˜åŒ–**: åˆç†ä½¿ç”¨`readonly`ã€`shallowRef`ç­‰
5. **é”™è¯¯å¤„ç†**: å»ºç«‹ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶
6. **ç”Ÿå‘½å‘¨æœŸ**: æ­£ç¡®ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸé’©å­è¿›è¡Œèµ„æºç®¡ç†
::

### å¸¸è§æ¨¡å¼

::code-group
```vue [è¡¨å•å¤„ç†æ¨¡å¼]
<template>
  <form @submit.prevent="handleSubmit">
    <div v-for="field in formFields" :key="field.name">
      <label>{{ field.label }}</label>
      <input
        v-model="form[field.name]"
        :type="field.type"
        :placeholder="field.placeholder"
        @blur="validateField(field.name)"
      >
      <div v-if="errors[field.name]" class="error">
        {{ errors[field.name] }}
      </div>
    </div>
    <button type="submit" :disabled="!isValid">
      æäº¤
    </button>
  </form>
</template>

<script setup>
const formFields = [
  { name: 'name', label: 'å§“å', type: 'text', placeholder: 'è¯·è¾“å…¥å§“å' },
  { name: 'email', label: 'é‚®ç®±', type: 'email', placeholder: 'è¯·è¾“å…¥é‚®ç®±' },
  { name: 'phone', label: 'ç”µè¯', type: 'tel', placeholder: 'è¯·è¾“å…¥ç”µè¯' }
];

// ä½¿ç”¨è¡¨å•ç»„åˆå¼å‡½æ•°
const {
  form,
  errors,
  isValid,
  validateField,
  resetForm
} = useForm({
  name: '',
  email: '',
  phone: ''
}, {
  name: { required: true, minLength: 2 },
  email: { required: true, email: true },
  phone: { required: true, phone: true }
});

async function handleSubmit() {
  if (!isValid.value)
    return;

  try {
    await submitForm(form.value);
    resetForm();
  } catch (error) {
    console.error('æäº¤å¤±è´¥:', error);
  }
}
</script>
```

```vue [æ•°æ®åˆ—è¡¨æ¨¡å¼]
<template>
  <div>
    <!-- æœç´¢å’Œç­›é€‰ -->
    <div class="filters">
      <input v-model="searchQuery" placeholder="æœç´¢...">
      <select v-model="statusFilter">
        <option value="">
          å…¨éƒ¨çŠ¶æ€
        </option>
        <option value="active">
          æ´»è·ƒ
        </option>
        <option value="inactive">
          éæ´»è·ƒ
        </option>
      </select>
    </div>

    <!-- æ•°æ®åˆ—è¡¨ -->
    <div v-if="loading">
      åŠ è½½ä¸­...
    </div>
    <div v-else-if="error">
      {{ error }}
    </div>
    <div v-else>
      <DataTable
        :items="filteredItems"
        :columns="columns"
        @sort="handleSort"
        @edit="handleEdit"
        @delete="handleDelete"
      />

      <!-- åˆ†é¡µ -->
      <Pagination
        v-model:page="currentPage"
        :total="totalItems"
        :per-page="pageSize"
      />
    </div>
  </div>
</template>

<script setup>
// ä½¿ç”¨æ•°æ®åˆ—è¡¨ç»„åˆå¼å‡½æ•°
const {
  items,
  loading,
  error,
  searchQuery,
  statusFilter,
  currentPage,
  pageSize,
  totalItems,
  sortBy,
  sortOrder,
  filteredItems,
  refresh,
  handleSort,
  handleEdit,
  handleDelete
} = useDataList('/api/users', {
  defaultSort: 'name',
  defaultPageSize: 20
});

const columns = [
  { key: 'name', label: 'å§“å', sortable: true },
  { key: 'email', label: 'é‚®ç®±', sortable: true },
  { key: 'status', label: 'çŠ¶æ€', sortable: false },
  { key: 'actions', label: 'æ“ä½œ', sortable: false }
];
</script>
```
::

## ğŸš€ ä¸‹ä¸€æ­¥å­¦ä¹ 

æŒæ¡äº†Vue3ç»„åˆå¼APIåï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

:::card-group{cols=2}
  ::::card{icon="lucide:type"}
  #title
  [TypeScripté›†æˆ](/getting-started/writing/typescript-integration)
  #description
  å­¦ä¹ TypeScriptåœ¨Vue3ä¸­çš„æ·±åº¦é›†æˆ
  ::::

  ::::card{icon="lucide:workflow"}
  #title
  [å¼€å‘å·¥ä½œæµ](/getting-started/writing/development-workflow)
  #description
  æŒæ¡ç°ä»£åŒ–çš„å¼€å‘å·¥ä½œæµå’Œå·¥å…·é“¾
  ::::
:::
